<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utf-8">
    <title>Google C++ スタイルガイド(日本語全訳) Google C++ Style Guide (Japanese)</title>
    <link rel="stylesheet" href="include/styleguide.ja.css">
    <script src="include/styleguide.ja.js"></script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <style>
        /* 翻訳ポップアップ */
        span:hover { background-color: #FFC; }

        #tip_popup {
            position: absolute;
            border: 1px solid black;
            max-width: 50%;
            background-color: #EFF;
            padding: 8px;
            z-index: 100;
            left: -99999px;
        }

        span.src,
        div.src {
            display: none;
        }
    </style>
    <script>
        // 翻訳ポップアップ
        $(document).ready(function () {
            $("body").append('<div id="tip_popup"></div>');
            var tip = $('#tip_popup');
            $("span,div").each(function () {
                if ($(this).attr("title")) {
                    $(this).attr("data-title", $(this).attr("title"));
                    $(this).removeAttr("title");
                    $(this).mousemove(function (m) { tip.html($(this).attr("data-title")); });
                    $(this).mousemove(function (m) { tip.css({ left: (m.pageX + 20) + "px", top: (m.pageY + 20) + "px" }); });
                    $(this).mouseout(function () { tip.css({ left: "-99999px" }); });
                }
                else if ($(this).children(".src").html()) {
                    $(this).mousemove(function (m) { tip.html($(this).children(".src").html()); });
                    $(this).mousemove(function (m) { tip.css({ left: (m.pageX + 20) + "px", top: (m.pageY + 20) + "px" }); });
                    $(this).mouseout(function () { tip.css({ left: "-99999px" }); });
                }
            });
        });
    </script>
    <link rel="shortcut icon" href="https://www.google.com/favicon.ico" />

    <script async defer src="https://buttons.github.io/buttons.js"></script>
</head>

<body onload="initStyleGuide();">
    <div id="content">
        <h1>
            <span title="Google C++ Style Guide">Google C++ スタイルガイド</span> 日本語全訳
        </h1>
        <h2 class="ignoreLink">訳者前書き</h2>
        <ul>
            <li>本ドキュメントは<a href="https://github.com/google/styleguide/">https://github.com/google/styleguide/</a> にて公開されているGoogle C++ Style Guideを日本語に訳したものです。</li>
            <li>オリジナルの最新版は <a href="https://google.github.io/styleguide/cppguide.html">https://google.github.io/styleguide/cppguide.html</a>で読むことができます。</li>
            <li>commit <a href="https://github.com/google/styleguide/blob/6ebcd8cee24e6eb5e56efaec55d44873eb224f97/cppguide.html">6ebcd8c (Oct 24, 2023)</a> 時点のものを底本としています。</li>
            <li>オリジナルと同様<a href="https://creativecommons.org/licenses/by/3.0/">CC-By 3.0 License</a>で頒布します。</li>
            <li>誤訳を含んでいる恐れがあります。訳文にマウスを重ねると原文が表示されますので、そちらもあわせて参照してください。</li>
            <li>訳者はGoogleと無関係です。</li>
            <li>誤訳の指摘・改善案は GitHub の <a href="https://github.com/ttsuki/styleguide/issues">Issues</a> か <a href="https://github.com/ttsuki/styleguide/pulls">Pull Requests</a> からお願いします。</li>
            <li>☆をつけてもらえると励みになります;) <a class="github-button" href="https://github.com/ttsuki/styleguide" data-color-scheme="no-preference: light; light: light; dark: dark;" data-icon="octicon-star" data-show-count="true" aria-label="Star ttsuki/styleguide on GitHub">Star:</a></li>
       </ul>

        <div class="horizontal_toc" id="tocDiv"></div>

        <h2 id="Background" class="ignoreLink"><span title="Background">背景</span></h2>

        <p>
            <span>
                <span class="src">
                    C++ is one of the main development languages used by
                    many of Google's open-source projects.
                </span>
                C++は、多くのGoogleのオープンソースプロジェクトで採用されている主要言語のうちのひとつです。
            </span>
            <span>
                <span class="src">
                    As every C++
                    programmer knows, the language has many powerful features, but
                    this power brings with it complexity, which in turn can make
                    code more bug-prone and harder to read and maintain.
                </span>
                C++プログラマーの誰もが知っているように、この言語にはたくさんのパワフルな機能がありますが、パワフルであると同時に非常に複雑でもあります。そして、この複雑さこそが、ときに、バグを埋め込んでしまう要因となったり、あるいは、コードを読みにくくメンテナンスしにくいものにしてしまう要因となったりします。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    The goal of this guide is to manage this complexity by
                    describing in detail the dos and don'ts of writing C++
                    code.
                </span>
                このガイドでは、C++のコードを書くときにすべきこと・すべきでないことについて詳しく説明し、C++のもつ様々な複雑さに対処できるようにすることを目標としています。
            </span>
            <span>
                <span class="src">
                    These rules exist to
                    keep the code base manageable while still allowing
                    coders to use C++ language features productively.
                </span>
                これらのルールによって、C++の生産的な言語機能を活かしつつも、コードベースを管理可能な状態に保つことができるようになるはずです。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    <em>Style</em>, also known as readability, is what we call
                    the conventions that govern our C++ code.
                </span>
                「<em>スタイル</em>」という用語は、一般には可読性(readability/リーダビリティ)としても知られる語ですが、本ガイドにおいては、私たちのC++コードが従うべきコーディング規約全般のことを指します。
            </span>
            <span>
                <span class="src">
                    The term Style is a
                    bit of a misnomer, since these conventions cover far more than
                    just source file formatting.
                </span>
                このコーディング規約では、単なるソースコードのフォーマットだけではなく、もっと広い範囲もカバーしているため、<em>スタイル</em>という用語を充てるのには少し語弊があるかもしれません。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Most open-source projects developed by
                    Google conform to the requirements in this guide.
                </span>
                ほとんどのGoogleのオープンソースプロジェクトが、本ガイドのルールに従って開発されています。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Note that this guide is not a C++ tutorial: we assume that
                    the reader is familiar with the language.
                </span>
                なお、このガイドはC++のチュートリアルではありません。むしろ、本ガイドは、C++に精通した読者に向けて書かれていますので、その点に注意してください。
            </span>
        </p>

        <h3 id="Goals">
            <span title="Goals of the Style Guide">このスタイルガイドのゴール</span>
        </h3>
        <p>
            <span>
                <span class="src">
                    Why do we have this document?
                </span>
                何のために、この文書があるのでしょうか？
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    There are a few core goals that we believe this guide should
                    serve.
                </span>
                まず、このガイドで果たそうとしている中心的な目標、すなわちゴールがいくつかあります。
            </span>
            <span>
                <span class="src">
                    These are the fundamental <b>why</b>s that
                    underlie all of the individual rules.
                </span>
                それらは、このガイドで説明されるすべての個々のルールの基礎となる、その基本的な「<strong>理由</strong>」の集合です。
            </span>
            <span>
                <span class="src">
                    By bringing these ideas to
                    the fore, we hope to ground discussions and make it clearer to our
                    broader community why the rules are in place and why particular
                    decisions have been made.
                </span>
                私たちは、これらの考え方を前面に出すことで、議論を根付かせ、なぜそのルールがあるのか、なぜそのように決められているのかを、より広い範囲のコミュニティで明確になるようにしていきたいと考えています。
            </span>
            <span>
                <span class="src">
                    If you understand what goals each rule is
                    serving, it should be clearer to everyone when a rule may be waived
                    (some can be), and what sort of argument or alternative would be
                    necessary to change a rule in the guide.
                </span>
                それぞれのルールによって何を達成しようとしているのか、その目的を正しく理解することによって、逆に、どのような場合にルールを放棄すべきか、あるいは、ルールを変更するために必要な議論や代替案は何か、より考えやすくなることでしょう。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    The goals of the style guide as we currently see them are as
                    follows:
                </span>
                現時点での本スタイルガイドのゴールは以下のとおりです。
            </span>
        </p>
        <dl>
            <dt>
                <span>
                    <span class="src">
                        Style rules should pull their weight
                    </span>
                    それぞれのスタイルルールが十分役立つこと
                </span>
            </dt>
            <dd>
                <span>
                    <span class="src">
                        The benefit of a style rule
                        must be large enough to justify asking all of our engineers to
                        remember it.
                    </span>
                    各スタイルルールがもたらす利益は、所属するすべてのエンジニアがそのルールを覚えるに値するくらい、十分に大きな価値がなければいけません。
                </span>
                <span>
                    <span class="src">
                        The benefit is measured relative to the codebase we would
                        get without the rule, so a rule against a very harmful practice may
                        still have a small benefit if people are unlikely to do it
                        anyway.
                    </span>
                    ここでいう利益は「仮にそのルールがなかったとしたら、書かれていたかもしれないコード」との比較で計ります。
                    たとえ何らかの「非常に有害な慣行」に関するルールを考えたとしても、そもそもルールがなくても、通常そのような有害なコードが書かれることはないのであれば、そのルールは価値が低いという風に考えます。
                </span>
                <span>
                    <span class="src">
                        This principle mostly explains the rules we don&#8217;t have, rather
                        than the rules we do: for example, <code>goto</code> contravenes many
                        of the following principles, but is already vanishingly rare, so the Style
                        Guide doesn&#8217;t discuss it.
                    </span>
                    この原則は、むしろ、本ガイドで取り扱わないルールについての説明と言えるかもしれません。
                    たとえば、本スタイルガイドでは<code>goto</code>の濫用に関するルールを取り扱っていません。確かに<code>goto</code>の濫用は本ガイドの多くの原則に違反するのですが、昨今では、そもそも<code>goto</code>が濫用されること自体少なくなっているため、このルールを定めてもあまり価値がありません。
                </span>
            </dd>

            <dt>
                <span>
                    <span class="src">
                        Optimize for the reader, not the writer
                    </span>
                    コードの著者ではなく、コードの読者に最適化すること
                </span>
            </dt>
            <dd>
                <span>
                    <span class="src">
                        Our codebase (and most individual components submitted to it) is
                        expected to continue for quite some time.
                    </span>
                    私たちのコードベース(と、それらに関与する多くの個々のコンポーネント)は、今後、長い時を経ていきます。
                </span> <span>
                    <span class="src">
                        As a result, more time will
                        be spent reading most of our code than writing it.
                    </span>
                    結果的に、コードを書くのに費やした時間に比べて、はるかに多くの時間が、そのコードを読むために使われることになるでしょう。
                </span> <span>
                    <span class="src">
                        We explicitly
                        choose to optimize for the experience of our average software engineer
                        reading, maintaining, and debugging code in our codebase rather than
                        ease when writing said code.
                    </span>
                    私たちは、コードを書くときに楽をすることよりも、私たちの平均的なエンジニアにとって、読みやすい、メンテしやすい、デバッグがしやすいコードになるように最適化することを明示的に選択します。
                </span>
                <span>
                    <span class="src">
                        "Leave a trace for the reader" is a
                        particularly common sub-point of this principle: When something
                        surprising or unusual is happening in a snippet of code (for example,
                        transfer of pointer ownership), leaving textual hints for the reader
                        at the point of use is valuable (<code>std::unique_ptr</code>
                        demonstrates the ownership transfer unambiguously at the call
                        site).
                    </span>
                    コード読者のためのヒントを残すこと、それがこの原則の共通のサブテーマです。コードの中で何か特殊なことをするとき(たとえば、ポインタの所有権を移すとき)、コード読者のために、コードを読み解くためのヒントを残すことは非常に価値のあることです(たとえば、<code>std::unique_ptr</code>を使えば、曖昧性なく、所有権の移動を表現できるでしょう)。
                </span>
            </dd>

            <dt>
                <span>
                    <span class="src">
                        Be consistent with existing code
                    </span>
                    既存コードとの一貫性が保たれていること
                </span>
            </dt>
            <dd>
                <span>
                    <span class="src">
                        Using one style consistently through our codebase lets us focus on
                        other (more important) issues.
                    </span>
                    ある唯一のスタイルをコードベース全体で一貫して用いることで、他の、本来注目すべき重要な課題にフォーカスすることができます。
                </span>
                <span>
                    <span class="src">
                        Consistency also allows for automation:
                        tools that format your code or adjust your <code>#include</code>s only
                        work properly when your code is consistent with the expectations of
                        the tooling.
                    </span>
                    また、一貫性を保つと、自動化しやすくもなります。たとえば、コード整形や<code>#include</code>整理を行うツールは、コードがツールの期待と一貫しているときにのみ力を発揮できるでしょう。
                </span>
                <span>
                    <span class="src">
                        In many cases, rules that are attributed to "Be
                        Consistent" boil down to "Just pick one and stop worrying about it";
                        the potential value of allowing flexibility on these points is
                        outweighed by the cost of having people argue over them. 
                    </span>
                    多くの場合において、「一貫性を保つ」に帰結されるルールは、「ある１つのやり方を選んで決め、それ以降は悩むのをやめる」ということに要約されます。これらの点では、多様性を認めることによって得られる潜在的な価値よりも、議論するコストの方が高くついてしまうからです。
                </span>
                <span>
                    <span class="src">
                        However,
                        there are limits to consistency; it is a good tie breaker when there
                        is no clear technical argument, nor a long-term direction.
                    </span>
                    しかしながら、一貫性には限界もあります。一貫性は、明確な技術的論拠や長期的な方向性が特にないというときには、よい判断材料となるでしょう。
                </span>
                <span>
                    <span class="src">
                        It applies
                        more heavily locally (per file, or for a tightly-related set of
                        interfaces).
                    </span>
                    これは、局所的(ファイルごと、もしくは密に関連するインターフェースの集合)なほど、より強く適用されます。
                </span>
                <span>
                    <span class="src">
                        Consistency should not generally be used as a
                        justification to do things in an old style without considering the
                        benefits of the new style, or the tendency of the codebase to converge
                        on newer styles over time.
                    </span>
                    新しいスタイルの利点や、コードベースが時間とともに新しいスタイルに移り変わっていく傾向について考慮することなく、古いスタイルのまま物事を進めることを正当化するための言い訳としては、一貫性を持ち出すべきではないでしょう。
                </span>
            </dd>

            <dt>
                <span>
                    <span class="src">
                        Be consistent with the broader C++ community when appropriate
                    </span>
                    適切ならば、より広範囲なC++コミュニティとの一貫性を保つこと
                </span>
            </dt>
            <dd>
                <span>
                    <span class="src">
                        Consistency with the way other organizations use C++ has value for
                        the same reasons as consistency within our code base.
                    </span>
                    自分たちのコードベース内で一貫性を保つことと同じ理由で、C++を使う他の組織の手法との一貫性を保つことにも、やはり価値があります。
                </span>
                <span>
                    <span class="src">
                        If a feature in
                        the C++ standard solves a problem, or if some idiom is widely known
                        and accepted, that's an argument for using it.
                    </span>
                    C++標準の機能の範囲で目的が達成できるならば、あるいは、そのイディオムが広く知られて受け入れられているならば、そのことは、それらを使う理由になるでしょう。
                </span>
                <span>
                    <span class="src">
                        However, sometimes
                        standard features and idioms are flawed, or were just designed without
                        our codebase's needs in mind.
                    </span>
                    しかし、ときには、それらの標準機能やイディオムに欠陥があったり、あるいは、私たちのコードベースのニーズを考慮せずに設計されていたりします。
                </span> <span>
                    <span class="src">
                        In those cases (as described below) it's
                        appropriate to constrain or ban standard features.
                    </span>
                    詳しくは後述しますが、このような場合には、それらの使用について制限または禁止してしまう方が適切です。
                </span> <span>
                    <span class="src">
                        In some cases we
                        prefer a homegrown or third-party library over a library defined in
                        the C++ Standard, either out of perceived superiority or insufficient
                        value to transition the codebase to the standard interface.
                    </span>
                    場合によっては、C++標準ライブラリよりも自家製あるいはサードパーティのライブラリを選ぶこともあります。単純にそれらのライブラリの方が優れている場合や、あるいは、コードベースを標準的なインターフェースに移行することに十分なメリットがない場合などです。
                </span>
            </dd>

            <dt>
                <span>
                    <span class="src">
                        Avoid surprising or dangerous constructs
                    </span>
                    特殊な構成・危険な構成を避けること
                </span>
            </dt>
            <dd>
                <span>
                    <span class="src">
                        C++ has features that are more surprising or dangerous than one
                        might think at a glance.
                    </span>
                    C++の機能の中には、一目見ただけでは想像できない、驚くような挙動、あるいは危険な機能が隠れていることがあります。
                </span> <span>
                    <span class="src">
                        Some style guide restrictions are in place to
                        prevent falling into these pitfalls.
                    </span>
                    本ガイドでは、そのような落し穴を避けるために、いくつか機能制限を課すルールが存在しています。
                </span> <span>
                    <span class="src">
                        There is a high bar for style
                        guide waivers on such restrictions, because waiving such rules often
                        directly risks compromising program correctness.
                    </span>
                    これらの制限を撤廃してしまうと、直接的にプログラムの正当性を脅かす危険性に繋がってしまうため、そのようなルールの放棄については高いハードルを設けています。
                </span>
            </dd>

            <dt>
                <span>
                    <span class="src">
                        Avoid constructs that our average C++ programmer would find tricky
                        or hard to maintain
                    </span>
                    平均的なC++プログラマーがトリッキーに感じたり、あるいはメンテナンスしにくいと感じたりするかもしれない構成を避けること
                </span>
            </dt>
            <dd>
                <span>
                    <span class="src">
                        C++ has features that may not be generally appropriate because of
                        the complexity they introduce to the code.
                    </span>
                    C++の中には、非常に複雑すぎるがために、通常、コードに導入するのには適さないような機能も存在しています。
                </span> <span>
                    <span class="src">
                        In widely used
                        code, it may be more acceptable to use
                        trickier language constructs, because any benefits of more complex
                        implementation are multiplied widely by usage, and the cost in understanding
                        the complexity does not need to be paid again when working with new
                        portions of the codebase.
                    </span>
                    広く使われるコードであれば、多少トリッキーな言語構造をしていても、比較的受け入れられやすい場合もあります。それらのコードは、実装が多少複雑であっても、その実装が広く使われることによって価値が倍増しており、また、新たなコード中で扱うときでも、その複雑さに対する学習コストを再度支払う必要もありません。
                </span> <span>
                    <span class="src">
                        When in doubt, waivers to rules of this type
                        can be sought by asking your project leads.
                    </span>
                    迷ったときは、この種のルールの放棄について、プロジェクトリーダーと相談してください。
                </span> <span>
                    <span class="src">
                        This is specifically
                        important for our codebase because code ownership and team membership
                        changes over time: even if everyone that works with some piece of code
                        currently understands it, such understanding is not guaranteed to hold a
                        few years from now.
                    </span>
                    このルールは、私たちのコードベースでは特に重要です。なぜなら、コードの担当者やチームのメンバーは時とともに変化していくからです。たとえ今この瞬間、チーム内の全てのプログラマーが全てを理解できていたとしても、数年後も同じである保証はないのです。
                </span>
            </dd>

            <dt>
                <span>
                    <span class="src">
                        Be mindful of our scale
                    </span>
                    私たち自身の「規模」に留意すること
                </span>
            </dt>
            <dd>
                <span>
                    <span class="src">
                        With a codebase of 100+ million lines and thousands of engineers,
                        some mistakes and simplifications for one engineer can become costly
                        for many.
                    </span>
                    1億行以上のコード、何千人ものエンジニアが働くコードベースにおいては、ある1人のミスや単純化が、多くのエンジニアの損失を招いてしまうことがあります。
                </span>
                <span>
                    <span class="src">
                        For instance it's particularly important to
                        avoid polluting the global namespace: name collisions across a
                        codebase of hundreds of millions of lines are difficult to work with
                        and hard to avoid if everyone puts things into the global
                        namespace.
                    </span>
                    たとえば、グローバル名前空間の汚染を避けることは非常に重要です。何億行ものコードベースにおいて、誰もがグローバル名前空間に何でもかんでも入れていたら、名前の衝突を避けるのは困難を極めるでしょう。
                </span>
            </dd>

            <dt>
                <span>
                    <span class="src">
                        Concede to optimization when necessary
                    </span>
                    必要な最適化は容認すること
                </span>
            </dt>
            <dd>
                <span>
                    <span class="src">
                        Performance optimizations can sometimes be necessary and
                        appropriate, even when they conflict with the other principles of this
                        document.
                    </span>
                    しばしば、パフォーマンス上の最適化を必要とする場合があります。たとえ、本ガイドの何らかのルールと競合したとしても、パフォーマンスを最適化することが必要で適切なのであれば、それを行ってください。
                </span>
            </dd>
        </dl>

        <p>
            <span>
                <span class="src">
                    The intent of this document is to provide maximal guidance with
                    reasonable restriction.
                </span>
                このドキュメントの意図は、合理的な制限を設けて、最大限のガイドを提供することにあります。
            </span>
            <span>
                <span class="src">
                    As always, common sense and good taste should
                    prevail.
                </span>
                いつもどおり、常識と良識を優先しましょう。
            </span>
            <span>
                <span class="src">
                    By this we specifically refer to the established conventions
                    of the entire Google C++ community, not just your personal preferences
                    or those of your team.
                </span>
                このドキュメントは、個人やチームの好みにとどまらず、GoogleのC++コミュニティ全体で確立された慣習について言及しているものです。
            </span>
            <span>
                <span class="src">
                    Be skeptical about and reluctant to use
                    clever or unusual constructs: the absence of a prohibition is not the
                    same as a license to proceed.
                </span>
                巧妙(clever)な構成や特殊な構成に対して懐疑的な姿勢を持ち、それらを避けるようにしてください(禁止されていなければやってもよいというわけではありません)。
            </span>
            <span>
                <span class="src">
                    Use your judgment, and if you are
                    unsure, please don't hesitate to ask your project leads to get additional
                    input.
                </span>
                自分の判断に従いましょう。確信を持てないときは、遠慮なくプロジェクトリーダーに質問して、意見を聞いてみてください。
            </span>
        </p>

        <h2 id="C++_Version">
            <span title="C++ Version">C++のバージョン</span>
        </h2>

        <p>
            <span>
                <span class="src">
                    Currently, code should target C++20, i.e., should not use C++23
                    features.
                </span>
                現時点において、コードはC++20をターゲットとします。C++23の機能は使ってはいけません。
            </span>
            <span>
                <span class="src">
                    The C++ version targeted by this guide will advance
                    (aggressively) over time.
                </span>
                なお、このガイドが対象とするC++のバージョンは、時とともに(かつ積極的に)進行します。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Do not use
                    <a href="#Nonstandard_Extensions">non-standard extensions</a>.
                </span>
                <a href="#Nonstandard_Extensions">非標準の拡張</a>を使ってはいけません。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Consider portability to other environments
                    before using features from C++17 and C++20 in your project.
                </span>
                C++17やC++20から導入された比較的新しい機能については、それらを使う前に、他の環境への移植性について考慮してください。
            </span>
        </p>

        <h2 id="Header_Files">
            <span title="Header Files">ヘッダーファイル</span>
        </h2>

        <p>
            <span>
                <span class="src">
                    In general, every <code>.cc</code> file should have an
                    associated <code>.h</code> file.
                </span>
                一般的には、全ての<code>.cc</code>ファイルに、それぞれと対応する<code>.h</code>ファイルを作るようにします。
            </span>
            <span>
                <span class="src">
                    There are some common
                    exceptions, such as unit tests and
                    small <code>.cc</code> files containing just a
                    <code>main()</code> function.
                </span>
                ただし、ユニットテストや<code>main()</code>だけを含むような小さな<code>.cc</code>ファイルは例外としてもかまいません。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Correct use of header files can make a huge difference to
                    the readability, size and performance of your code.
                </span>
                正しくヘッダーファイルを扱うことで、コードの可読性やサイズ、パフォーマンスに大きな違いをもたらします。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    The following rules will guide you through the various
                    pitfalls of using header files.
                </span>
                以下に続くルールは、ヘッダーファイルに関する様々な落とし穴を避けるためのガイドとなるでしょう。
            </span>
        </p>

        <a id="The_-inl.h_Files"></a>
        <h3 id="Self_contained_Headers">
            <span title="Self-contained Headers">自己完結ヘッダー</span>
        </h3>

        <p>
            <span>
                <span class="src">
                    Header files should be self-contained (compile on their own) and
                    end in <code>.h</code>.
                </span>
                ヘッダーファイルは、それ単体でコンパイルできるようにします。(このことを、ヘッダーファイルが自己完結していると呼びます。)
                ヘッダーファイルのファイル名は<code>.h</code>で終わります。
            </span>
            <span>
                <span class="src">
                    Non-header files that are meant for inclusion
                    should end in <code>.inc</code> and be used sparingly.
                </span>
                ヘッダーファイル以外の<code>#include</code>して使うことを意図したファイルには<code>.inc</code>で終わる名前を付けますが、なるべく使用は控えるようにしましょう。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    All header files should be self-contained.
                </span>
                すべてのヘッダーファイルは自己完結していなければなりません。
            </span>
            <span>
                <span class="src">
                    Users and refactoring
                    tools should not have to adhere to special conditions to include the
                    header.
                </span>
                ヘッダーの利用者やリファクタリングツールに対して、そのヘッダーを<code>#include</code>するための事前条件を課さないようにしてください。
            </span>
            <span>
                <span class="src">
                    Specifically, a header should
                    have <a href="#The__define_Guard">header guards</a> and include all
                    other headers it needs.
                </span>
                すなわち、ヘッダーには<a href="#The__define_Guard">インクルードガード</a>を書き、そのヘッダーで必要とするすべての他のヘッダーを<code>#include</code>するようにしてください。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    When a header declares inline functions or templates that clients of the
                    header will instantiate, the inline functions and templates must also have
                    definitions in the header, either directly or in files it includes.
                </span>
                あるヘッダーファイルにおいて、ファイルの利用者に使ってもらうことを意図したインライン関数やテンプレートを宣言するときは、それらの定義も、同一のヘッダーファイル内か、同一ヘッダーファイルから<code>#include</code>するファイルの中で行わなければなりません。
            </span>
            <span>
                <span class="src">
                    Do not move
                    these definitions to separately included header (<code>-inl.h</code>) files;
                    this practice was common in the past, but is no longer allowed.
                </span>
                これらの定義を、別途<code>#include</code>されるヘッダーファイル (<code>-inl.h</code>) に移動してはいけません。
                このようなやり方は、過去には慣習的でしたが、現在では許容しません。
            </span>
            <span>
                <span class="src">
                    When all
                    instantiations of a template occur in one <code>.cc</code> file, either because
                    they're <a href="https://en.cppreference.com/w/cpp/language/class_template#Explicit_instantiation">
                    explicit</a> or because the definition is accessible to only
                    the <code>.cc</code> file, the template definition can be kept in that file.
                </span>
                あるテンプレートのすべてのインスタンス化が特定の<code>.cc</code>ファイル内でのみ行われる場合には、そのテンプレートの定義を<code>.cc</code>ファイル側で保持してもかまいません。これは、たとえば
                <a href="https://en.cppreference.com/w/cpp/language/class_template#Explicit_instantiation">明示的なテンプレートのインスタンス化</a>を行う場合や、あるいは、テンプレートの定義へのアクセスを<code>.cc</code>ファイルに限定している場合などが当てはまります。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    There are rare cases where a file designed to be included is not
                    self-contained.
                </span>
                レアケースながら、<code>#include</code>されることを目的としつつも、自己完結ではないファイルも存在します。
            </span>
            <span>
                <span class="src">
                    These are typically intended to be included at unusual
                    locations, such as the middle of another file.
                </span>
                これらのファイルは、典型的には、別のファイルの途中(中ほど)などの特殊な場所で<code>#include</code>されることを意図して作られており、
            </span>
            <span>
                <span class="src">
                    They might not
                    use <a href="#The__define_Guard">header guards</a>, and might not include their prerequisites.
                </span>
                その内容として<a href="#The__define_Guard">インクルードガード</a>を持っていなかったり、そのヘッダーが必要とする他のファイルを<code>#include</code>していなかったりします。
            </span>
            <span>
                <span class="src">
                    Name such files with the <code>.inc</code>
                    extension.
                </span>
                このようなファイルには、拡張子<code>.inc</code>を含むファイル名をつけますが、
            </span>
            <span>
                <span class="src">
                    Use sparingly, and prefer self-contained headers when possible.
                </span>
                なるべく使用することを避けてください。可能であれば、自己完結ヘッダーを用いるようにしましょう。
            </span>
        </p>

        <h3 id="The__define_Guard">
            <span title="The #define Guard">インクルードガード</span>
        </h3>

        <p>
            <span>
                <span class="src">
                    All header files should have <code>#define</code> guards to
                    prevent multiple inclusion.
                </span>
                多重にインクルードされるのを防ぐために、すべてのヘッダーファイルにおいて、インクルードガード(<code>#define</code>によるガード)を持たせます。
            </span>
            <span>
                <span class="src">
                    The format of the symbol name
                    should be
                    <code><i>&lt;PROJECT&gt;</i>_<i>&lt;PATH&gt;</i>_<i>&lt;FILE&gt;</i>_H_</code>.
                </span>
                ガードのシンボル名は<code><i>&lt;PROJECT&gt;</i>_<i>&lt;PATH&gt;</i>_<i>&lt;FILE&gt;</i>_H_</code>の形式とします。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    To guarantee uniqueness, they should
                    be based on the full path in a project's source tree.
                </span>
                ユニーク性を保証するため、ガードのシンボル名は、プロジェクト内ソースツリー上のフルパスに基づくものをつけてください。
            </span>
            <span>
                <span class="src">
                    For example, the file <code>foo/src/bar/baz.h</code> in
                    project <code>foo</code> should have the following
                    guard:
                </span>
                たとえば、プロジェクトfooに含まれるファイル<code>foo/src/bar/baz.h</code>のインクルードガードは次のようにします。
            </span>
        </p>

        <pre>#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
</pre>

        <h3 id="Include_What_You_Use"><span title="Include What You Use">必要なものを<code>#include</code>する</span></h3>

        <p>
            <span>
                <span class="src">
                    If a source or header file refers to a symbol defined elsewhere,
                    the file should directly include a header file which properly intends
                    to provide a declaration or definition of that symbol.
                </span>
                ソースファイル上やヘッダーファイル上において他の場所で定義された何らかのシンボルを参照するためには、そのシンボルの宣言や定義を提供することが意図されたヘッダーファイルを直接<code>#include</code>します。
            </span>
            <span>
                <span class="src">
                    It should not
                    include header files for any other reason.
                </span>
                そして、それ以外の理由ではヘッダーファイルを<code>#include</code>すべきではありません。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Do not rely on transitive inclusions.
                </span>
                推移的な<code>#include</code>に頼ってはいけません。
            </span>
            <span>
                <span class="src">
                    This allows people to remove
                    no-longer-needed <code>#include</code> statements from their headers without
                    breaking clients.
                </span>
                推移的な<code>#include</code>の心配がなければ、ヘッダーファイルの著者は、ヘッダー利用者のコードを破壊することなく、不要になった<code>#include</code>文を削除できます。
            </span>
            <span>
                <span class="src">
                    This also applies to related headers
                    - <code>foo.cc</code> should include <code>bar.h</code> if it uses a
                    symbol from it even if <code>foo.h</code>
                    includes <code>bar.h</code>.
                </span>
                なお、このルールは、先の「<code>.cc</code>に対応するヘッダー」にも適用されます。
                たとえば<code>foo.cc</code>で<code>bar.h</code>のシンボルを使用のであれば、たとえ<code>foo.h</code>で既に<code>#include "bar.h"</code>してあったとしても、<code>foo.cc</code>でも、改めて<code>#include "bar.h"</code>するようにしてください。
            </span>
        </p>

        <h3 id="Forward_Declarations">
            <span title="Forward Declarations">前方宣言</span>
        </h3>

        <p>
            <span>
                <span class="src">
                    Avoid using forward declarations where possible.
                </span>
                前方宣言は、可能な限り避けます。
            </span>
            <span>
                <span class="src">
                    Instead, <a href="#Include_What_You_Use">include the headers you need</a>.
                </span>
                かわりに<a href="#Include_What_You_Use">必要なヘッダーを<code>#include</code></a>します。
            </span>
        </p>

        <p class="definition"></p>
        <p>
            <span>
                <span class="src">
                    A "forward declaration" is a declaration of an entity
                    without an associated definition.
                </span>
                前方宣言とは、対応する定義のないエンティティの宣言のことです。
            </span>
        </p>
        <div><div class="src">
        <pre>// In a C++ source file:
class B;
void FuncInB();
extern int variable_in_b;
ABSL_DECLARE_FLAG(flag_in_b);
</pre></div><pre>// C++ソース内:
class B;
void FuncInB();
extern int variable_in_b;
ABSL_DECLARE_FLAG(flag_in_b);
</pre></div>
        <p class="pros"></p>
        <ul>
            <li>
                <span>
                    <span class="src">
                        Forward declarations can save compile time, as
                        <code>#include</code>s force the compiler to open
                        more files and process more input.
                    </span>
                    前方宣言を用いると、コンパイラが<code>#include</code>によって多数のファイルを開いて処理する分のコンパイル時間を節約できます。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Forward declarations can save on unnecessary
                        recompilation.
                    </span>
                    前方宣言は、不要な再コンパイルを抑えることができます。
                </span>
                <span>
                    <span class="src">
                        <code>#include</code>s can force
                        your code to be recompiled more often, due to unrelated
                        changes in the header.
                    </span>
                    <code>#include</code>していた場合、そのヘッダーが変更されると、その変更がコードに無関係であっても、ソースが再コンパイル対象となるため、コンパイル頻度が上がります。
                </span>
            </li>
        </ul>

        <p class="cons"></p>
        <ul>
            <li>
                <span>
                    <span class="src">
                        Forward declarations can hide a dependency, allowing
                        user code to skip necessary recompilation when headers
                        change.
                    </span>
                    前方宣言は依存性を隠してしまうかもしれません。ヘッダーが更新されて、本来はコードの再コンパイルが必要となっているにもかかわらず、それをスキップさせてしまいます。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        A forward declaration as opposed to an <code>#include</code> statement
                        makes it difficult for automatic tooling to discover the module
                        defining the symbol.
                    </span>
                    前方宣言は、<code>#include</code>に比べて、自動化ツールがシンボルの定義を含むモジュールを探す際の妨げとなる場合があります。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        A forward declaration may be broken by subsequent
                        changes to the library.
                    </span>
                    前方宣言は、将来のライブラリ側の変更によって壊れてしまうことがあります。
                </span>
                <span>
                    <span class="src">
                        Forward declarations of functions
                        and templates can prevent the header owners from making
                        otherwise-compatible changes to their APIs, such as
                        widening a parameter type, adding a template parameter
                        with a default value, or migrating to a new namespace.
                    </span>
                    関数やテンプレートの前方宣言は、ヘッダーのメンテナによる、(本来互換性を保てたはずの)APIの変更(パラメータの型を拡張したり、デフォルト値とともにテンプレートパラメータを増やしたり、新しい名前空間への移行したり)の妨げとなる場合があります。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Forward declaring symbols from namespace
                        <code>std::</code> yields undefined behavior.
                    </span>
                    <code>std::</code>名前空間内のシンボルに対する前方宣言は未定義動作を引き起こします。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        It can be difficult to determine whether a forward
                        declaration or a full <code>#include</code> is needed.
                    </span>
                    そもそも、前方宣言だけで済むのか、あるいは、<code>#include</code>が必要なのかを判断すること自体が難しいことです。
                </span>
                <span>
                    <span class="src">
                        Replacing an <code>#include</code> with a forward
                        declaration can silently change the meaning of
                        code:
                    </span>
                    たとえば、次のコードの<code>#include</code>を単純に前方宣言に置き換えてしまうと、コードの意味が変わってしまいます。
                </span>
                <pre>// b.h:
struct B {};
struct D : B {};

// good_user.cc:
#include "b.h"
void f(B*);
void f(void*);
void test(D* x) { f(x); }  // Calls f(B*)</pre>
                <span>
                    <span class="src">
                        If the <code>#include</code> was replaced with forward
                        decls for <code>B</code> and <code>D</code>,
                        <code>test()</code> would call <code>f(void*)</code>.
                    </span>
                    もし、<code>#include</code>を<code>B</code>と<code>D</code>に対する前方宣言に置き換えてしまうと、それらの継承関係が見えなくなり、<code>test()</code>は<code>f(void*)</code>の方を呼び出してしまうでしょう。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Forward declaring multiple symbols from a header
                        can be more verbose than simply
                        <code>#include</code>ing the header.
                    </span>
                    1つのヘッダーにある複数のシンボルを前方宣言することは、単にそのヘッダーを<code>#include</code>するよりも冗長になってしまいます。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Structuring code to enable forward declaration
                        (e.g., using pointer members instead of object members)
                        can make the code slower and more complex.
                    </span>
                    前方宣言を用いる場合、たとえばクラスメンバーをオブジェクトではなくポインタで持つ必要があるなど、前方宣言を用いるためのコードの構造によって、コードの実行が遅くなり、コード自体も複雑になりがちです。
                </span>
            </li>
        </ul>

        <p class="decision"></p>
        <ul>
            <li>
                <span>
                    <span class="src">
                        Try to avoid forward declarations of entities
                        defined in another project.
                    </span>
                    プロジェクトの外部で定義されるエンティティを前方宣言することは避けましょう。
                </span>
            </li>
        </ul>

        <h3 id="Inline_Functions">
            <span title="Inline Functions">インライン関数</span>
        </h3>

        <p>
            <span>
                <span class="src">
                    Define functions inline only when they are small, say, 10
                    lines or fewer.
                </span>
                インライン関数は、関数の定義が小さいとき(10行以下程度)に限定します。
            </span>
        </p>

        <p class="definition"></p>
        <p>
            <span>
                <span class="src">
                    You can declare functions in a way that allows the compiler to expand
                    them inline rather than calling them through the usual
                    function call mechanism.
                </span>
                関数は、通常の関数呼び出しのかわりに、コンパイラによって直接その場に展開されることを許す形でも宣言することができます。
            </span>
        </p>
        <p class="pros"></p>
        <p>
            <span>
                <span class="src">
                    Inlining a function can generate more efficient object
                    code, as long as the inlined function is small.
                </span>
                関数が十分に小さいとき、インライン化することによって、より効率的なオブジェクトコードを生成できます。
            </span>
            <span>
                <span class="src">
                    Feel free
                    to inline accessors and mutators, and other short,
                    performance-critical functions.
                </span>
                getter関数(原: accessors)、setter関数(原: mutators)、あるいは、その他の小さく、かつパフォーマンスクリティカルな関数は、自由にインライン化してかまいません。
            </span>
        </p>
        <p class="cons"></p>
        <p>
            <span>
                <span class="src">
                    Overuse of inlining can actually make programs slower.
                </span>
                関数のインライン化を濫用すると、逆にプログラムの動作が遅くなってしまうことがあります。
            </span>
            <span>
                <span class="src">
                    Depending on a function's size, inlining it can cause the
                    code size to increase or decrease.
                </span>
                関数のサイズによって、インライン化後のコードのサイズは大きく増えたり減ったりします。
            </span>
            <span>
                <span class="src">
                    Inlining a very small
                    accessor function will usually decrease code size while
                    inlining a very large function can dramatically increase code size.
                </span>
                非常に小さなgetter関数をインライン化することは、通常はコード全体のサイズを小さくします。しかし、逆に、非常に大きな関数をインライン化してしまうと、コード全体のサイズが劇的に大きくなってしまうかもしれません。
            </span>
            <span>
                <span class="src">
                    On modern processors smaller code usually runs
                    faster due to better use of the instruction cache.
                </span>
                現代的なCPUにおいては、通常は、コードサイズが小さい方が、命令キャッシュを効率的に使えるため、高速に動作します。
            </span>
        </p>
        <p class="decision"></p>
        <p>
            <span>
                <span class="src">
                    A decent rule of thumb is to not inline a function if
                    it is more than 10 lines long.
                </span>
                経験則として、関数が10行より多くなったらインライン化すべきではありません。
            </span>
            <span>
                <span class="src">
                    Beware of destructors,
                    which are often longer than they appear because of
                    implicit member- and base-destructor calls!
                </span>
                また、デストラクタには注意が必要です。デストラクタは、暗黙的にメンバのデストラクタと基底クラスのデストラクタを呼び出すため、その見た目に比べて長い実体を持つことがあるためです。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Another useful rule of thumb: it's typically not cost
                    effective to inline functions with loops or switch
                    statements (unless, in the common case, the loop or
                    switch statement is never executed).
                </span>
                もう１つの経験則として、大抵の場合は、ループやswitch文を含む関数は(それらの文がまったく実行されないような場合を除いて)インライン化しても効率的になりません。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    It is important to know that functions are not always
                    inlined even if they are declared as such; for example,
                    virtual and recursive functions are not normally inlined.
                </span>
                なお、関数をインライン化できるように宣言したとしても、必ずインライン化されるとは限らないため注意してください。たとえば、仮想関数や再帰関数は通常はインライン化されません。
            </span>
            <span>
                <span class="src">
                    Usually recursive functions should not be inline.
                </span>
                通常、再帰関数はインライン化されません。
            </span>
            <span>
                <span class="src">
                    The
                    main reason for making a virtual function inline is to
                    place its definition in the class, either for convenience
                    or to document its behavior, e.g., for accessors and
                    mutators.
                </span>
                また、仮想関数をクラス内にインラインで定義する主な理由は、利便性や、(それがgetterやsetterの場合など)その挙動に関するドキュメントとしての役割を持たせられることにあります。
            </span>
        </p>
        <h3 id="Names_and_Order_of_Includes">
            <span title="Names and Order of Includes"><code>#include</code>の名前と順序</span>
        </h3>

        <p>
            <span>
                <span class="src">
                    Include headers in the following order: Related header, C system headers,
                    C++ standard library headers,
                    other libraries' headers, your project's
                    headers.
                </span>
                <code>#include</code>は次の順番で行います: <code>.cc</code>自身と対応するヘッダー、C言語のシステムヘッダー、C++標準ライブラリヘッダー、その他のライブラリのヘッダー、自分のプロジェクト内のヘッダー。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    All of a project's header files should be
                    listed as descendants of the project's source
                    directory without use of UNIX directory aliases
                    <code>.</code> (the current directory) or <code>..</code>
                    (the parent directory).
                </span>
                すべてのプロジェクトヘッダーのパスは、プロジェクトソースディレクトリルートからの相対パスで記述します。その際、UNIXディレクトリのエイリアスである<code>./</code>(カレントディレクトリ)や、<code>../</code>(親ディレクトリ)は省きます。
            </span>
            <span>
                <span class="src">
                    For example,
                    <code>google-awesome-project/src/base/logging.h</code>
                    should be included as:
                </span>
                たとえば、<code>google-awesome-project/src/base/logging.h</code>は次のように記述します。
            </span>
        </p>

        <pre>#include "base/logging.h"
</pre>

        <p>
            <span>
                <span class="src">
                    In <code><var>dir/foo</var>.cc</code> or
                    <code><var>dir/foo_test</var>.cc</code>, whose main
                    purpose is to implement or test the stuff in
                    <code><var>dir2/foo2</var>.h</code>, order your includes
                    as follows:
                </span>
                <code>#include</code>の順序の例として、たとえば<code><var>dir2/foo2</var>.h</code>の宣言を実装するファイル<code><var>dir/foo</var>.cc</code>や、もしくは、それらをテストする目的のファイル<code><var>dir/foo_test</var>.cc</code>においては、次の順に並べます。
            </span>
        </p>

        <ol>
            <li>
                <span>
                    <span class="src">
                        <code><var>dir2/foo2</var>.h</code>.
                    </span>
                    <code><var>dir2/foo2</var>.h</code> (対応するヘッダーファイル)
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        A blank line
                    </span>
                    空行
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        C system headers (more precisely: headers in angle brackets with the
                        <code>.h</code> extension), e.g., <code>&lt;unistd.h&gt;</code>,
                        <code>&lt;stdlib.h&gt;</code>.
                    </span>
                    C言語のシステムヘッダー(より正確には、<code>&lt;&gt;</code>で囲まれ、拡張子<code>.h</code>を持つもの)、たとえば<code>&lt;unistd.h&gt;</code>や<code>&lt;stdlib.h&gt;</code>
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        A blank line
                    </span>
                    空行
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        C++ standard library headers (without file extension), e.g.,
                        <code>&lt;algorithm&gt;</code>, <code>&lt;cstddef&gt;</code>.
                    </span>
                    C++標準ライブラリのヘッダー(拡張子のないもの)、たとえば<code>&lt;algorithm&gt;</code>や<code>&lt;cstddef&gt;</code>など
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        A blank line
                    </span>
                    空行
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Other libraries' .h files.
                    </span>
                    他のライブラリの<code>.h</code>ファイル
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        A blank line
                    </span>
                    空行
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Your project's <code>.h</code> files.
                    </span>
                    自分のプロジェクトの.hファイル
                </span>
            </li>
        </ol>

        <p>
            <span>
                <span class="src">
                    Separate each non-empty group with one blank line.
                </span>
                空でないグループ同士の間には空行を1つ入れます。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    With the preferred ordering, if the related header
                    <code><var>dir2/foo2</var>.h</code> omits any necessary
                    includes, the build of <code><var>dir/foo</var>.cc</code>
                    or <code><var>dir/foo</var>_test.cc</code> will break.
                </span>
                この順番にしておくことで、<code>.cc</code>の関連ヘッダーである<code><var>dir2/foo2</var>.h</code>で、必要なインクルードを忘れてしまったときに、まず<code><var>dir/foo</var>.cc</code>や<code><var>dir/foo</var>_test.cc</code>がビルドエラーになります。
            </span>

            <span>
                <span class="src">
                    Thus, this rule ensures that build breaks show up first
                    for the people working on these files, not for innocent
                    people in other packages.
                </span>
                そのため、ビルドエラーが起きたときに、他のパッケージで作業している無実の人ではなく、当該ファイルで作業をしていた本人が最初に気づくことができるようになります。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    <code><var>dir/foo</var>.cc</code> and
                    <code><var>dir2/foo2</var>.h</code> are usually in the same
                    directory (e.g., <code>base/basictypes_test.cc</code> and
                    <code>base/basictypes.h</code>), but may sometimes be in different
                    directories too.
                </span>
                <code><var>dir/foo</var>.cc</code>と<code><var>dir2/foo2</var>.h</code>は、通常は同じディレクトリ内に置きます(たとえば、<code>base/basictypes_test.cc</code>と<code>base/basictypes.h</code>も同様です)が、場合によって異なるディレクトリに置かれることもあります。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Note that the C headers such as <code>stddef.h</code>
                    are essentially interchangeable with their C++ counterparts
                    (<code>cstddef</code>).
                </span>
                なお、<code>stddef.h</code>のようなC言語のヘッダーは、C++の相当するヘッダー(<code>cstddef</code>)と相互に置き換えることができます。
            </span>
            <span>
                <span class="src">
                    Either style is acceptable, but prefer consistency with existing code.
                </span>
                どちらのスタイルでもかまいませんが、既存のコードとの一貫性を優先してください。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Within each section the includes should be ordered
                    alphabetically.
                </span>
                各セクション内ではアルファベット順に並べます。
            </span>
            <span>
                <span class="src">
                    Note that older code might not conform to
                    this rule and should be fixed when convenient.
                </span>
                古いコードはこのルールに沿ってないかもしれませんが、修正したほうが利便性がよければ、修正してしまいましょう。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    For example, the includes in
                    <code>google-awesome-project/src/foo/internal/fooserver.cc</code>
                    might look like this:
                </span>
                次に例を示します。たとえば、<code>google-awesome-project/src/foo/internal/fooserver.cc</code>の<code>#include</code>は次のようになります。
            </span>
        </p>

        <pre>#include "foo/server/fooserver.h"

#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#include &lt;string&gt;
#include &lt;vector&gt;

#include "base/basictypes.h"
#include "foo/server/bar.h"
#include "third_party/absl/flags/flag.h"
</pre>
        <p class="exception">
            <span>
                <span class="src">
                    Sometimes, system-specific code needs
                    conditional includes.
                </span>
                システム特有のコードは、しばしば条件付きの<code>#include</code>を要する場合があります。
            </span>
            <span>
                <span class="src">
                    Such code can put conditional
                    includes after other includes.
                </span>
                そのような条件付き<code>#include</code>は、それ以外の<code>#include</code>の後に配置します。
            </span>
            <span>
                <span class="src">
                    Of course, keep your
                    system-specific code small and localized.
                </span>
                もちろん、システム特有のコードは小さく局所的に保つようにしてください。
            </span>
            <span>
                <span class="src">
                    Example:
                </span>
                次に例を示します。
            </span>
        </p>

        <pre>#include "foo/public/fooserver.h"

#include "base/port.h"  // For LANG_CXX11.

#ifdef LANG_CXX11
#include &lt;initializer_list&gt;
#endif  // LANG_CXX11
</pre>

        <h2 id="Scoping">
            <span title="Scoping">スコープ</span>
        </h2>

        <h3 id="Namespaces">
            <span title="Namespaces">名前空間</span>
        </h3>

        <p>
            <span>
                <span class="src">
                    With few exceptions, place code in a namespace.
                </span>
                一部の例外を除いて、コードは何らかの名前空間の中に置きます。
            </span>
            <span>
                <span class="src">
                    Namespaces should have unique names based on the project name, and possibly its path.
                </span>
                名前空間にはプロジェクト名やファイルパスに基づくユニークな名前をつけます。
            </span>
            <span>
                <span class="src">
                    Do not use <i>using-directives</i> (e.g.,
                    <code>using namespace foo</code>).
                </span>
                <i>usingディレクティブ</i>(<code>using namespace foo</code>)は使ってはいけません。
            </span>
            <span>
                <span class="src">
                    Do not use inline namespaces.
                </span>
                インライン名前空間を使ってはいけません。
            </span>

            <span>
                <span class="src">
                    For unnamed namespaces, see
                    <a href="#Internal_Linkage">Internal Linkage</a>.
                </span>
                無名名前空間については<a href="#Internal_Linkage">内部リンケージ</a>を参照してください。
            </span>
        </p>

        <p class="definition"></p>
        <p>
            <span>
                <span class="src">
                    Namespaces subdivide the global scope
                    into distinct, named scopes, and so are useful for preventing
                    name collisions in the global scope.
                </span>
                名前空間は、グローバルスコープを異なる名前付きのスコープに分割します。名前空間によって、グローバルスコープにおける名前の衝突を防ぐことができます。
            </span>
        </p>
        <p class="pros"></p>

        <p>
            <span>
                <span class="src">
                    Namespaces provide a method for preventing name conflicts
                    in large programs while allowing most code to use reasonably
                    short names.
                </span>
                名前空間を用いると、大きなプログラムであっても、コードの大部分において合理的な短い名前を使えることを活かしたまま、名前の衝突を防ぐことができます。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    For example, if two different projects have a class
                    <code>Foo</code> in the global scope, these symbols may
                    collide at compile time or at runtime.
                </span>たとえば、2つのプロジェクト間で同じ名前のクラス<code>Foo</code>がグローバル名前空間に含まれていたとすると、これらのシンボルはコンパイル時や実行時に衝突してしまうかもしれません。
            </span>
            <span>
                <span class="src">
                    If each project
                    places their code in a namespace, <code>project1::Foo</code>
                    and <code>project2::Foo</code> are now distinct symbols that
                    do not collide, and code within each project's namespace
                    can continue to refer to <code>Foo</code> without the prefix.
                </span>
                しかし、それぞれのプロジェクトがそのクラスを独自の名前空間の中に入れていれば、<code>project1::Foo</code>と<code>project2::Foo</code>とは区別できるようになり、衝突しなくなります。さらに、各プロジェクトの名前空間内では、引き続き、接頭辞なしのただの<code>Foo</code>という記述で、そのクラスを参照することができます。
            </span>
        </p>

        <p>
            <span>
                <span class="src">Inline namespaces automatically place their names in the enclosing scope.</span>
                インライン名前空間は、自身の名前を自動的に外側のスコープに配置します。
            </span>

            <span>
                <span class="src">Consider the following snippet, for example:</span>
                例として、次のスニペットについて考えます。
            </span>
        </p>

        <pre class="neutralcode">namespace outer {
inline namespace inner {
  void foo();
}  // namespace inner
}  // namespace outer
</pre>

        <p>
            <span>
                <span class="src">
                    The expressions <code>outer::inner::foo()</code> and
                    <code>outer::foo()</code> are interchangeable.
                </span>
                このとき、式<code>outer::inner::foo()</code>と<code>outer::foo()</code>とは相互に交換可能となります。
            </span>
            <span>
                <span class="src">
                    Inline namespaces are primarily intended for ABI compatibility across versions.
                </span>
                インライン名前空間は、主にバージョン間におけるABIの互換性を保つことを目的で利用することができます。
            </span>
        </p>
        <p class="cons"></p>

        <p>
            <span>
                <span class="src">
                    Namespaces can be confusing, because they complicate
                    the mechanics of figuring out what definition a name refers
                    to.
                </span>
                名前空間は、名前から定義を解決する仕組みを複雑化させるため、困惑を招くことがあります。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Inline namespaces, in particular, can be confusing
                    because names aren't actually restricted to the namespace
                    where they are declared.
                </span>
                特にインライン名前空間は、事実上、その中で宣言される名前を名前空間の中に閉じ込めないため困惑しやすいです。
            </span>
            <span>
                <span class="src">
                    They are only useful as part of
                    some larger versioning policy.
                </span>
                インライン名前空間は、バージョン管理ポリシーの一部としてのみ役に立ちます。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    In some contexts, it's necessary to repeatedly refer to
                    symbols by their fully-qualified names.
                </span>
                また、文脈によって、シンボルを解決するために完全修飾された名前を必要とすることがありますが、
            </span>
            <span>
                <span class="src">
                    For deeply-nested
                    namespaces, this can add a lot of clutter.
                </span>
                名前空間のネストが深いと、コードが散らかってしまいます。
            </span>
        </p>
        <p class="decision"></p>

        <p>
            <span>
                <span class="src">
                    Namespaces should be used as follows:
                </span>
                名前空間は次のように使いましょう:
            </span>
        </p>

        <ul>
            <li>
                <span>
                    <span class="src">
                        Follow the rules on <a href="#Namespace_Names">Namespace Names</a>
                    </span>
                    <a href="#Namespace_Names">名前空間の名前</a>のルールに従ってください。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        Terminate multi-line namespaces with comments as shown in the given
                        examples.
                    </span>
                    複数行からなる名前空間の終わりには、先の例の通り、コメントをつけてください。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        Namespaces wrap the entire source file after
                        includes,
                        <a href="https://gflags.github.io/gflags/">gflags</a> definitions/declarations
                        and forward declarations of classes from other namespaces.
                    </span>
                    名前空間は、<code>include</code>文、<a href="https://gflags.github.io/gflags/">gflags</a>の定義や宣言、他の名前空間のクラスの前方宣言の後に続く、すべてのソースコードを包むようにしてください。
                </span>
                <div>
                    <div class="src">
                        <pre>// In the .h file
namespace mynamespace {

// All declarations are within the namespace scope.
// Notice the lack of indentation.
class MyClass {
 public:
  ...
  void Foo();
};

}  // namespace mynamespace
</pre>
                    </div>
                    <pre>// .h ファイル
namespace mynamespace {

// すべての宣言は名前空間のスコープに含めます。
// 名前空間ではインデントしません。
class MyClass {
 public:
  ...
  void Foo();
};

}  // namespace mynamespace
</pre>
</div>
<div>
                    <div class="src">
                        <pre>// In the .cc file
namespace mynamespace {

// Definition of functions is within scope of the namespace.
void MyClass::Foo() {
    ...
}

}  // namespace mynamespace
</pre>
                    </div>
                    <pre>// .ccファイル
namespace mynamespace {

// 関数の定義は名前空間に含めます。
void MyClass::Foo() {
  ...
}

}  // namespace mynamespace
</pre>
</div>
                <span>
                    <span class="src">
                        More complex <code>.cc</code> files might have additional details,
                        like flags or using-declarations.
                    </span>
                    より複雑な <code>.cc</code>ファイルでは、flagsやusing宣言などを含む場合もあるかもしれません。
                </span>
                <div>
                    <div class="src">
                        <pre>#include "a.h"

ABSL_FLAG(bool, someflag, false, "a flag");

namespace mynamespace {

using ::foo::Bar;

...code for mynamespace...    // Code goes against the left margin.

}  // namespace mynamespace
</pre>
                    </div>
                    <pre>#include "a.h"

ABSL_FLAG(bool, someflag, false, "a flag");

namespace mynamespace {

using ::foo::bar;

...code for mynamespace...    // コードの左側には余白を入れない。

}  // namespace mynamespace
</pre>
                </div>
            </li>

            <li>
                <span>
                    <span class="src">
                        To place generated protocol
                        message code in a namespace, use the
                        <code>package</code> specifier in the
                        <code>.proto</code> file.
                    </span>
                    Protocol Buffer が生成したメッセージコードを名前空間に含めたいときは、<code>.proto</code>ファイル内の<code>package</code>指定子を使ってください。
                </span>
                <span>
                    <span class="src">
                        See
                        <a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated#package">
                            Protocol Buffer Packages</a>
                        for details.
                    </span>
                    詳細は <a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated#package">Protocol Buffer Packages</a> を参照してください。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Do not declare anything in namespace
                        <code>std</code>, including forward declarations of
                        standard library classes.
                    </span>
                    <code>std</code>名前空間の中には、標準ライブラリの前方宣言を含めて、何も宣言してはいけません。
                </span>
                <span>
                    <span class="src">
                        Declaring entities in
                        namespace <code>std</code> is undefined behavior, i.e.,
                        not portable.
                    </span>
                    <code>std</code>名前空間の中に何かを宣言することは未定義動作であり、コードの移植性を失わせてしまいます。
                </span>
                <span>
                    <span class="src">
                        To declare entities from the standard
                        library, include the appropriate header file.
                    </span>標準ライブラリのエンティティを宣言するためには、適切なヘッダーファイルを<code>#include</code>してください。
                </span>
            </li>

            <li>
                <p>
                    <span>
                        <span class="src">
                            You may not use a <i>using-directive</i>
                            to make all names from a namespace available.
                        </span>
                        名前空間内のすべての名前を利用できるようにするための<i>usingディレクティブ</i>は使ってはいけません。
                    </span>
                </p>
                <div>
                    <div class="src">
                        <pre class="badcode">// Forbidden -- This pollutes the namespace.
using namespace foo;
</pre>
                    </div>
                    <pre class="badcode">// 不可。名前空間を汚染している。
using namespace foo;
</pre>
                </div>
            </li>

            <li>
                <p>
                    <span>
                        <span class="src">
                            Do not use <i>Namespace aliases</i> at namespace scope
                            in header files except in explicitly marked
                            internal-only namespaces, because anything imported into a namespace
                            in a header file becomes part of the public
                            API exported by that file.
                        </span>
                        内部用であることを明示した名前空間の中を除き、<i>名前空間のエイリアス(Namespace aliase)</i>をヘッダーファイルの名前空間スコープで宣言してはいけません。このようなヘッダーファイルで名前空間にインポートされたすべてのものは、そのヘッダーファイルが提供するAPIの一部として公開したことになるためです。
                    </span>
                </p>

                <div>
                    <div class="src">
                        <pre>// Shorten access to some commonly used names in .cc files.
namespace baz = ::foo::bar::baz;
</pre>
                    </div>
                    <pre>// .ccファイル内
// たくさん使われる名前へのショートカットを作る。
namespace baz = ::foo::bar::baz;
</pre>
                </div>
                <div>
                    <div class="src">
                        <pre>// Shorten access to some commonly used names (in a .h file).
namespace librarian {
namespace impl {  // Internal, not part of the API.
namespace sidetable = ::pipeline_diagnostics::sidetable;
}  // namespace impl

inline void my_inline_function() {
  // namespace alias local to a function (or method).
  namespace baz = ::foo::bar::baz;
  ...
}
}  // namespace librarian
</pre>
                    </div>
                    <pre>// .hファイル内
// よく使われる名前へのショートカットを作る。
namespace librarian {
namespace impl {  // 内部用。APIではありません。
namespace sidetable = ::pipeline_diagnostics::sidetable;
}  // namespace impl

inline void my_inline_function() {
  // 関数内に限定された名前空間の別名。
  namespace baz = ::foo::bar::baz;
  ...
}
}  // namespace librarian
</pre>
                </div>

            </li>
            <li>
                <span><span class="src">Do not use inline namespaces.</span>
                インライン名前空間を使ってはいけません。</span>
            </li>

            <li><p><span><span class="src">Use namespaces with "internal" in the name to document parts of an API that
                should not be mentioned by users of the API.</span>
                APIのユーザーによって触れられるべきでない部分は、その旨を明示するために"internal"を含めた名前の名前空間を使ってください。</span>
                </p>
<div><div class="src">
<pre class="badcode">// We shouldn't use this internal name in non-absl code.
using ::absl::container_internal::ImplementationDetail;
</pre></div><pre class="badcode">// absl外のコードでは、abslのinternalな名前を使用すべきではありません。
using ::absl::container_internal::ImplementationDetail;
</pre></div>
            </li>

            <li><p><span><span class="src">Single-line nested namespace declarations
                are preferred in new code, but are not required.</span>
                新しく書くコードにおいては、1行でネストした名前空間宣言を用いるのが好ましいですが、必須ではありません。</span></p>
            </li>
        </ul>

        <a id="Unnamed_Namespaces_and_Static_Variables"></a>
        <h3 id="Internal_Linkage"><span title="Internal Linkage">内部リンケージ</span></h3>

        <p>
            <span>
                <span class="src">
                    When definitions in a <code>.cc</code> file do not need to be
                    referenced outside that file, give them internal linkage by placing
                    them in an unnamed namespace or declaring them <code>static</code>.
                </span>
                エンティティの定義が<code>.cc</code>ファイル内にあり、かつ、ファイル外から参照される必要がないときは、それらを無名の名前空間内におくか、もしくは<code>static</code>に宣言することによって、内部リンケージを持たせるようにします。
            </span>
            <span>
                <span class="src">
                    Do not use either
                    of these constructs in <code>.h</code> files.
                </span>
                なお、<code>.h</code>ファイル内では、これらのいずれも行ってはいけません。
            </span>
        </p>

        <p class="definition"></p>
        <p>
            <span>
                <span class="src">
                    All declarations can be given internal linkage by placing them in unnamed
                    namespaces.
                </span>
                無名名前空間内で宣言を行うことによって、それらを内部リンケージとすることができます。
            </span>
            <span>
                <span class="src">
                    Functions and variables can also be given internal linkage by
                    declaring them <code>static</code>.
                </span>
                関数と変数は、<code>static</code>に宣言することでも、内部リンケージにすることができます。
            </span>
            <span>
                <span class="src">
                    This means that anything you're declaring
                    can't be accessed from another file.
                </span>
                内部リンケージのエンティティは他のファイルからアクセスできなくなります。
            </span>
            <span>
                <span class="src">
                    If a different file declares something with
                    the same name, then the two entities are completely independent.
                </span>
                仮に、異なるファイル間において同名のエンティティが宣言されていたとしても、それらは完全に独立した別の実体として扱われます。
            </span>
        </p>
        <p class="decision"></p>

        <p>
            <span>
                <span class="src">
                    Use of internal linkage in <code>.cc</code> files is encouraged
                    for all code that does not need to be referenced elsewhere.
                </span>
                他の場所から参照される必要のないすべてのコードを、<code>.cc</code>内の内部リンケージにすることを推奨します。
            </span>
            <span>
                <span class="src">
                    Do not use internal linkage in <code>.h</code> files.
                </span>
                <code>.h</code>ファイルでは内部リンケージは使用してはいけません。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Format unnamed namespaces like named namespaces.
                </span>
                無名名前空間も、名前付きの名前空間と同じようにフォーマットしてください。
            </span>
            <span>
                <span class="src">
                    In the
                    terminating comment, leave the namespace name empty:
                </span>
                無名名前空間が終わるときのコメントは、次のように、名前空間名を空白のままにしたものを記述してください。
            </span>
        </p>

        <pre>namespace {
...
}  // namespace
</pre>

        <h3 id="Nonmember,_Static_Member,_and_Global_Functions">
            <span title="Nonmember, Static Member, and Global Functions">非メンバ関数、静的メンバ関数、グローバル関数</span>
        </h3>

        <p>
            <span>
                <span class="src">
                    Prefer placing nonmember functions in a namespace; use completely global
                    functions rarely.
                </span>
                非メンバ関数(通常の関数)は何らかの名前空間内におきます。完全なグローバル関数はまず使いません。
            </span>
            <span>
                <span class="src">
                    Do not use a class simply to group static members.
                </span>
                静的メンバをグループ化するためだけのクラスを作ってはいけません。
            </span>
            <span>
                <span class="src">
                    Static
                    methods of a class should generally be closely related to instances of the
                    class or the class's static data.
                </span>
                静的メンバ関数は、そのクラスのインスタンスや静的データと強い関連がある場合に限って使用します。
            </span>
        </p>

        <p class="pros"></p>
        <p>
            <span>
                <span class="src">
                    Nonmember and static member functions can be useful in
                    some situations.
                </span>
                通常の関数や静的メンバ関数は、様々な場面で有用です。
            </span>
            <span>
                <span class="src">
                    Putting nonmember functions in a
                    namespace avoids polluting the global namespace.
                </span>
                通常関数は何らかの名前空間内に置くことで、グローバル名前空間の汚染を避けられます。
            </span>
        </p>
        <p class="cons"></p>
        <p>
            <span>
                <span class="src">
                    Nonmember and static member functions may make more sense
                    as members of a new class, especially if they access
                    external resources or have significant dependencies.
                </span>
                通常関数や静的メンバ関数は、新しいクラスのメンバとした方が合理的な場合があります。特に、それらが外部のリソースにアクセスしていたり、あるいは強く依存していたりする場合などです。
            </span>
        </p>
        <p class="decision"></p>
        <p>
            <span>
                <span class="src">
                    Sometimes it is useful to define a
                    function not bound to a class instance.
                </span>
                場合によっては、関数がクラスインスタンスに紐付かない方が便利なこともあるでしょう。
            </span>
            <span>
                <span class="src">
                    Such a function
                    can be either a static member or a nonmember function.
                </span>
                このような関数は、静的メンバ関数や非メンバ関数(通常の関数)とすることができます。
            </span>
            <span>
                <span class="src">
                    Nonmember functions should not depend on external
                    variables, and should nearly always exist in a namespace.
                </span>
                非メンバ関数は、外部の変数に依存すべきではありません。また、ほとんど常に名前空間の中におかれなければなりません。
            </span>
            <span>
                <span class="src">
                    Do not create classes only to group static members;
                    this is no different than just giving the names a
                    common prefix, and such grouping is usually unnecessary anyway.
                </span>
                静的なメンバをグループ化するためだけのクラスを作ってはいけません。
                このようなクラスを作ることは、名前に共通の接頭辞をつけることと何ら違いがありません。
                また、いずれにせよ、通常はこのようなグループ化自体が不要です。
            </span>
        </p>
        <p>
            <span>
                <span class="src">
                    If you define a nonmember function and it is only
                    needed in its <code>.cc</code> file, use
                    <a href="#Internal_Linkage">internal linkage</a> to limit
                    its scope.
                </span>
                非メンバ関数が特定の<code>.cc</code>ファイル内からのみ必要とされる場合は、スコープを制限するために<a href="#Internal_Linkage">内部リンケージ</a>を使用してください。
            </span>
        </p>

        <h3 id="Local_Variables">
            <span title="Local Variables">ローカル変数</span>
        </h3>

        <p>
            <span>
                <span class="src">
                    Place a function's variables in the narrowest scope
                    possible, and initialize variables in the declaration.
                </span>
                関数の中で変数を宣言するときは、そのスコープを可能な限り狭めます。また、変数宣言と同時に初期化します。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    C++ allows you to declare variables anywhere in a function.
                </span>
                C++では、関数内のどこでも変数を宣言することができます。
            </span>
            <span>
                <span class="src">
                    We encourage you to declare them in a scope as local as
                    possible, and as close to the first use as possible.
                </span>
                変数は、できる限り局所的なスコープの中で、また、できる限り初めて使う場所の近くで宣言することが望ましいです。
            </span>
            <span>
                <span class="src">
                    This makes it easier for the reader to find the
                    declaration and see what type the variable is and what it
                    was initialized to.
                </span>
                そうすることで、コードの読者が変数宣言を見つけやすくなり、変数の型や初期化の方法についての見通しがよくなります。
            </span>
            <span>
                <span class="src">
                    In particular, initialization should
                    be used instead of declaration and assignment, e.g.,:
                </span>
                また、変数は、変数宣言と代入を別々に行うのではなく、変数宣言と同時に初期化するようにしてください。以下に例を示します。
            </span>
        </p>
        <div>
            <div class="src">
                <pre class="badcode">int i;
i = f();      // Bad -- initialization separate from declaration.
</pre>
            </div>
            <pre class="badcode">int i;
i = f();      // 悪い例。初期化が宣言と分かれている。
</pre>
        </div>
        <div>
            <div class="src">
                <pre>int i = f();  // Good -- declaration has initialization.
</pre>
            </div>
            <pre>int i = f();  // 良い例。宣言と同時に初期化が行われている。
</pre>
        </div>
        <div>
            <div class="src">
                <pre>int jobs = NumJobs();
f(jobs);      // Good -- declaration immediately (or closely) followed by use.
</pre></div>
            <pre>int jobs = NumJobs();
f(jobs);      // 良い例。使用する直前に(あるいはすぐ近くで)宣言されている。
</pre></div>
        <div>
            <div class="src">
                <pre class="badcode">std::vector&lt;int&gt; v;
v.push_back(1);  // Prefer initializing using brace initialization.
v.push_back(2);
</pre>
            </div>
            <pre class="badcode">std::vector&lt;int&gt; v;
v.push_back(1);  // {}による初期化を使う方がよい。
v.push_back(2);
</pre>
        </div>
        <div>
            <div class="src">
                <pre>std::vector&lt;int&gt; v = {1, 2};  // Good -- v starts initialized.
</pre>
            </div>
            <pre>std::vector&lt;int&gt; v = {1, 2};  // 良い例。宣言と同時に初期化されている。
</pre>
        </div>

        <p>
            <span>
                <span class="src">
                    Variables needed for <code>if</code>, <code>while</code>
                    and <code>for</code> statements should normally be declared
                    within those statements, so that such variables are confined
                    to those scopes. E.g.,:
                </span>

                <code>if</code>文や<code>while</code>文、<code>for</code>文で使用される変数は、通常はそれらの文中で宣言します。そうすることで、変数のスコープを制限できます。以下に例を示します。
            </span>
        </p>
        <pre>while (const char* p = strchr(str, '/')) str = p + 1;
</pre>
        <p>
            <span>
                <span class="src">
                    There is one caveat: if the variable is an object, its
                    constructor is invoked every time it enters scope and is
                    created, and its destructor is invoked every time it goes
                    out of scope.
                </span>
                ただし、変数がオブジェクト型であるときは少し注意が必要です。スコープ内で変数を宣言した場合、スコープに入るたびに毎回コンストラクタが呼ばれ、オブジェクトが生成され、スコープから出るたびに毎回デストラクタが呼ばれることになるためです。
            </span>
        </p>
        <div>
            <div class="src">
                <pre class="badcode">// Inefficient implementation:
for (int i = 0; i &lt; 1000000; ++i) {
  Foo f;  // My ctor and dtor get called 1000000 times each.
  f.DoSomething(i);
}
</pre>
            </div>
            <pre class="badcode">// 非効率的な実装
for (int i = 0; i &lt; 1000000; ++i) {
  Foo f;  // コンストラクタとデストラクタがそれぞれ 1000000 回ずつ呼ばれる。
  f.DoSomething(i);
}
</pre>
        </div>

        <p>
            <span>
                <span class="src">
                    It may be more efficient to declare such a variable
                    used in a loop outside that loop:
                </span>
                このような場合、変数宣言をループの外側に出すことで、より効率的にできる場合があります。
            </span>
        </p>
        <div>
            <div class="src">
                <pre>Foo f;  // My ctor and dtor get called once each.
for (int i = 0; i &lt; 1000000; ++i) {
  f.DoSomething(i);
}
</pre>
            </div>
            <pre>Foo f;  // コンストラクタとデストラクタは1回ずつ呼ばれる。
for (int i = 0; i &lt; 1000000; ++i) {
  f.DoSomething(i);
}
</pre>
        </div>

        <h3 id="Static_and_Global_Variables">
            <span title="Static and Global Variables">静的変数とグローバル変数</span>
        </h3>

        <p>
            <span>
                <span class="src">
                    Objects with
                    <a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">
                        static storage duration</a> are forbidden unless they are
                    <a href="http://en.cppreference.com/w/cpp/types/is_destructible">trivially
                        destructible</a>.
                </span>
                「<a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">静的記憶域期間(static storage duration)</a>」を持つオブジェクトは、
                それらが「<a href="http://en.cppreference.com/w/cpp/types/is_destructible">自明に破壊可能(trivially destructible)</a>」でない限り禁止とします。
            </span>
            <span>
                <span class="src">
                    Informally this means that the destructor does not do
                    anything, even taking member and base destructors into account.
                </span>
                「自明に破壊可能」とは、ざっくり言うと、そのメンバ変数や基底クラスのデストラクタまで含めたとしても、デストラクタが「何もしない」ということを意味します。
            </span>
            <span>
                <span class="src">
                    More formally it
                    means that the type has no user-defined or virtual destructor and that all bases
                    and non-static members are trivially destructible.
                </span>
                より正式には、型にユーザー定義デストラクタまたは仮想デストラクタがなく、かつ、すべての基底クラスと非静的メンバもまた同様に自明に破壊可能であるときに成り立ちます。
            </span>
            <span>
                <span class="src">
                    Static function-local variables may use dynamic initialization.
                </span>
                関数ローカルスコープの静的変数は、動的な初期化を行ってもかまいません。
            </span>
            <span>
                <span class="src">
                    Use of dynamic initialization for static class member variables or variables at
                    namespace scope is discouraged, but allowed in limited circumstances; see below
                    for details.
                </span>
                それ以外の、クラススコープの静的メンバ変数や名前空間スコープの静的変数に対して、動的な初期化を行うことは原則として非推奨です。ただし、後述するいくつかの限定された状況においては、使用が認められることもあります。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    As a rule of thumb: a global variable satisfies these requirements if its
                    declaration, considered in isolation, could be <code>constexpr</code>.
                </span>
                グローバル変数については、大雑把な判断基準として、その宣言が他に独立して<code>constexpr</code>にできるときは、これらの要件も満たしています。
            </span>
        </p>

        <p class="definition"></p>
        <p>
            <span>
                <span class="src">
                    Every object has a <dfn>storage duration</dfn>, which correlates with its
                    lifetime.
                </span>
                すべてのオブジェクトには<dfn>記憶域期間(storage duration)</dfn>があり、その寿命と関連しています。
            </span>
            <span>
                <span class="src">
                    Objects with static storage duration live from the point of their
                    initialization until the end of the program.
                </span>
                静的記憶域期間を持つオブジェクトは、それらが初期化された時点からプログラムの終了までの寿命を持ちます。
            </span>
            <span>
                <span class="src">
                    Such objects appear as variables at
                    namespace scope ("global variables"), as static data members of classes, or as
                    function-local variables that are declared with the <code>static</code>
                    specifier.
                </span>
                これらのオブジェクトは、名前空間スコープの変数(いわゆるグローバル変数)や、クラスの静的データメンバ、あるいは、<code>static</code>指定子つきで宣言された関数ローカルな変数として現れます。
            </span>
            <span>
                <span class="src">
                    Function-local static variables are initialized when control first
                    passes through their declaration; all other objects with static storage duration
                    are initialized as part of program start-up.
                </span>
                静的記憶域期間を持つオブジェクトのうち、関数ローカルの静的変数だけは、プログラムの処理が初めてその宣言を通過するときに初期化され、それ以外のすべての静的記憶域期間を持つオブジェクトは、プログラムの起動処理の一部として初期化されます。
            </span>
            <span>
                <span class="src">
                    All objects with static storage
                    duration are destroyed at program exit (which happens before unjoined threads
                    are terminated).
                </span>
                静的記憶域期間を持つすべてのオブジェクトは、プログラムの終了時に破壊されます。プログラムの終了時に待機(join)されていないスレッドが存在する場合、それらのスレッドが強制終了されるよりも前の時点で破壊されます。
            </span>
        </p>
        <p>
            <span>
                <span class="src">
                    Initialization may be <dfn>dynamic</dfn>, which means that something
                    non-trivial happens during initialization.
                </span>
                これらの変数は<dfn>動的(dynamic)</dfn>に初期化することもできますが、そのような初期化においては自明ではないことが起こるかもしれません。
            </span>
            <span>
                <span class="src">
                    (For example, consider a constructor
                    that allocates memory, or a variable that is initialized with the current
                    process ID.)
                </span>
                (たとえば、メモリを割り当てるコンストラクタの実行や、現在のプロセスIDによって初期化される変数などがこれに当てはまります。)
            </span>
            <span>
                <span class="src">
                    The other kind of initialization is <dfn>static</dfn>
                    initialization.
                </span>
                もう1つの種類の初期化は<dfn>静的(static)</dfn>初期化です。
            </span>
            <span>
                <span class="src">
                    The two aren't quite opposites, though: static
                    initialization <em>always</em> happens to objects with static storage duration
                    (initializing the object either to a given constant or to a representation
                    consisting of all bytes set to zero), whereas dynamic initialization happens
                    after that, if required.
                </span>
                これら2つの初期化は完全に正反対というわけではありません。
                静的初期化は、すべての静的記憶域期間を持つオブジェクトにおいて<em>必ず</em>発生します。(オブジェクトは、初期化子に与えられた何らかの定数や、あるいはゼロで埋めることによって初期化されます。)
                一方で、動的初期化は、静的初期化の後に、必要に応じて行われることになります。
            </span>
        </p>
        <p class="pros"></p>
        <p>
            <span>
                <span class="src">
                    Global and static variables are very useful for a large number of
                    applications: named constants, auxiliary data structures internal to some
                    translation unit, command-line flags, logging, registration mechanisms,
                    background infrastructure, etc.
                </span>
                グローバル変数と静的変数は、たとえば、名前付き定数、一部の翻訳単位内部の補助データ構造、コマンドラインフラグ、ロギング、登録メカニズム、バックグラウンドインフラストラクチャなどに利用することができ、多数のアプリケーションで非常に役立ちます。
            </span>
        </p>
        <p class="cons"></p>
        <p>
            <span>
                <span class="src">
                    Global and static variables that use dynamic initialization or have
                    non-trivial destructors create complexity that can easily lead to hard-to-find
                    bugs.
                </span>
                動的初期化や非自明(non-trivial)デストラクタを持つグローバル変数や静的変数は、プログラムを複雑化させ、容易に発見困難なバグを引き起こします。
            </span>
            <span>
                <span class="src">
                    Dynamic initialization is not ordered across translation units, and
                    neither is destruction (except that destruction
                    happens in reverse order of initialization).
                </span>
                静的記憶域期間を持つ変数の動的初期化は、翻訳単位間をまたいだ順序付けが行われません。また、それらが破壊されるときも(初期化の逆順で行われるという点を除けば)同様です。
            </span>
            <span>
                <span class="src">
                    When one initialization refers to
                    another variable with static storage duration, it is possible that this causes
                    an object to be accessed before its lifetime has begun (or after its lifetime
                    has ended).
                </span>
                ある1つの初期化処理(あるいは破壊処理)において、他の静的記憶域期間を持つ変数を参照していると、そのオブジェクトが初期化される前(あるいは寿命が終わった後)にそのオブジェクトにアクセスしてしまう恐れがあります。
            </span>
            <span>
                <span class="src">
                    Moreover, when a program starts threads that are not joined at exit,
                    those threads may attempt to access objects after their lifetime has ended if
                    their destructor has already run.
                </span>
                さらに、プログラムが実行中に何らかのスレッドを起動して、プログラム終了時にそれらを待機(join)しなかった場合には、それらのスレッドが、デストラクタ実行済みの既に寿命が終わったオブジェクトにアクセスを試みてしまうかもしれません。
            </span>
        </p>
        <p class="decision"></p>
        <h4 title="Decision on destruction">破壊に関する結論</h4>

        <p>
            <span>
                <span class="src">
                    When destructors are trivial, their execution is not subject to ordering at
                    all (they are effectively not "run"); otherwise we are exposed to the risk of
                    accessing objects after the end of their lifetime.
                </span>
                デストラクタが自明(trivial)な場合、それらの実行は順序付けの議論の対象とはなりません(そもそも、実質的に「実行」される処理がありません)。しかし、オブジェクトが非自明なデストラクタを持つ場合には、寿命が終わった後のオブジェクトにアクセスしてしまう危険性を抱え込むことになります。
            </span>
            <span>
                <span class="src">
                    Therefore, we only allow
                    objects with static storage duration if they are trivially destructible.
                </span>
                したがって、静的記憶域期間を持つオブジェクトについては、少なくともそれらが「自明に破壊可能(trivially destructible)」である場合にのみ認めることとします。
            </span>
            <span>
                <span class="src">
                    Fundamental types (like pointers and <code>int</code>) are trivially
                    destructible, as are arrays of trivially destructible types.
                </span>
                基本的な組み込みの型(ポインタや<code>int</code>など)は自明に破壊可能であり、自明に破壊可能な型の配列も同様に自明に破壊可能です。
                
            </span>
            <span>
                <span class="src">
                    Note that
                    variables marked with <code>constexpr</code> are trivially destructible.
                </span>
                また、これらに加えて<code>constexpr</code>でマークされた変数も自明に破壊可能ですので、この点は覚えておくとよいでしょう。
            </span>
        </p>
<div>
            <div class="src">
                <pre>const int kNum = 10;  // Allowed

struct X { int n; };
const X kX[] = {{1}, {2}, {3}};  // Allowed

void foo() {
  static const char* const kMessages[] = {"hello", "world"};  // Allowed
}

// Allowed: constexpr guarantees trivial destructor.
constexpr std::array&lt;int, 3&gt; kArray = {1, 2, 3};</pre>
            </div>
            <pre>const int kNum = 10;  // OK

struct X { int n; };
const X kX[] = {{1}, {2}, {3}};  // OK

void foo() {
  static const char* const kMessages[] = {"hello", "world"};  // OK
}

// OK: constexpr は trivial destructor を保証する。
constexpr std::array&lt;int, 3&gt; kArray = {1, 2, 3};</pre>
</div>
<div>
<div class="src">
        <pre class="badcode">// Bad: non-trivial destructor
const std::string kFoo = "foo";

// Bad for the same reason, even though kBar is a reference (the
// rule also applies to lifetime-extended temporary objects).
const std::string&amp; kBar = StrCat("a", "b", "c");

void bar() {
  // Bad: non-trivial destructor.
  static std::map&lt;int, int&gt; kData = {{1, 0}, {2, 0}, {3, 0}};
}</pre>
            </div>
        <pre class="badcode">// ダメ: non-trivial destructor
const std::string kFoo = "foo";

// 同様の理由でダメ。kBarが参照であったとしても。
// このルールは、一時オブジェクトの有効期限の延長が行われた場合も対象。
const std::string&amp; kBar = StrCat("a", "b", "c");

void bar() {
  // ダメ: non-trivial destructorを持つ
  static std::map&lt;int, int&gt; kData = {{1, 0}, {2, 0}, {3, 0}};
}</pre>
        </div>
        <p>
            <span>
                <span class="src">
                    Note that references are not objects, and thus they are not subject to the
                    constraints on destructibility.
                </span>
                なお、参照はオブジェクトそのものではないため、破壊可能性に関する制約も受けません。
            </span>
            <span>
                <span class="src">
                    The constraint on dynamic initialization still
                    applies, though.
                </span>
                (ただし、その場合であっても、動的初期化に関する制約はそのまま適用されます。)
            </span>
            <span>
                <span class="src">
                    In particular, a function-local static reference of the form
                    <code>static T&amp; t = *new T;</code> is allowed.
                </span>
                特に、<code>static T&amp; t = *new T;</code> のような形の関数ローカルな静的参照変数は問題ありません。
            </span>
        </p>

        <h4 title="Decision on initialization">初期化に関する結論</h4>

        <p>
            <span>
                <span class="src">
                    Initialization is a more complex topic.
                </span>
                初期化は、より複雑なトピックです。
            </span>
            <span>
                <span class="src">
                    This is because we must not only
                    consider whether class constructors execute, but we must also consider the
                    evaluation of the initializer:
                </span>
                というのも、これは、クラスのコンストラクタが実行されるか否かに関してだけでなく、その初期化子の評価についても考える必要があるためです。
            </span>
        </p>
<div>
<div class="src">
        <pre class="neutralcode">int n = 5;    // Fine
int m = f();  // ? (Depends on f)
Foo x;        // ? (Depends on Foo::Foo)
Bar y = g();  // ? (Depends on g and on Bar::Bar)</pre>
            </div>
        <pre class="neutralcode">int n = 5;    // OK
int m = f();  // ？ (fに依存)
Foo x;        // ？ (Fooのコンストラクタに依存)
Bar y = g();  // ？ (gとBarのコンストラクタに依存)</pre>
</div>
        
        <p>
            <span>
                <span class="src">
                    All but the first statement expose us to indeterminate initialization
                    ordering.
                </span>
                最初の例を除くすべての文において、潜在的に初期化順序の不確定性に関する問題があるかもしれません。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    The concept we are looking for is called <em>constant initialization</em> in
                    the formal language of the C++ standard.
                </span>
                この議論で見いだそうとしている概念は、C++標準の形式言語において「<em>定数初期化</em>」と呼ばれるものにあたります。
            </span>
            <span>
                <span class="src">
                    It means that the initializing
                    expression is a constant expression, and if the object is initialized by a
                    constructor call, then the constructor must be specified as
                    <code>constexpr</code>, too:
                </span>
                定数初期化とは、初期化式が定数式であるということを意味します。
                また、定数となるオブジェクトがコンストラクタ呼び出しによって初期化される場合には、そのコンストラクタも<code>constexpr</code>指定されていることが必要です。
            </span>
        </p>
<div>
<div class="src">
        <pre>struct Foo { constexpr Foo(int) {} };

int n = 5;  // Fine, 5 is a constant expression.
Foo x(2);   // Fine, 2 is a constant expression and the chosen constructor is constexpr.
Foo a[] = { Foo(1), Foo(2), Foo(3) };  // Fine</pre>
            </div>
        <pre>struct Foo { constexpr Foo(int) {} };

int n = 5;  // OK、 5 は定数式。
Foo x(2);   // OK、 2 は定数式で、選ばれるコンストラクタもconstexpr。
Foo a[] = { Foo(1), Foo(2), Foo(3) };  // OK</pre>
</div>
        

        <p>
            <span>
                <span class="src">
                    Constant initialization is always allowed.
                </span>
                定数初期化は、いつでも使ってかまいません。
            </span>
            <span>
                <span class="src">
                    Constant initialization of
                    static storage duration variables should be marked with <code>constexpr</code>
                    or <code>constinit</code>.
                </span>
                静的記憶域期間を持つ変数を定数初期化するときは、常に<code>constexpr</code>か<code>constinit</code>でマークします。
            </span>
            <span>
                <span class="src">
                    Any non-local static storage
                    duration variable that is not so marked should be presumed to have
                    dynamic initialization, and reviewed very carefully.
                </span>
                そのようにマークされていない非ローカルな静的記憶域期間の変数は、動的初期化される可能性があるという前提のもとで、非常に慎重にレビューされる必要があります。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    By contrast, the following initializations are problematic:
                </span>
                対照的に、次の初期化には問題があります。
            </span>
        </p>
<div>
<div class="src">
       <pre class="badcode">// Some declarations used below.
time_t time(time_t*);      // Not constexpr!
int f();                   // Not constexpr!
struct Bar { Bar() {} };

// Problematic initializations.
time_t m = time(nullptr);  // Initializing expression not a constant expression
Foo y(f());                // Ditto
Bar b;                     // Chosen constructor Bar::Bar() not constexpr</pre>
            </div>
        <pre class="badcode">// 以降の初期化時に使用される式の宣言
time_t time(time_t*);      // constexprでない!
int f();                   // constexprでない!
struct Bar { Bar() {} };

// 問題のある初期化
time_t m = time(nullptr);  // 初期化式が定数式でない
Foo y(f());                // 同上
Bar b;                     // 選択されるコンストラクタ Bar::Bar() がconstexprでない</pre>
</div>
        <p>
            <span>
                <span class="src">
                    Dynamic initialization of nonlocal variables is discouraged, and in general
                    it is forbidden.
                </span>
                非ローカル変数を動的初期化することは非推奨であり、原則としては禁止です。
            </span>
            <span>
                <span class="src">
                    However, we do permit it if no aspect of the program depends
                    on the sequencing of this initialization with respect to all other
                    initializations.
                </span>
                ただし、その初期化について、プログラムのあらゆる側面からみて、その初期化と他のすべての初期化との間に、順序付けに関する一切の依存性がないと見なせる場合は、そのような初期化を行ってもかまいません。
            </span>
            <span>
                <span class="src">
                    Under those restrictions, the ordering of the initialization
                    does not make an observable difference.
                    For example:
                </span>
                そのような制限の下においては、初期化の順序の違いが、観測可能な違いとして現れることがありません。例を示します。
            </span>
        </p>
<div>
<div class="src">
        <pre>int p = getpid();  // Allowed, as long as no other static variable
                   // uses p in its own initialization.</pre>
            </div>
       <pre>int p = getpid();  // OK。ただし、他の静的変数の初期化において
                   // pを使用していないときに限る。</pre>
</div>
        <p>
            <span>
                <span class="src">
                    Dynamic initialization of static local variables is allowed (and common).
                </span>
                一方で、ローカルな静的変数については、それらを動的に初期化してかまいません(むしろ、そのような初期化は一般的です)。
            </span>
        </p>
        <h4 title="Common patterns">よくあるパターン</h4>
        <ul>
            <li>
                <span>
                    <span class="src">
                        Global strings: if you require a named global or static string constant,
                        consider using a <code>constexpr</code> variable of
                        <code>string_view</code>, character array, or character pointer, pointing
                        to a string literal.
                    </span>
                    グローバル文字列: 名前付きのグローバル文字列定数または静的文字列定数が必要な場合は、<code>constexpr</code>な<code>string_view</code>、<code>constexpr</code>な文字配列、<code>constexpr</code>な文字列リテラルを指すポインタを使用することを検討してください。
                </span>
                <span>
                    <span class="src">
                        String literals have static storage duration already
                        and are usually sufficient.
                    </span>
                    文字列リテラルは、もともと静的記憶域期間を持ち、通常はそれで十分なことが多いです。
                </span>
                <span>
                    <span class="src">
                        See <a href="https://abseil.io/tips/140">TotW #140.</a>
                    </span>
                    <a href="https://abseil.io/tips/140">TotW #140.</a>を参照してください。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        Maps, sets, and other dynamic containers: if you require a static, fixed
                        collection, such as a set to search against or a lookup table, you cannot
                        use the dynamic containers from the standard library as a static variable,
                        since they have non-trivial destructors.
                    </span>
                    連想配列(map)、集合(set)、およびその他の動的コンテナ: 検索対象の集合やルックアップテーブルなどの用途で、静的かつ不変のコレクションが欲しいときであっても、標準ライブラリの動的コンテナは非自明なデストラクタ(non-trivial destructors)を持つため、静的変数として使用してはいけません。
                </span>
                <span>
                    <span class="src">
                        Instead, consider
                        a simple array of trivial types, e.g., an array of arrays of ints (for a "map from int
                        to
                        int"), or an array of pairs (e.g., pairs of <code>int</code> and <code>const
    char*</code>).
                    </span>
                    かわりに、自明(trivial)な型の単純な配列、たとえば <code>int</code>の配列の配列 (「int から int への連想配列」として)や、ペアの配列(たとえば、<code>pair&lt;int, const char*&gt;[]</code>)等を検討してください。
                </span>

                <span>
                    <span class="src">
                        For small collections, linear search is entirely sufficient
                        (and efficient, due to memory locality); consider using the facilities from
                        <a href="https://github.com/abseil/abseil-cpp/blob/master/absl/algorithm/container.h">absl/algorithm/container.h</a>
                        for the standard operations.
                    </span>
                    コレクションが小さいときは線形検索でまったく十分です(線形検索はメモリ局所性の面からみても効率的に動作します)。より一般的な操作を必要とする場合には<a href="https://github.com/abseil/abseil-cpp/blob/master/absl/algorithm/container.h">absl/algorithm/container.h</a>ライブラリを採用することを検討してください。
                </span>

                <span>
                    <span class="src">
                        If necessary, keep the collection in sorted
                        order and use a binary search algorithm.
                    </span>
                    必要であれば、コレクションをソート済みの状態に保っておき、二分探索アルゴリズムを適用することもできるでしょう。
                </span>

                <span>
                    <span class="src">
                        If you do really prefer a dynamic container from the standard library, consider using
                        a function-local static pointer, as described below.
                    </span>
                    それでも、どうしても標準ライブラリの動的コンテナを使いたいというときには、後述する関数ローカルな静的ポインタ変数を用いることを検討してください。
                </span>

            </li>
            <li>
                <span>
                    <span class="src">
                        Smart pointers (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>): smart
                        pointers execute cleanup during destruction and are therefore forbidden.
                    </span>
                    スマートポインタ (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>): スマートポインタはデストラクタ内で解放処理が実行されるため、静的変数としての使用は禁止します。
                </span>
                <span>
                    <span class="src">
                        Consider whether your use case fits into one of the other patterns described
                        in this section.
                    </span>
                    そのようなユースケースにおいては、このセクションで説明している他のパターンのいずれかに当てはめることができないか考えてみてください。
                </span>
                <span>
                    <span class="src">
                        One simple solution is to use a plain pointer to a
                        dynamically allocated object and never delete it (see last item).
                    </span>
                    簡単な解決策の1つは、単純な生のポインタ変数を用意し、動的に割り当てられたオブジェクトへのポインタを保持した上で、そのオブジェクトをdeleteしないままにすることです(最後の項目を参照)。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        Static variables of custom types: if you require static, constant data of
                        a type that you need to define yourself, give the type a trivial destructor
                        and a <code>constexpr</code> constructor.
                    </span>
                    独自の型の静的変数: 独自に定義した型を静的な定数データとして扱いたい場合は、その型に自明(trivial)なデストラクタと<code>constexpr</code>コンストラクタを持たせてください。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        If all else fails, you can create an object dynamically and never delete
                        it by using a function-local static pointer or reference (e.g.,
                        <code>static const auto&amp; impl = *new T(args...);</code>).
                    </span>
                    上記のいずれの方法も採用できない場合は、関数ローカルの静的な生のポインタか参照を用意し、オブジェクトを動的に作成し、それをdeleteしないままにします。
                    (例: <code>static const auto&amp; impl = *new T(args...);</code>)
                </span>
            </li>
        </ul>

        <h3 id="thread_local" title="thread_local Variables">thread_local 変数</h3>
        <p>
            <span>
                <span class="src">
                    <code>thread_local</code> variables that aren't declared inside a function
                    must be initialized with a true compile-time constant,
                    and this must be enforced by using the

                    <a href="https://github.com/abseil/abseil-cpp/blob/master/absl/base/attributes.h">
                        <code>ABSL_CONST_INIT</code></a>
                    attribute.
                </span>
                <code>thread_local</code>変数が、関数スコープよりも外で宣言されるときは、真のコンパイル時定数で初期化されなくてはなりません。これは<a href="https://github.com/abseil/abseil-cpp/blob/master/absl/base/attributes.h"><code>ABSL_CONST_INIT</code></a>属性を使用して強制されていなくてはなりません。
            </span>
            <span>
                <span class="src">
                    Prefer
                    <code>thread_local</code> over other ways of defining thread-local data.
                </span>
                また、スレッドごとにローカルなデータを定義したい場合は、他の方法よりも、標準である<code>thread_local</code>を優先的に使用します。
            </span>
        </p>

        <p class="definition"></p>
        <p>
            <span>
                <span class="src">
                    Variables can be declared with the
                    <code>thread_local</code> specifier:
                </span>
                変数は、次のように、<code>thread_local</code>指定子をつけて宣言することができます。
            </span>
        </p>
        <pre>thread_local Foo foo = ...;
</pre>
        <p>
            <span>
                <span class="src">
                    Such a variable is actually a collection of objects, so that when different
                    threads access it, they are actually accessing different objects.
                </span>
                このような変数は、実際にはオブジェクトのコレクションになり、異なるスレッドからアクセスすると、実際にはそれぞれ異なるオブジェクトにアクセスすることになります。
            </span>

            <span>
                <span class="src">
                    <code>thread_local</code> variables are much like
                    <a href="#Static_and_Global_Variables">static storage duration variables</a>
                    in many respects.
                </span>
                <code>thread_local</code>変数は、多くの点で<a href="#Static_and_Global_Variables">静的記憶域期間の変数</a>によく似ています。
            </span>
            <span>
                <span class="src">
                    For instance, they can be declared at namespace scope,
                    inside functions, or as static class members, but not as ordinary class
                    members.
                </span>
                たとえば、<code>thread_local</code>変数は、名前空間スコープ、関数内、または静的クラスメンバとして宣言できますが、通常のクラスメンバとして宣言することはできません。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    <code>thread_local</code> variable instances are initialized much like
                    static variables, except that they must be initialized separately for each
                    thread, rather than once at program startup.
                </span>
                「プログラムの起動時に一度だけ」ではなく「スレッドごとに個別に」初期化される点を除き、<code>thread_local</code>変数のインスタンスは静的変数とほとんど同じように初期化されます。
            </span>

            <span>
                <span class="src">
                    This means that
                    <code>thread_local</code> variables declared within a function are safe, but
                    other <code>thread_local</code> variables are subject to the same
                    initialization-order issues as static variables (and more besides).
                </span>
                これは、関数内で宣言される<code>thread_local</code>変数は安全であり、それ以外の場所で宣言される<code>thread_local</code>変数は、静的変数と同じように、初期化順序やその他の問題の影響を受けることを意味します。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    <code>thread_local</code> variabls have a subtle destruction-order issue:
                    during thread shutdown, <code>thread_local</code> variables will be destroyed
                    in the opposite order of their initialization (as is generally true in C++).
                </span>
                <code>thread_local</code>変数には、破壊順序に関する微妙な問題もあります。<code>thread_local</code>変数は、スレッドが終了するときに破壊されますが、それらの破壊順序は、(C++が全般的にそうであるように)変数が初期化された順の逆順となります。
            </span>
            <span>
                <span class="src">
                   If code triggered by the destructor of any <code>thread_local</code> variable
                   refers to any already-destroyed <code>thread_local</code> on that thread, we will
                   get a particularly hard to diagnose use-after-free.
                </span>
                もし、ある<code>thread_local</code>変数のデストラクタから呼び出すコードが、同スレッド内で破壊済みの別の<code>thread_local</code>を参照してしまっていると、そのような use-after-free バグ(訳注:破壊後やメモリ解放後にアクセスしてしまうこと)を診断するのは特に困難となるでしょう。
            </span>
        </p>

        <p class="pros">
        </p>
        <ul>
            <li>
                <span>
                    <span class="src">
                        Thread-local data is inherently safe from races (because only one thread
                        can ordinarily access it), which makes <code>thread_local</code> useful for
                        concurrent programming.
                    </span>
                    スレッドローカルなデータは、通常は1つのスレッドからしかアクセスできないので、本質的に競合(race)に対して安全です。
                    このため、<code>thread_local</code>は、並行プログラミングにおいて非常に有用です。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        <code>thread_local</code> is the only standard-supported way of creating
                        thread-local data.
                    </span>
                    スレッドローカルなデータの作成方法として、<code>thread_local</code>は標準でサポートされている中では唯一の方法です。
                </span>
            </li>
        </ul>

        <p class="cons">
        </p>
        <ul>
            <li>
                <span>
                    <span class="src">
                        Accessing a <code>thread_local</code> variable may trigger execution of
                        an unpredictable and uncontrollable amount of other code during thread-start or
                        first use on a given thread.
                    </span>
                    <code>thread_local</code>変数を用いると、スレッド開始時や、各スレッドで初めてその変数を使用するときに、その見た目からは予測も制御もできないような量のコードが実行されるようになる可能性があります。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        <code>thread_local</code> variables are effectively global variables,
                        and have all the drawbacks of global variables other than lack of
                        thread-safety.
                    </span>
                    <code>thread_local</code>変数は事実上グローバル変数であり、スレッドセーフである点を除けば、グローバル変数のもつ欠点と同様の欠点を持ちます。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        The memory consumed by a <code>thread_local</code> variable scales with
                        the number of running threads (in the worst case), which can be quite large
                        in a program.
                    </span>
                    <code>thread_local</code>変数は、(最悪の場合、)実行中のスレッド数に比例した量のメモリを使用するため、プログラムの消費メモリが非常に大きくなる可能性があります。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        Data members cannot be <code>thread_local</code> unless they are also
                        <code>static</code>.
                    </span>
                    データメンバを<code>thread_local</code>とするためには、同時にそれらを<code>static</code>にしなければなりません。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        We may suffer from use-after-free bugs if <code>thread_local</code> variables
                        have complex destructors.
                    </span>
                    <code>thread_local</code>変数が複雑なデストラクタを持っている場合には、use-after-freeバグに悩まされるかもしれません。
                </span>
                <span>
                    <span class="src">
                        In particular, the destructor of any such variable must not
                        call any code (transitively) that refers to any potentially-destroyed
                        <code>thread_local</code>.
                    </span>
                    特に、このような変数のデストラクタにおいては、推移的な呼び出しも含めて、潜在的に破壊済みかもしれない他の<code>thread_local</code>変数を参照するコードを呼び出してはなりません。
                </span>
                <span>
                    <span class="src">
                         This property is hard to enforce.
                    </span>
                    しかし、このような特性を強制するのは困難です。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        Approaches for avoiding use-after-free in global/static contexts do not work for
                        <code>thread_local</code>s.
                    </span>
                    グローバル変数や静的変数で使われるuse-after-freeバグを回避するテクニックは、<code>thread_local</code>変数に対しては役に立ちません。
                </span>
                <span>
                    <span class="src">
                        Specifically, skipping destructors for globals and static
                        variables is allowable because their lifetimes end at program shutdown.
                    </span>
                    このテクニックは、具体的には、グローバル変数や静的変数の生存期間がプログラムの終了時までであることを利用し、それらのデストラクタを呼ばずにそのままプログラムを終了させてしまう手法のことを指します。
                </span>
                <span>
                    <span class="src">
                        Thus, any "leak" is managed immediately by the OS cleaning up our memory and other resources.
                    </span>
                    このときに発生する何らかの「リーク」は、OSによるメモリとリソースのクリーンアップ処理によって直ちに処理されるため問題になりません。
                </span>
                <span>
                    <span class="src">
                        By
                        contrast, skipping destructors for <code>thread_local</code> variables leads to resource
                        leaks proportional to the total number of threads that terminate during the lifetime of
                        the program.
                    </span>
                    対照的に、<code>thread_local</code>変数のデストラクタ呼び出しをスキップするようにしてしまうと、プログラムの実行期間中に終了する延べのスレッド数に比例して、リソースリークを引き起こしてしまうことになります。
                </span>
            </li>

        </ul>

        <p class="decision">
        </p>
        <p>
            <span>
                <span class="src">
                    <code>thread_local</code> variables at class or namespace scope must be
                    initialized with a true compile-time constant (i.e., they must have no
                    dynamic initialization).
                </span>
                クラススコープや名前空間スコープの<code>thread_local</code>変数は、真のコンパイル時定数で初期化されなければなりません。(すなわち、動的初期化されてはなりません。)
            </span>
            <span>
                <span class="src">
                    To enforce this, <code>thread_local</code> variables
                    at class or namespace scope must be annotated with


                    <a href="https://github.com/abseil/abseil-cpp/blob/master/absl/base/attributes.h">
                    <code>ABSL_CONST_INIT</code></a>
                    (or <code>constexpr</code>, but that should be rare):
                </span>
                これを強制するため、そのようなスコープの<code>thread_local</code>変数は<a href="https://github.com/abseil/abseil-cpp/blob/master/absl/base/attributes.h">
                <code>ABSL_CONST_INIT</code></a>でマークされていなければなりません(もしくは<code>constexpr</code>でマークしてもかまいませんが、こちらを使うのはレアケースでしょう)。
            </span>
         </p>

         <p>
            <span>
                <span class="src">
                    <code>thread_local</code> variables inside a function have no initialization
                    concerns, but still risk use-after-free during thread exit.
                </span>
                <code>thread_local</code>変数を関数内スコープで宣言する場合は、初期化時の懸念事項はなくなります。ただし、依然としてスレッド終了時のuse-after-freeバグに関する危険性は残ります。
            </span>

            <span>
                <span class="src">
                    Note that you can use
                    a function-scope <code>thread_local</code> to simulate a class- or
                    namespace-scope <code>thread_local</code> by defining a function or
                    static method that exposes it:
                </span>
                なお、次のように、関数や静的メソッドを用意して関数内スコープの<code>thread_local</code>を定義することで、クラススコープや名前空間スコープの<code>thread_local</code>変数をシミュレートすることができますので、テクニックとして覚えておくとよいでしょう。
            </span>
        </p>

        <pre>Foo&amp; MyThreadLocalFoo() {
    thread_local Foo result = ComplicatedInitialization();
    return result;
}</pre>


  <p>
            <span>
                <span class="src">
                    Note that <code>thread_local</code> variables will be destroyed whenever a thread exits.
                </span>
                <code>thread_local</code>変数が破壊されるのはスレッド終了時です。
            </span>
  
            <span>
                <span class="src">
                    If the destructor of any such variable refers to any other (potentially-destroyed)
                    <code>thread_local</code> we will suffer from hard to diagnose use-after-free bugs.
                </span>
                もし、これらの変数のデストラクタで、他の(破壊済みかもしれない)<code>thread_local</code>変数を参照していると、診断が困難なuse-after-freeバグに悩まされることになるかもしれません。
            </span>
  
            <span>
                <span class="src">
                    Prefer trivial types, or types that provably run no user-provided code at destruction to
                    minimize the potential of accessing any other <code>thread_local</code>.
                </span>
                デストラクタにおける他<code>thread_local</code>変数への潜在的なアクセスを最小化するために、自明(trivial)な型や、ユーザ定義のデストラクタを持たない型を用いるようにしましょう。
            </span>
        </p>
        <p>
            <span>
                <span class="src">
                    <code>thread_local</code> should be preferred over other mechanisms for
                    defining thread-local data.
                </span>
                また、スレッドローカルなデータを定義するときは、他の仕組みよりも、標準の<code>thread_local</code>を優先的に採用しましょう。
            </span>
        </p>

        <h2 id="Classes">
            <span title="Classes">クラス</span>
        </h2>

        <p>
            <span>
                <span class="src">
                    Classes are the fundamental unit of code in C++.
                </span>
                クラスはC++におけるコードの基本単位です。
            </span>
            <span>
                <span class="src">
                    Naturally, we use them extensively.
                </span>
                もちろん、私たちは、すでにクラスを広く使っています。
            </span>
            <span>
                <span class="src">
                    This section lists the main dos and
                    don'ts you should follow when writing a class.
                </span>
                このセクションでは、クラスを書くときに、すべきこと、すべきでないことについて述べます。
            </span>
        </p>

        <h3 id="Doing_Work_in_Constructors">
            <span title="Doing Work in Constructors">コンストラクタで行うこと</span>
        </h3>

        <p>
            <span>
                <span class="src">
                    Avoid virtual method calls in constructors, and avoid
                    initialization that can fail if you can't signal an error.
                </span>
                コンストラクタで仮想メンバ関数を呼んではいけません。
                また、エラーを伝える何らかの手段がない場合、失敗する可能性のある初期化処理を行ってはいけません。
            </span>
        </p>

        <p class="definition"></p>
        <p>
            <span>
                <span class="src">
                    It is possible to perform arbitrary initialization in the body
                    of the constructor.
                </span>
                コンストラクタでは任意の初期化処理を行うことができます。
            </span>
        </p>
        <p class="pros"></p>
        <ul>
            <li>
                <span>
                    <span class="src">
                        No need to worry about whether the class has been initialized or
                        not.
                    </span>
                    クラスが初期化済みであるか否かについて、心配しなくてよくなります。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Objects that are fully initialized by constructor call can
                        be <code>const</code> and may also be easier to use with standard containers
                        or algorithms.
                    </span>
                    コンストラクタによってオブジェクトが完全に初期化されるのであれば、そのオブジェクトを<code>const</code>にすることができます。また、標準コンテナや標準アルゴリズムで扱いやすくもなります。
                </span>
            </li>
        </ul>

        <p class="cons"></p>
        <ul>
            <li>
                <span>
                    <span class="src">
                        If the work calls virtual functions, these calls
                        will not get dispatched to the subclass
                        implementations.
                    </span>
                    コンストラクタから仮想関数が呼び出されたとしても、派生クラスの実装が呼び出されることはありません。
                </span>
                <span>
                    <span class="src">
                        Future modification to your class can
                        quietly introduce this problem even if your class is
                        not currently subclassed, causing much confusion.
                    </span>
                    現時点では、クラスに派生クラスがなかったとしても、将来的にクラスが変更されたときに静かにこの問題が入り込み、混乱を招くことになるかもしれません。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        There is no easy way for constructors to signal errors, short of
                        crashing the program (not always appropriate) or using exceptions
                        (which are <a href="#Exceptions">forbidden</a>).
                    </span>
                    コンストラクタには、エラーを伝える簡単な方法がありません。せいぜい、プログラムをクラッシュさせる(常にそれが適切とは限りません)か、例外を使う(ルール上は<a href="#Exceptions">禁止</a>です)方法くらいです。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        If the work fails, we now have an object whose initialization
                        code failed, so it may be an unusual state requiring a <code>bool
                        IsValid()</code> state checking mechanism (or similar) which is easy
                        to forget to call.
                    </span>
                    コンストラクタが処理に失敗したときは、正しく初期化されていない中途半端なオブジェクトができてしまいます。そのため、<code>bool IsValid()</code>のような、状態をチェックする仕組みを必要とするかもしれません。しかし、そのような仕組みを用意してすら、それを呼び出すこと自体も簡単に忘れられてしまいます。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        You cannot take the address of a constructor, so whatever work
                        is done in the constructor cannot easily be handed off to, for
                        example, another thread.
                    </span>
                    コンストラクタのアドレスを得ることはできません。このため、コンストラクタの処理内容を他のスレッドなどに渡したりするようなことは、簡単にはできません。
                </span>
            </li>
        </ul>

        <p class="decision"></p>
        <p>
            <span>
                <span class="src">
                    Constructors should never call virtual functions.
                </span>
                コンストラクタでは仮想関数を呼び出してはいけません。
            </span>
            <span>
                <span class="src">
                    If appropriate
                    for your code ,
                    terminating the program may be an appropriate error handling
                    response.
                </span>
                コンストラクタで発生するエラーの処理の方法としては、適切な場合には、そのままプログラムを強制終了するのも1つの手段でしょう。
            </span>
            <span>
                <span class="src">
                    Otherwise, consider a factory function
                    or <code>Init()</code> method as described in
                    <a href="https://abseil.io/tips/42">TotW #42</a>
                    .
                </span>
                さもなくば、<a href="https://abseil.io/tips/42">TotW #42</a>で説明されているような、ファクトリ関数や<code>Init()</code>メソッドの導入を検討しましょう。
            </span>
            <span>
                <span class="src">
                    Avoid <code>Init()</code> methods on objects With
                    no other states that affect which public methods may be called
                    (semi-constructed objects of this form are particularly hard to work
                    with correctly).
                </span>
                どのパブリックメソッドを呼びだせるかに影響するような他の状態を持たないオブジェクトでは<code>Init()</code>メソッドは避けてください(この形の中途半端に構築されたオブジェクトを正しく扱うのは非常に困難です)。
            </span>
        </p>

        <a id="Explicit_Constructors"></a>
        <h3 id="Implicit_Conversions">
            <span title="Implicit Conversions">暗黙的型変換</span>
        </h3>

        <p>
            <span>
                <span class="src">
                    Do not define implicit conversions.
                </span>
                暗黙的型変換を定義してはいけません。
            </span>
            <span>
                <span class="src">
                    Use the <code>explicit</code>
                    keyword for conversion operators and single-argument
                    constructors.
                </span>
                型変換演算子や、引数1つのコンストラクタには、<code>explicit</code>キーワードを使用してください。
            </span>
        </p>

        <p class="definition"></p>
        <p>
            <span>
                <span class="src">
                    Implicit conversions allow an
                    object of one type (called the <dfn>source type</dfn>) to
                    be used where a different type (called the <dfn>destination
                    type</dfn>) is expected, such as when passing an
                    <code>int</code> argument to a function that takes a
                    <code>double</code> parameter.
                </span>
                暗黙的型変換によって、ある型(<dfn>変換元の型</dfn>)のオブジェクトを、異なる型(<dfn>変換先の型</dfn>)が期待される箇所で用いることができるようになります。たとえば、<code>double</code>型の引数をとる関数に<code>int</code>型の値を渡すといった例が考えられます。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    In addition to the implicit conversions defined by the language,
                    users can define their own, by adding appropriate members to the
                    class definition of the source or destination type.
                </span>
                言語で元々定義されている暗黙的型変換に加えて、変換元の型か変換先の型のクラス定義に適切なメンバを加えることで、独自の暗黙的型変換を定義することができます。
            </span>
            <span>
                <span class="src">
                    An implicit
                    conversion in the source type is defined by a type conversion operator
                    named after the destination type (e.g., <code>operator
                    bool()</code>).
                </span>
                変換元の型で暗黙的型変換を定義するには、変換先の型の名前をもつ型変換演算子を定義します(例:<code>operator bool()</code>)。
            </span>
            <span>
                <span class="src">
                    An implicit conversion in the destination
                    type is defined by a constructor that can take the source type as
                    its only argument (or only argument with no default value).
                </span>
                変換先の型で暗黙的型変換を定義するには、変換元の型の引数を1つだけとる(またはデフォルト値のない引数を1つだけとる)コンストラクタを定義します。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    The <code>explicit</code> keyword can be applied to a constructor
                    or a conversion operator, to ensure that it can only be
                    used when the destination type is explicit at the point of use,
                    e.g., with a cast.
                </span>
                <code>explicit</code>キーワードは、コンストラクタや型変換演算子に適用することができ、キャストなどによって変換先の型が明示された場合にのみ変換が行われるように限定することができます。
            </span>
            <span>
                <span class="src">
                    This applies not only to implicit conversions, but to
                    list initialization syntax:
                </span>
                これは、暗黙的型変換を防ぐだけではなく、以下に示すようなリスト初期化構文にも適用されます。
            </span>
        </p>
        <pre>class Foo {
  explicit Foo(int x, double y);
  ...
};

void Func(Foo f);
</pre>
        <pre class="badcode">Func({42, 3.14});  // Error
</pre>
        <span>
            <span class="src">
                This kind of code isn't technically an implicit conversion, but the
                language treats it as one as far as <code>explicit</code> is concerned.
            </span>
            これに類するコードは、技術的には暗黙的型変換ではないのですが、言語系からは暗黙的変換の一種のように扱われ、<code>explicit</code>の影響を受けることになります。
        </span>

        <p class="pros"></p>
        <ul>
            <li>
                <span>
                    <span class="src">
                        Implicit conversions can make a type more usable and
                        expressive by eliminating the need to explicitly name a type
                        when it's obvious.
                    </span>
                    要求される型が明らかな箇所においては、暗黙的型変換によって型名を省略できるようになるため、型の利便性や表現性が高まります。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        Implicit conversions can be a simpler alternative to
                        overloading, such as when a single
                        function with a <code>string_view</code> parameter takes the
                        place of separate overloads for <code>std::string</code> and
                        <code>const char*</code>.
                    </span>
                    暗黙的型変換を関数オーバーロードの代替手段として用いると、APIをよりシンプルにできます。
                    たとえば、引数に<code>std::string</code>を受け取る関数オーバーロードと<code>const char*</code>を受け取る関数オーバーロードとを別々に定義するかわりに、<code>string_view</code>を引数とした関数を1つだけ用意して済ませることができるようになります。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        List initialization syntax is a concise and expressive
                        way of initializing objects.
                    </span>
                    リスト初期化の構文は、オブジェクトの初期化方法として簡潔で表現的です。
                </span>
            </li>
        </ul>

        <p class="cons"></p>
        <ul>
            <li>
                <span>
                    <span class="src">
                        Implicit conversions can hide type-mismatch bugs, where the
                        destination type does not match the user's expectation, or
                        the user is unaware that any conversion will take place.
                    </span>
                    暗黙的型変換は、型の不一致に起因するバグを隠蔽してしまうことがあります。
                    たとえば、期待と異なる型に変換されてしまったり、そもそもその場で他の型への型変換が行われてしまっていることにすら気づけなかったりするかもしれません。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Implicit conversions can make code harder to read, particularly
                        in the presence of overloading, by making it less obvious what
                        code is actually getting called.
                    </span>
                    暗黙的型変換は、コードの可読性を下げることがあります。特に、関数がオーバーロードされている場合は、実際にどの関数オーバーロードが呼び出されるのか、わかりにくくなってしまうことがあります。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Constructors that take a single argument may accidentally
                        be usable as implicit type conversions, even if they are not
                        intended to do so.
                    </span>
                    引数1つのコンストラクタによって、意図せず型変換の機能を提供してしまうことがあります。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        When a single-argument constructor is not marked
                        <code>explicit</code>, there's no reliable way to tell whether
                        it's intended to define an implicit conversion, or the author
                        simply forgot to mark it.
                    </span>
                    引数1つのコンストラクタが<code>explicit</code>でマークされていないとき、そのコンストラクタが、暗黙的な型変換を意図したものなのか、あるいは単に<code>explicit</code>を付け忘れただけなのかを判断する手段がありません。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Implicit conversions can lead to call-site ambiguities, especially
                        when there are bidirectional implicit conversions.
                    </span>
                    特に、ある2つの型が双方向に暗黙的型変換が可能なときは、暗黙的型変換によって、呼び出し元のコードが曖昧になってしまうかもしれません。
                </span>
                <span>
                    <span class="src">
                        This can be caused
                        either by having two types that both provide an implicit conversion,
                        or by a single type that has both an implicit constructor and an
                        implicit type conversion operator.
                    </span>
                    これは、それらの2つの型の双方において暗黙的型変換が提供されているときや、片方の型において暗黙的型変換を行うコンストラクタと暗黙的型変換を行う演算子の両方が実装されているときに起こります。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        List initialization can suffer from the same problems if
                        the destination type is implicit, particularly if the
                        list has only a single element.
                    </span>
                    リスト初期化においても、変換先の型が暗黙的であるとき、特にリストの要素が1つだけであるときに、同様の問題に直面します。
                </span>
            </li>
        </ul>

        <p class="decision"></p>
        <p>
            <span>
                <span class="src">
                    Type conversion operators, and constructors that are
                    callable with a single argument, must be marked
                    <code>explicit</code> in the class definition.
                </span>
                型変換演算子、および、引数1つで呼び出せるコンストラクタは、その定義において<code>explicit</code>でマークされていなくてはなりません。
            </span>
            <span>
                <span class="src">
                    As an
                    exception, copy and move constructors should not be
                    <code>explicit</code>, since they do not perform type
                    conversion.
                </span>
                例外として、コピーコンストラクタとムーブコンストラクタについては、<code>explicit</code>でマークしてはいけません(これらのコンストラクタでは型変換は行われません)。
            </span>
            <span>
                <span class="src">
                    Implicit conversions can sometimes be necessary and appropriate for
                    types that are designed to be interchangeable, for example when objects
                    of two types are just different representations of the same underlying
                    value.
                </span>
                暗黙的型変換は、場合によって、必要かつ適切であることもあります。たとえば、ある2つの型が、同じ意味の値に対して表現方法のみが異なるようなときは、型を相互に交換可能であるように設計してもよいでしょう。(訳注: <code>std::chrono::duration</code>などがそうでしょうか。)
            </span>
            <span>
                <span class="src">
                    In that case, contact
                    your project leads to request
                    a waiver of this rule.
                </span>
                この場合は、プロジェクトリーダーと相談し、このルールの適用外としてください。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Constructors that cannot be called with a single argument
                    may omit <code>explicit</code>.
                </span>
                引数1つで呼び出せないコンストラクタについては、<code>explicit</code>を省略してかまいません。
            </span>
            <span>
                <span class="src">
                    Constructors that
                    take a single <code>std::initializer_list</code> parameter should
                    also omit <code>explicit</code>, in order to support copy-initialization
                    (e.g., <code>MyType m = {1, 2};</code>).
                </span>
                また、引数に<code>std::initializer_list</code>を1つだけとるコンストラクタについても、コピーによる初期化(<code>MyType m = {1, 2};</code>の形)をサポートするために<code>explicit</code>を省略してください。
            </span>
        </p>

        <h3 id="Copyable_Movable_Types">
            <span title="Copyable and Movable Types">コピー可能な型・ムーブ可能な型</span>
        </h3>
        <a id="Copy_Constructors"></a>

        <p>
            <span>
                <span class="src">
                    A class's public API must make clear whether the class is copyable,
                    move-only, or neither copyable nor movable.
                </span>
                クラスを定義するときは、その公開APIにおいて、その型のオブジェクトがコピー可能なのか、ムーブのみ可能なのか、あるいは、いずれも不可能なのか明確にわかるようにしておかなければなりません。
            </span>
            <span>
                <span class="src">
                    Support copying and/or
                    moving if these operations are clear and meaningful for your type.
                </span>
                オブジェクトのコピー操作やムーブ操作について明確かつ意味が通るのであれば、型でそれらの操作を定義します。
            </span>
        </p>

        <p class="definition"></p>
        <p>
            <span>
                <span class="src">
                    A movable type is one that can be initialized and assigned
                    from temporaries.
                </span>
                「型がムーブ可能である」とは、一時オブジェクトから新たなオブジェクトを初期化および代入可能であることを言います。
            </span>
        </p>
        <p>
            <span>
                <span class="src">
                    A copyable type is one that can be initialized or assigned from
                    any other object of the same type (so is also movable by definition), with the
                    stipulation that the value of the source does not change.
                </span>
                「型がコピー可能である」とは、同じ型の別のオブジェクトから、そのオブジェクトの値を変化させることなく、新たなオブジェクトを初期化および代入可能であることを言います。(その定義から、コピー可能な型は、同時にムーブ可能でもあります。)
            </span>
            <span>
                <span class="src">
                    <code>std::unique_ptr&lt;int&gt;</code> is an example of a movable but not
                    copyable type (since the value of the source
                    <code>std::unique_ptr&lt;int&gt;</code> must be modified during assignment to
                    the destination).
                </span>
                たとえば、<code>std::unique_ptr&lt;int&gt;</code>は、ムーブ可能であるがコピーは不可な型の一例です。(別の<code>std::unique_ptr&lt;int&gt;</code>変数への代入操作を行うときには、代入操作に使われる元の値が変更される必要があります。)
            </span>

            <span>
                <span class="src">
                    <code>int</code> and <code>std::string</code> are examples of
                    movable types that are also copyable.
                </span>
                <code>int</code>や<code>std::string</code>は、ムーブもコピーも可能な型の例です。
            </span>

            <span>
                <span class="src">
                    (For <code>int</code>, the move and copy
                    operations are the same; for <code>std::string</code>, there exists a move operation
                    that is less expensive than a copy.)
                </span>
                (<code>int</code>においてはムーブとコピーは同一の操作となり、
                <code>std::string</code>においては、コピー操作よりも低コストなムーブ操作が提供されています。)
            </span>

            <span>
                <span class="src">
                    For user-defined types, the copy behavior is defined by the copy
                    constructor and the copy-assignment operator.
                </span>
                ユーザー定義の型において、コピーの挙動はコピーコンストラクタとコピー代入演算子によって定義されます。
            </span>

            <span>
                <span class="src">
                    Move behavior is defined by the
                    move constructor and the move-assignment operator, if they exist, or by the
                    copy constructor and the copy-assignment operator otherwise.
                </span>
                ムーブの挙動は、ムーブコンストラクタとムーブ代入演算子が定義されていればそれらによって定義され、ムーブコンストラクタとムーブ代入演算子が定義されていなければコピー操作と同一になります。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    The copy/move constructors can be implicitly invoked by the compiler
                    in some situations, e.g., when passing objects by value.
                </span>
                コピーコンストラクタやムーブコンストラクタは、オブジェクトを値渡しするときなど、コンパイラによって暗黙的に呼び出されます。
            </span>
        </p>
        <p class="pros"></p>
        <p>
            <span>
                <span class="src">
                    Objects of copyable and movable types can be passed and returned by value,
                    which makes APIs simpler, safer, and more general.
                </span>
                コピー可能な型・ムーブ可能な型のオブジェクトは値渡し・値戻しすることができます。これによって、よりシンプル、より安全、より一般的な形でAPIを定義することができるようになります。
            </span>
            <span>
                <span class="src">
                    Unlike when passing objects
                    by pointer or reference, there's no risk of confusion over ownership,
                    lifetime, mutability, and similar issues, and no need to specify them in the
                    contract.
                </span>
                値渡しは、ポインタ渡し・参照渡しするときとは異なり、オブジェクトの所有権や寿命、変更可能性、その他の類する危険がなく、APIにおいてそれらに関する前提条件を定める必要もなくなります。
            </span>
            <span>
                <span class="src">
                    It also prevents non-local interactions between the client and the
                    implementation, which makes them easier to understand, maintain, and optimize by
                    the compiler.
                </span>
                また同様に、呼び出し元と実装をつないでしまうような非局所的な相互作用が自動的に防がれます。これによって、理解しやすくメンテナンスしやすい形でオブジェクトを実装することができ、同時に、コンパイラによる最適化も掛かりやすくなります。
            </span>
            <span>
                <span class="src">
                    Further, such objects can be used with generic APIs that
                    require pass-by-value, such as most containers, and they allow for additional
                    flexibility in e.g., type composition.
                </span>
                さらに、このようなオブジェクトは、多くのコンテナ型のように値渡しを要求する一般的なAPIにも用いることができますし、あるいは、型の抱合などを行う際にもより柔軟に対応することができるようになります。
            </span>
        </p>
        <p>
            <span>
                <span class="src">
                    Copy/move constructors and assignment operators are usually
                    easier to define correctly than alternatives
                    like <code>Clone()</code>, <code>CopyFrom()</code> or <code>Swap()</code>,
                    because they can be generated by the compiler, either implicitly or
                    with <code>= default</code>.
                </span>
                コピーコンストラクタ、ムーブコンストラクタ、また関連する代入演算子は、暗黙的に、あるいは明示的に<code>= default</code>と記述することで、コンパイラに生成させることができます。これらを自動生成させれば、<code>Clone()</code>, <code>CopyFrom()</code>, <code>Swap()</code>のような代替手段よりも簡単に正しい実装を得ることができるかもしれません。
            </span>
            <span>
                <span class="src">
                    They are concise, and ensure
                    that all data members are copied.
                </span>
                これらの自動生成されるコンストラクタや代入演算子は簡潔で、しかも、すべてのメンバがコピーされることが保証されます。
            </span>
            <span>
                <span class="src">
                    Copy and move
                    constructors are also generally more efficient, because they don't
                    require heap allocation or separate initialization and assignment
                    steps, and they're eligible for optimizations such as

                    <a href="http://en.cppreference.com/w/cpp/language/copy_elision">
                        copy elision</a>.
                </span>
                また、一般に、これらの代替手段よりも、コピーコンストラクタやムーブコンストラクタを用いる方が効率的にもなりやすいです。これらのコンストラクタを用いる場合は、ヒープメモリの確保が不要になり、初期化と割り当てをまとめて行えて、かつ、<a href="http://en.cppreference.com/w/cpp/language/copy_elision">コピーの省略</a>のような最適化に対しても適格となるためです。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Move operations allow the implicit and efficient transfer of
                    resources out of rvalue objects.
                </span>
                ムーブ操作の仕組みによって、右辺値オブジェクトから暗黙的かつ効率的にリソースを取り出すことが実現可能になります。
            </span>
            <span>
                <span class="src">
                    This allows a plainer coding style
                    in some cases.
                </span>
                また、場合によっては、より簡潔なコーディングスタイルを採用できるようにもなるでしょう。
            </span>
        </p>
        <p class="cons"></p>
        <p>
            <span>
                <span class="src">
                    Some types do not need to be copyable, and providing copy
                    operations for such types can be confusing, nonsensical, or outright
                    incorrect.
                </span>
                型によっては、コピー操作が不要であったり、そもそもコピー操作を提供すること自体が、概念上おかしい場合があります。
            </span>
            <span>
                <span class="src">
                    Types representing singleton objects (<code>Registerer</code>),
                    objects tied to a specific scope (<code>Cleanup</code>), or closely coupled to
                    object identity (<code>Mutex</code>) cannot be copied meaningfully.
                </span>
                たとえば、(<code>Registerer</code>のような)シングルトンオブジェクトや、(<code>Cleanup</code>のような)そのスコープに紐付くオブジェクト、あるいは(<code>Mutex</code>のような)その識別子自体と紐付けて使われるオブジェクトは、意味のある形でコピーを定義できません。
            </span>
        </p>
        <p>
            <span>
                <span class="src">
                    Copy operations for base class types that are to be used
                    polymorphically are hazardous, because use of them can lead to
                    <a href="https://en.wikipedia.org/wiki/Object_slicing">object slicing</a>.
                </span>
                ポリモーフィズムを使用しているような型においては、基底クラスに対するコピー操作は、<a href="https://en.wikipedia.org/wiki/Object_slicing">オブジェクトのスライシング</a>を引き起こす可能性があるため、非常に危険です。
            </span>
            <span>
                <span class="src">
                    Defaulted or carelessly-implemented copy operations can be incorrect, and the
                    resulting bugs can be confusing and difficult to diagnose.
                </span>
                コピー操作をデフォルトのままにしていたり、深く考えずにコピー操作を定義してしまうと、それらの実装は「正しくない」実装になる可能性があり、その結果として診断の難しい困惑的なバグを招くかもしれません。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Copy constructors are invoked implicitly, which makes the
                    invocation easy to miss.
                </span>
                また、コピーコンストラクタは暗黙的に呼び出されるため、その呼び出しそのものも見落としやすいです。
            </span>
            <span>
                <span class="src">
                    This may cause confusion for programmers used to
                    languages where pass-by-reference is conventional or mandatory.
                </span>
                これは、参照渡しが慣習的(あるいは必須)であるような他のプログラミング言語に慣れ親しんでいるプログラマーにとって、特に困惑的なポイントかもしれません。
            </span>
            <span>
                <span class="src">
                    It may also
                    encourage excessive copying, which can cause performance problems.
                </span>
                また、これによって、オブジェクトの過度なコピーが助長され、パフォーマンス上の問題となって表れるかもしれません。
            </span>
        </p>
        <p class="decision"></p>
        <p>
            <span>
                <span class="src">
                    Every class's public interface must make clear which copy and move
                    operations the class supports.
                </span>
                すべてのクラスの公開インターフェースにおいて、その型がコピー可能か、ムーブ可能か、明確にわかるようにしなければなりません。
            </span>
            <span>
                <span class="src">
                    This should usually take the form of explicitly
                    declaring and/or deleting the appropriate operations in the <code>public</code>
                    section of the declaration.
                </span>
                これは、通常は、クラス宣言の<code>public</code>セクションにおいて、対応する操作を明示的に宣言あるいは削除することによって行います。
            </span>
        </p>
        <p>
            <span>
                <span class="src">
                    Specifically, a copyable class should explicitly declare the copy
                    operations, a move-only class should explicitly declare the move operations,
                    and a non-copyable/movable class should explicitly delete the copy operations.
                </span>
                すなわち、コピー可能なクラスではコピー操作を明示的に宣言し、ムーブのみ可能なクラスではムーブ操作を明示的に宣言し、コピーもムーブもできないクラスでは、コピー操作を明示的に削除しましょう。
            </span>
            <span>
                <span class="src">
                    A
                    copyable class may also declare move operations in order to support efficient
                    moves.
                </span>
                コピー可能クラスにおいては、より効率的なムーブを提供するために、追加のムーブ操作に関する宣言をしてもかまいません。
            </span>
            <span>
                <span class="src">
                    Explicitly declaring or deleting all four copy/move operations is permitted,
                    but not required.
                </span>
                4つのコピー・ムーブ操作すべてを明示的に宣言または削除してもかまいませんが、必須ではありません。
            </span>
            <span>
                <span class="src">
                    If you provide a copy or move assignment operator, you
                    must also provide the corresponding constructor.
                </span>
                ただし、コピー代入演算子やムーブ代入演算子を提供する場合は、必ずその操作に対応するコンストラクタも提供するようにしてください。
            </span>
        </p>
<div>
<div class="src">
        <pre>class Copyable {
 public:
  Copyable(const Copyable&amp; other) = default;
  Copyable&amp; operator=(const Copyable&amp; other) = default;

  // The implicit move operations are suppressed by the declarations above.
  // You may explicitly declare move operations to support efficient moves.
};

class MoveOnly {
 public:
  MoveOnly(MoveOnly&amp;&amp; other) = default;
  MoveOnly&amp; operator=(MoveOnly&amp;&amp; other) = default;

  // The copy operations are implicitly deleted, but you can
  // spell that out explicitly if you want:
  MoveOnly(const MoveOnly&amp;) = delete;
  MoveOnly&amp; operator=(const MoveOnly&amp;) = delete;
};

class NotCopyableOrMovable {
 public:
  // Not copyable or movable
  NotCopyableOrMovable(const NotCopyableOrMovable&amp;) = delete;
  NotCopyableOrMovable&amp; operator=(const NotCopyableOrMovable&amp;)
      = delete;

  // The move operations are implicitly disabled, but you can
  // spell that out explicitly if you want:
  NotCopyableOrMovable(NotCopyableOrMovable&amp;&amp;) = delete;
  NotCopyableOrMovable&amp; operator=(NotCopyableOrMovable&amp;&amp;)
      = delete;
};
</pre>
            </div>
       <pre>class Copyable {
 public:
  Copyable(const Copyable&amp; other) = default;
  Copyable&amp; operator=(const Copyable&amp; other) = default;

  // 暗黙的ムーブ操作は、上記の宣言によって抑制されます。
  // 効率的なムーブをサポートするために、明示的にムーブ操作を宣言してもかまいません。
};

class MoveOnly {
 public:
  MoveOnly(MoveOnly&amp;&amp; other) = default;
  MoveOnly&amp; operator=(MoveOnly&amp;&amp; other) = default;

  // コピー操作は暗黙的に削除されます。
  // 次のように、明示的に宣言してもかまいません。
  MoveOnly(const MoveOnly&amp;) = delete;
  MoveOnly&amp; operator=(const MoveOnly&amp;) = delete;
};

class NotCopyableOrMovable {
 public:
  // コピーもムーブも不可
  NotCopyableOrMovable(const NotCopyableOrMovable&amp;) = delete;
  NotCopyableOrMovable&amp; operator=(const NotCopyableOrMovable&amp;)
      = delete;

  // この例では、ムーブ操作は暗黙的に無効になります。
  // 次のように、明示的に宣言してもかまいません。
  NotCopyableOrMovable(NotCopyableOrMovable&amp;&amp;) = delete;
  NotCopyableOrMovable&amp; operator=(NotCopyableOrMovable&amp;&amp;)
      = delete;
};
</pre>
</div>

        <p>
            <span>
                <span class="src">
                    These declarations/deletions can be omitted only if they are obvious:
                </span>
                これらの宣言や削除宣言は、型がどの操作をサポートするか明確であるときに限り省略してもかまいません。
            </span>
        </p>
        <ul>
            <li>
                <span>
                    <span class="src">
                        If the class has no <code>private</code> section, like a
                        <a href="#Structs_vs._Classes">struct</a> or an interface-only base class,
                        then the copyability/movability can be determined by the
                        copyability/movability of any public data members.
                    </span>
                    <a href="#Structs_vs._Classes">構造体</a>やインターフェース基底クラスのような、<code>private</code>セクションを持たないクラスのコピー・ムーブ可能性は、そのクラスの公開データメンバのコピー・ムーブ可能性によって決定できます。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        If a base class clearly isn't copyable or movable, derived classes
                        naturally won't be either.
                    </span>
                    基底クラスが明らかにコピー不可(あるいはムーブ不可)なとき、派生クラスも当然にコピー不可(あるいはムーブ不可)となります。
                </span>
                <span>
                    <span class="src">
                        An interface-only base class that leaves these
                        operations implicit is not sufficient to make concrete subclasses clear.
                    </span>
                    逆に、インターフェースを定義する基底クラスにおいて、それらの操作が暗黙のままにされているときは、その派生クラスにおいて可能な操作の種類が明確であるとは言えません。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        Note that if you explicitly declare or delete either the constructor or
                        assignment operation for copy, the other copy operation is not obvious and
                        must be declared or deleted.
                    </span>
                    なお、コピーコンストラクタやコピー代入演算子のいずれかを明示的に宣言または削除する場合でも、もう一方のコピー操作が自動的に自明となるわけではありませんので、常に、コンストラクタと代入演算子の両方の操作について、宣言または削除するようにしてください。
                </span>
                <span>
                    <span class="src">
                        Likewise for move operations.
                    </span>
                    ムーブ操作についても同様です。
                </span>
            </li>
        </ul>
        <p>
            <span>
                <span class="src">
                    A type should not be copyable/movable if the meaning of
                    copying/moving is unclear to a casual user, or if it incurs unexpected
                    costs.
                </span>
                ある型のコピー・ムーブ操作の意味がカジュアルなユーザーから見て不明瞭であるとき、あるいは、予期しないコストを発生させるときは、その型をコピー可能あるいはムーブ可能にはしないでください。
            </span>
            <span>
                <span class="src">
                    Move operations for copyable types are strictly a performance
                    optimization and are a potential source of bugs and complexity, so
                    avoid defining them unless they are significantly more efficient than
                    the corresponding copy operations.
                </span>
                コピー可能な型における追加のムーブ操作は、厳密に考えるとパフォーマンス上の最適化にあたり、潜在的にバグや複雑さの要因となります。よって、このような型の追加のムーブ操作は、それに対応するコピー操作よりもはるかに効率的に実現できる場合に限って定義し、それ以外の場合には実装しないでください。
            </span>
            <span>
                <span class="src">
                    If your type provides copy operations, it is
                    recommended that you design your class so that the default implementation of
                    those operations is correct.
                </span>
                新しい型でコピー操作を提供する場合は、できるだけ、コンパイラによるデフォルト実装がそのまま正しい実装となるように型を設計するとよいでしょう。
            </span>
            <span>
                <span class="src">
                    Remember to review the correctness of any
                    defaulted operations as you would any other code.
                </span>
                ただし、その場合でも、コンパイラによるデフォルト実装によって正しくコピーあるいはムーブの操作が実現できているのかどうか、他のコードと同じようにレビューするようにしてください。
            </span>
        </p>
        <p>
            <span>
                <span class="src">
                    To eliminate the risk of slicing, prefer to make base classes abstract,
                    by making their constructors protected, by declaring their destructors protected,
                    or by giving them one or more pure virtual member functions.
                </span>
                スライシングのリスクを排除するためには、基底クラスが抽象クラスとなる方が望ましいです。クラスを抽象クラスにするためには、コンストラクタを<code>protected</code>にするか、デストラクタを<code>protected</code>にするか、あるいは、1つ以上の純粋仮想メンバ関数を宣言するとよいでしょう。
            </span>
            <span>
                <span class="src">
                    Prefer to avoid
                    deriving from concrete classes.
                </span>
                具象クラスから、さらなる派生クラスを作るのは、なるべく避けましょう。
            </span>
        </p>

        <h3 id="Structs_vs._Classes">
            <span title="Structs vs. Classes">構造体(<code>struct</code>)か、クラス(<code>class</code>)か</span>
        </h3>

        <p>
            <span>
                <span class="src">
                    Use a <code>struct</code> only for passive objects that
                    carry data; everything else is a <code>class</code>.
                </span>
                <code>struct</code>はデータを運ぶための受動的なオブジェクトにのみ使用し、それ以外のすべての用途では<code>class</code>を使用します。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    The <code>struct</code> and <code>class</code>
                    keywords behave almost identically in C++.
                </span>
                C++において、<code>struct</code>と<code>class</code>はほとんど同じ振る舞いをします。
            </span>
            <span>
                <span class="src">
                    We add our own
                    semantic meanings to each keyword, so you should use the
                    appropriate keyword for the data-type you're
                    defining.
                </span>
                私たちは、それぞれのキーワードに独自の意味づけをしており、定義するデータの種類に応じて適切なキーワードを使い分けています。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    <code>structs</code> should be used for passive objects that carry
                    data, and may have associated constants.
                </span>
                <code>struct</code>はデータを運ぶための受動的なオブジェクトに使用します。関連する定数を含んでもかまいません。
            </span>
            <span>
                <span class="src">
                    All fields must be public.
                </span>
                すべてのフィールドは<code>public</code>でなければなりません。
            </span>
            <span>
                <span class="src">
                    The
                    struct must not have invariants that imply relationships between
                    different fields, since direct user access to those fields may
                    break those invariants.
                </span>
                異なるフィールド間にまたがる暗黙的な不変条件を持ってはいけません。
                これらのフィールドは、ユーザーによって直接アクセスされるため、そのような不変条件は破られてしまうかもしれないためです。
            </span>
            <span>
                <span class="src">
                    Constructors, destructors, and helper methods may
                    be present; however, these methods must not require or enforce any
                    invariants.
                </span>
                コンストラクタやデストラクタ、その他のヘルパーメソッドを定義してもかまいません。
                しかし、それらのメンバ関数においても、何らかの不変条件を要求したり強制したりしてはいけません。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    If more functionality or invariants are required, or struct has wide visibility and expected to
                    evolve, then a <code>class</code> is more appropriate.
                </span>
                それ以上の機能性や不変条件を必要とする場合、あるいは、その構造体が広い範囲から可視であり、今後の拡張が予見される場合には、<code>class</code>を使う方が適切です。
            </span>
            <span>
                <span class="src">
                    If in doubt, make
                    it a <code>class</code>.
                </span>
                迷ったときは<code>class</code>を選びます。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    For consistency with STL, you can use
                    <code>struct</code> instead of <code>class</code> for
                    stateless types, such as traits,
                    <a href="#Template_metaprogramming">template metafunctions</a>,
                    and some functors.
                </span>
                型トレイトや<a href="#Template_metaprogramming">テンプレートメタ関数</a>、関数オブジェクトなどに代表されるような、状態を何も持たない型については、STLとの一貫性を保つ目的で<code>class</code>のかわりに<code>struct</code>を使ってもかまいません。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Note that member variables in structs and classes have
                    <a href="#Variable_Names">different naming rules</a>.
                </span>
                なお、<code>struct</code>と<code>class</code>では、<a href="#Variable_Names">メンバ変数の命名規則が異なります</a>ので、そのことにも注意してください。
            </span>
        </p>

        <h3 id="Structs_vs._Tuples"><span title="Structs vs. Pairs and Tuples">構造体(struct)か、ペア(pair)・タプル(tupple)か</span></h3>
 
        <p>
            <span>
                <span class="src">
                    Prefer to use a <code>struct</code> instead of a pair or a
                    tuple whenever the elements can have meaningful names.
                </span>
                その要素に意味のある名前を付けられるならば、常に、<code>pair</code>や<code>tuple</code>で済ませず、<code>struct</code>を定義して使います。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    While using pairs and tuples can avoid the need to define a custom type,
                    potentially saving work when <em>writing</em> code, a meaningful field
                    name will almost always be much clearer when <em>reading</em> code than
                    <code>.first</code>, <code>.second</code>, or <code>std::get&lt;X&gt;</code>.
                </span>
                ペアやタプルを用いると、型を独自に定義する必要がなくなるため、コードを<em>書く</em>ときに、いくらか楽をすることができるかもしれません。しかし、コードを<em>読む</em>ときのことを考えれば、<code>.first</code>、<code>.second</code>や<code>std::get&lt;X&gt;()</code>よりも、意味のあるフィールド名の方が、ほとんど常に、はるかにわかりやすいはずです。
            </span>

            <span>
                <span class="src">
                    While C++14's introduction of <code>std::get&lt;Type&gt;</code> to access a
                    tuple element by type rather than index (when the type is unique) can
                    sometimes partially mitigate this, a field name is usually substantially
                    clearer and more informative than a type.
                </span>
                タプルの中で型が一意なときは、C++14からの<code>std::get&lt;Type&gt;()</code>を使えば、インデックスではなく型名で要素にアクセスできるため、その状況はいくらか改善するかもしれません。しかし、いずれにせよ、通常は型名よりもフィールド名の方が明確であり、そこに含まれる情報量も多いでしょう。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Pairs and tuples may be appropriate in generic code where there are not
                    specific meanings for the elements of the pair or tuple.
                </span>
                ペアやタプルは、その各要素に特定の意味を定められないような汎用的なコードにおいては適切な場合もあります。
            </span>
            <span>
                <span class="src">
                    Their use may
                    also be required in order to interoperate with existing code or APIs.
                </span>
                あるいは、既存のコードやAPIとの相互運用のためにペアやタプルが必要となることもあるでしょう。
            </span>
        </p>

        <a id="Multiple_Inheritance"></a>
        <h3 id="Inheritance">
            <span title="Inheritance">継承</span>
        </h3>

        <p>
            <span>
                <span class="src">
                    Composition is often more appropriate than inheritance.
                </span>
                しばしば、継承よりも抱合(composition)の方がより適切な場合があります。
            </span>
            <span>
                <span class="src">
                    When using inheritance, make it <code>public</code>.
                </span>
                継承を用いるときは、必ず<code>public</code>にします。
            </span>
        </p>

        <p class="definition"></p>
        <p>
            <span>
                <span class="src">
                    When a sub-class
                    inherits from a base class, it includes the definitions
                    of all the data and operations that the base class
                    defines.
                </span>
                あるクラスが何らかの基底クラスを継承するとき、その派生クラスには基底クラスが定義しているすべてのデータと操作の定義が含まれます。
            </span>
            <span>
                <span class="src">
                    "Interface inheritance" is inheritance from a
                    pure abstract base class (one with no state or defined
                    methods); all other inheritance is "implementation
                    inheritance".
                </span>
                「インターフェースの継承」は、純粋抽象基底クラス(状態やメソッドの定義を持たないクラス)からの継承のことを言い、それ以外の継承はすべて「実装の継承」です。
            </span>
        </p>
        <p class="pros"></p>
        <p>
            <span>
                <span class="src">
                    Implementation inheritance reduces code size by re-using
                    the base class code as it specializes an existing type.
                </span>
                実装の継承においては、既存の型を特殊化する際に、基底クラスのコードを再利用するため、コードのサイズが小さくなります。
            </span>
            <span>
                <span class="src">
                    Because inheritance is a compile-time declaration, you
                    and the compiler can understand the operation and detect
                    errors.
                </span>
                継承はコンパイル時の宣言であるため、プログラマーとコンパイラとによってそれらは理解され、エラーがあれば検出することができます。
            </span>
            <span>
                <span class="src">
                    Interface inheritance can be used to
                    programmatically enforce that a class expose a particular
                    API.
                </span>
                インターフェースの継承において、派生クラスに対して所定のAPIを公開することをプログラム的に強制できます。
            </span>
            <span>
                <span class="src">
                    Again, the compiler can detect errors, in this case,
                    when a class does not define a necessary method of the
                    API.
                </span>
                APIに要求されるメソッドが派生クラスにおいて定義されていないとき、コンパイラはそれをエラーとして検出することができます。
            </span>
        </p>
        <p class="cons"></p>
        <p>
            <span>
                <span class="src">
                    For implementation inheritance, because the code
                    implementing a sub-class is spread between the base and
                    the sub-class, it can be more difficult to understand an
                    implementation.
                </span>
                実装の継承を行うと、派生クラスの実装コードが物理的に基底クラスと派生クラスとの間に分散してしまうため、実装を理解するのがより難しくなるかもしれません。
            </span>
            <span>
                <span class="src">
                    The sub-class cannot override functions
                    that are not virtual, so the sub-class cannot change
                    implementation.
                </span>
                また、派生クラスでは、基底クラスで<code>virtual</code>宣言されたもの以外をオーバーライドすることができないため、派生クラスでそれらの実装を変えることはできません。
            </span>
        </p>
        <p>
            <span>
                <span class="src">
                    Multiple inheritance is especially problematic, because
                    it often imposes a higher performance overhead (in fact,
                    the performance drop from single inheritance to multiple
                    inheritance can often be greater than the performance
                    drop from ordinary to virtual dispatch), and because
                    it risks leading to "diamond" inheritance patterns,
                    which are prone to ambiguity, confusion, and outright bugs.
                </span>
                多重継承は特に問題を引き起こしやすいです。
                多重継承を行うとパフォーマンス上のオーバーヘッドが大きくなります(実際、単一継承から多重継承に変更する際に生ずるパフォーマンス低下は、通常の関数呼び出しを仮想ディスパッチに変更する際のものと比べても大きくなりがちです)。
                また、曖昧で困惑的であからさまなバグを引き起こしがちな、「ダイヤモンド継承」パターンに繋がってしまうリスクもあります。
            </span>
        </p>
        <p class="decision"></p>

        <p>
            <span>
                <span class="src">
                    All inheritance should be <code>public</code>.
                </span>
                すべての継承は<code>public</code>で行います。
            </span>
            <span>
                <span class="src">
                    If you
                    want to do private inheritance, you should be including
                    an instance of the base class as a member instead.
                </span>
                <code>private</code>な継承を行いたいときは、継承するかわりに、基底クラスのインスタンスをメンバとして持つようにしてください。
            </span>
            <span>
                <span class="src">
                    You may use
                    <code>final</code> on classes when you don't intend to support using
                    them as base classes.
                </span>
                基底クラスとして使用されることを想定しないクラスには<code>final</code>をつけてもかまいません。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Do not overuse implementation inheritance.
                </span>
                実装の継承を濫用しないでください。
            </span>
            <span>
                <span class="src">
                    Composition
                    is often more appropriate.
                </span>
                多くの場合において抱合(composition)の方がより適切です。
            </span>
            <span>
                <span class="src">
                    Try to restrict use of
                    inheritance to the "is-a" case: <code>Bar</code>
                    subclasses <code>Foo</code> if it can reasonably be said
                    that <code>Bar</code> "is a kind of"
                    <code>Foo</code>.
                </span>
                継承は「is-a」関係が成立する場合に限って使用するようにしてみてください。
                たとえば<code>Foo</code>を継承して<code>Bar</code>を作ってよいのは、理屈の上で「<code>Bar</code>は<code>Foo</code>の一種」と言えるときだけです。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Limit the use of <code>protected</code> to those
                    member functions that might need to be accessed from
                    subclasses.
                </span>
                <code>protected</code>セクションを用いるのは、派生クラスからのアクセスが必要なメンバ関数だけにとどめてください。
            </span>
            <span>
                <span class="src">
                    Note that <a href="#Access_Control">
                        data
                        members should be <code>private</code>
                    </a>.
                </span>
                なお、<a href="#Access_Control">データメンバはすべて<code>private</code>です</a>。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Explicitly annotate overrides of virtual functions
                    or virtual destructors with exactly one of an <code>override</code>
                    or (less frequently) <code>final</code> specifier.
                </span>
                仮想関数や仮想デストラクタをオーバーライドするときは、<code>override</code>指定子あるいは(それほど頻繁ではありませんが)<code>final</code>指定子のいずれか1つをつけて、オーバーライドしていることを明示してください。
            </span>
            <span>
                <span class="src">
                    Do not use <code>virtual</code> when declaring an override.
                </span>
                オーバーライドを明示する目的で<code>virtual</code>を使ってはいけません。
            </span>
            <span>
                <span class="src">
                    Rationale: A function or destructor marked
                    <code>override</code> or <code>final</code> that is
                    not an override of a base class virtual function will
                    not compile, and this helps catch common errors.
                </span>
                その心は、仮想関数や仮想デストラクタをオーバーライドするとき、それらを<code>override</code>か<code>final</code>でマークしておくと、それらが基底クラスの関数をオーバーライドしなかったときにコンパイルエラーとなるため、その間違いに対処することができるようになるからです。
            </span>
            <span>
                <span class="src">
                    The
                    specifiers serve as documentation; if no specifier is
                    present, the reader has to check all ancestors of the
                    class in question to determine if the function or
                    destructor is virtual or not.
                </span>
                そして、これらの指定子はドキュメントの役割も果たします。これらの指定子が書かれていない場合があると、コードの読者は、それぞれの関数やデストラクタが仮想なのか否かを把握するために、すべての継承元をたどって調べなければならなくなってしまいます。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Multiple inheritance is permitted, but multiple <em>implementation</em>
                    inheritance is strongly discouraged.
                </span>
                多重継承は禁止しませんが、<em>実装の</em>多重継承は、強く非推奨とします。
            </span>
        </p>

        <h3 id="Operator_Overloading">
            <span title="Operator Overloading">演算子のオーバーロード</span>
        </h3>

        <p>
            <span>
                <span class="src">
                    Overload operators judiciously.
                </span>
                演算子のオーバーロードは慎重に。
            </span>
            <span>
                <span class="src">
                    Do not use user-defined literals.
                </span>
                ユーザー定義リテラルは使ってはいけません。
            </span>
        </p>

        <p class="definition"></p>
        <p>
            <span>
                <span class="src">
                    C++ permits user code to
                    <a href="http://en.cppreference.com/w/cpp/language/operators">
                        declare
                        overloaded versions of the built-in operators
                    </a> using the
                    <code>operator</code> keyword, so long as one of the parameters
                    is a user-defined type.
                </span>
                C++では、<code>operator</code>キーワードを使うことで、ユーザー定義の型を引数とした<a href="http://en.cppreference.com/w/cpp/language/operators">組み込み演算子のオーバーロードを宣言する</a>ことができます。
            </span>
            <span>
                <span class="src">
                    The <code>operator</code> keyword also
                    permits user code to define new kinds of literals using
                    <code>operator""</code>, and to define type-conversion functions
                    such as <code>operator bool()</code>.
                </span>
                また、<code>operator""</code>を用いることで新しいリテラルを定義することもできます。この他、<code>operator bool()</code>に代表されるような、型変換を行う関数を定義することもできます。
            </span>
        </p>
        <p class="pros"></p>
        <p>
            <span>
                <span class="src">
                    Operator overloading can make code more concise and
                    intuitive by enabling user-defined types to behave the same
                    as built-in types.
                </span>
                演算子のオーバーロードを用いると、ユーザー定義の型を組み込み型と同様に振る舞わせることができるようになり、コードがより簡潔で直感的になります。
            </span>
            <span>
                <span class="src">
                    Overloaded operators are the idiomatic names
                    for certain operations (e.g., <code>==</code>, <code>&lt;</code>,
                    <code>=</code>, and <code>&lt;&lt;</code>), and adhering to
                    those conventions can make user-defined types more readable
                    and enable them to interoperate with libraries that expect
                    those names.
                </span>
                オーバーロードされた演算子は、所定の操作に対する慣例的な見た目(<code>==</code>, <code>&lt;</code>, <code>=</code>, <code>&lt;&lt;</code>など)をしており、これらの慣例に従うことによって、ユーザー定義の型に対する可読性を向上させ、また、このような演算子の存在を前提とするライブラリとの相互運用性も高めることができます。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    User-defined literals are a very concise notation for
                    creating objects of user-defined types.
                </span>
                ユーザー定義のリテラルは、ユーザー定義のオブジェクトを生成するための非常に簡潔な表記方法です。
            </span>
        </p>
        <p class="cons"></p>
        <ul>
            <li>
                <span>
                    <span class="src">
                        Providing a correct, consistent, and unsurprising
                        set of operator overloads requires some care, and failure
                        to do so can lead to confusion and bugs.
                    </span>
                    正しい、一貫性のある、<em>普通の</em>、演算子のセットを提供するためには、細やかな注意を必要とし、それに失敗すると困惑とバグに繋がります。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Overuse of operators can lead to obfuscated code,
                        particularly if the overloaded operator's semantics
                        don't follow convention.
                    </span>
                    演算子を濫用した場合、特に、演算子にその慣例に従わないような意味を持たせると、コードがわかりにくくなってしまいます。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        The hazards of function overloading apply just as
                        much to operator overloading, if not more so.
                    </span>
                    演算子をオーバーロードする際には、関数をオーバーロードする際と同等の(あるいはそれ以上の)危険性があります。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Operator overloads can fool our intuition into
                        thinking that expensive operations are cheap, built-in
                        operations.
                    </span>
                    オーバーロードされた演算子は、その見た目に反して高コストな処理を、あたかも組み込み演算子が行うような低コストの処理に見せかけてしまうことがあります。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Finding the call sites for overloaded operators may
                        require a search tool that's aware of C++ syntax, rather
                        than e.g., grep.
                    </span>
                    オーバーロードされた演算子の呼び出し元を検索するためには、もはやgrepなどでは用をなさず、C++の文法を理解するツールを使用する必要があります。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        If you get the argument type of an overloaded operator
                        wrong, you may get a different overload rather than a
                        compiler error.
                    </span>
                    もしオーバーロードされた演算子の引数の型を間違えてしまったとき、コンパイルエラーにならず、別のオーバーロード呼び出しに解決されてコンパイルが通ってしまうかもしれません。
                </span>
                <span>
                    <span class="src">
                        For example, <code>foo &lt; bar</code>
                        may do one thing, while <code>&amp;foo &lt; &amp;bar</code>
                        does something totally different.
                    </span>
                    たとえば、<code>foo &lt; bar</code>と<code>&amp;foo &lt; &amp;bar</code>とでは、まったく意味が異なります。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Certain operator overloads are inherently hazardous.
                    </span>
                    演算子によっては、それをオーバーロードすること自体に潜在的な危険性をはらむものがあります。
                </span>
                <span>
                    <span class="src">
                        Overloading unary <code>&amp;</code> can cause the same
                        code to have different meanings depending on whether
                        the overload declaration is visible.
                    </span>
                    単項演算子<code>&amp;</code>のオーバーロードは、呼び出し元からその宣言が見えているか否かで意味が変わってしまいます。
                </span>
                <span>
                    <span class="src">
                        Overloads of
                        <code>&amp;&amp;</code>, <code>||</code>, and <code>,</code>
                        (comma) cannot match the evaluation-order semantics of the
                        built-in operators.
                    </span>
                    また、<code>&amp;&amp;</code>、<code>||</code>、や
                    <code>,</code>(カンマ演算子)をオーバーロードした場合、組み込み演算子で定められている式の評価順序と一致させることはできません。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Operators are often defined outside the class,
                        so there's a risk of different files introducing
                        different definitions of the same operator.
                    </span>
                    演算子はしばしばクラスの外で定義されますが、その場合、同じ演算子に対して別のファイルにある異なる定義を引き込んでしまう危険性があります。
                </span>
                <span>
                    <span class="src">
                        If both
                        definitions are linked into the same binary, this results
                        in undefined behavior, which can manifest as subtle
                        run-time bugs.
                    </span>
                    同じバイナリ内に、実装の異なる両方の演算子がリンクされてしまった場合、未定義動作を引き起こし、非常に微妙な実行時バグとなって現れるかもしれません。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        User-defined literals (UDLs) allow the creation of new
                        syntactic forms that are unfamiliar even to experienced C++
                        programmers, such as <code>"Hello World"sv</code> as a
                        shorthand for <code>std::string_view("Hello World")</code>.
                    </span>
                    ユーザー定義のリテラル(UDL)は、文法的に新しい形式を生み出します。たとえば<code>"Hello World"sv</code>で<code>std::string_view("Hello World")</code>の略記になります。しかし、このような形式は十分に経験を積んだC++プログラマーにとっても馴染みの浅いものです。
                </span>
                <span>
                    <span class="src">
                        Existing notations are clearer, though less terse.
                    </span>
                    この点で、従来からある表記方法は、簡潔でこそありませんが、わかりやすさの面で勝ります。
                </span>
            </li>
            <li>
                <span>
                    <span class="src">
                        Because they can't be namespace-qualified, uses of UDLs also require
                        use of either using-directives (which <a href="#Namespaces">we ban</a>) or
                        using-declarations (which <a href="#Aliases">we ban in header files</a> except
                        when the imported names are part of the interface exposed by the header
                        file in question).
                    </span>
                    UDLは名前空間修飾ができないため、UDLを使うためには、<code>using</code>ディレクティブ(は、<a href="#Namespaces">禁止です</a>)か <code>using</code>宣言(は、<a href="#Aliases">ヘッダーファイルでは一部例外を除いて禁止です</a>)のいずれかを行う必要があります。
                </span>
                <span>
                    <span class="src">
                        Given that header files would have to avoid UDL
                        suffixes, we prefer to avoid having conventions for literals differ
                        between header files and source files.
                    </span>
                    これらのことから、事実上、ヘッダーファイルではUDL接尾辞が使えないことになります。かといって、ヘッダーファイルとソースファイルとの間でリテラルに関するルールが分かれるような事態は好ましくはありません。
                </span>
            </li>
        </ul>

        <p class="decision"></p>
        <p>
            <span>
                <span class="src">
                    Define overloaded operators only if their meaning is
                    obvious, unsurprising, and consistent with the corresponding
                    built-in operators.
                </span>
                演算子のオーバーロードは、コード読者から見て、その意味が明らかであり、動作を予測可能であり、かつ、組み込み演算子との一貫性が保てるときに限って定義してください。
            </span>
            <span>
                <span class="src">
                    For example, use <code>|</code> as a
                    bitwise- or logical-or, not as a shell-style pipe.
                </span>
                たとえば、<code>|</code>演算子は、ビット和か論理和の意味でのみ使い、シェルのパイプのような意味では使ってはいけません。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Define operators only on your own types.
                </span>
                演算子は、自分で定義した型に対するもののみを定義してください。
            </span>
            <span>
                <span class="src">
                    More precisely,
                    define them in the same headers, <code>.cc</code> files, and namespaces
                    as the types they operate on.
                </span>
                より正確には、ある型に演算子は型と同じヘッダーファイルか<code>.cc</code>ファイルの中で、そして型と同じ名前空間の中で定義してください。
            </span>
            <span>
                <span class="src">
                    That way, the operators are available
                    wherever the type is, minimizing the risk of multiple
                    definitions.
                </span>
                そうすることで、型が利用可能なところでは常に演算子も利用可能となり、同一の演算子が多重定義されるリスクを最小限にとどめることができます。
            </span>
            <span>
                <span class="src">
                    If possible, avoid defining operators as templates,
                    because they must satisfy this rule for any possible template
                    arguments.
                </span>
                できれば、演算子をテンプレートとして定義するのは避けてください。
                テンプレートとして宣言された演算子は、取り得る限りすべてのテンプレート引数において、これらのルールを満たしていなければなりません。
            </span>
            <span>
                <span class="src">
                    If you define an operator, also define
                    any related operators that make sense, and make sure they
                    are defined consistently.
                </span>
                ある演算子を定義する場合には、それに関連する演算子も正しく定義し、必ず一貫性を保つようにしてください。
            </span>
            <span>
                <span class="src">
                    For example, if you overload
                    <code>&lt;</code>, overload all the comparison operators,
                    and make sure <code>&lt;</code> and <code>&gt;</code> never
                    return true for the same arguments.
                </span>
                たとえば、<code>&lt;</code>をオーバーロードしたならば、その他のすべての比較演算子もオーバーロードしてください。
                そして、ある引数の組に対する比較演算<code>&lt;</code>と<code>&gt;</code>の結果が両方とも真になるようなことがないようにしてください。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Prefer to define non-modifying binary operators as
                    non-member functions.
                </span>
                引数に対して変更を伴わない二項演算子は、非メンバ関数として定義される方が好ましいです。
            </span>
            <span>
                <span class="src">
                    If a binary operator is defined as a
                    class member, implicit conversions will apply to the
                    right-hand argument, but not the left-hand one.
                </span>
                二項演算子がクラスのメンバとして定義されていると、演算子の右辺については暗黙的型変換が適用されますが、左辺には適用されなくなってしまいます。
            </span>
            <span>
                <span class="src">
                    It will
                    confuse your users if <code>a + b</code> compiles but
                    <code>b + a</code> doesn't.
                </span>
                <code>a + b</code>がコンパイルできて<code>b + a</code>がコンパイルエラーになるような状況は、ユーザーの困惑を招きます。
            </span>
        </p>
        <p>
            <span>
                <span class="src">
                    For a type <code>T</code> whose values can be compared for
                    equality, define a non-member <code>operator==</code> and document when
                    two values of type <code>T</code> are considered equal.
                </span>
                ある型<code>T</code>がその値の等値性を比較できるとき、非メンバの<code>operator==</code>を定義した上で、どういう場合にそれらが等値と見なされるのかについて文書化してください。
            </span>
            <span>
                <span class="src">
                    If there is a single obvious notion of when a value <code>t1</code>
                    of type <code>T</code> is less than another such value <code>t2</code> then
                    you may also define <code>operator&lt;=&gt;</code>, which should be
                    consistent with <code>operator==</code>.
                </span>
                また、型<code>T</code>の値<code>t1</code>と別の値<code>t2</code>を大小比較するための、唯一で、かつ明らかな概念が存在するならば、<code>operator&lt;=&gt;</code>を定義してもかまいません。
                その際、<code>operator==</code>との一貫性は保つようにしてください。
            </span>
            <span>
                <span class="src">
                    Prefer not to overload the other comparison and ordering operators.
                </span>
                これ以外の比較演算子はオーバーロードしない方がよよいでしょう。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Don't go out of your way to avoid defining operator
                    overloads.
                </span>
                演算子のオーバーロードをわざわざ避けるようなことはしないでください。
            </span>
            <span>
                <span class="src">
                    For example, prefer to define <code>==</code>,
                    <code>=</code>, and <code>&lt;&lt;</code>, rather than
                    <code>Equals()</code>, <code>CopyFrom()</code>, and
                    <code>PrintTo()</code>.
                </span>
                <code>Equals()</code>や<code>CopyFrom()</code>、<code>PrintTo()</code>などを用意するよりも、<code>==</code>、<code>=</code>、<code>&lt;&lt;</code>を定義する方が好ましいです。
            </span>
            <span>
                <span class="src">
                    Conversely, don't define
                    operator overloads just because other libraries expect
                    them.
                </span>
                反対に、他のライブラリを使いたいがためだけに演算子をオーバーロードすることは避けてください。
            </span>
            <span>
                <span class="src">
                    For example, if your type doesn't have a natural
                    ordering, but you want to store it in a <code>std::set</code>,
                    use a custom comparator rather than overloading
                    <code>&lt;</code>.
                </span>
                たとえば、値の大小比較関係を自然に定義できない型のオブジェクトを<code>std::set</code>に入れたいときは、独自の比較子(comparator)を使うようにします。比較演算子<code>&lt;</code>をオーバーロードしてはいけません。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Do not overload <code>&amp;&amp;</code>, <code>||</code>,
                    <code>,</code> (comma), or unary <code>&amp;</code>.
                </span>
                演算子<code>&amp;&amp;</code>と<code>||</code>と<code>,</code>
                (カンマ演算子)、単項演算子<code>&amp;</code>はオーバーロードをしてはいけません。
            </span>
            <span>
                <span class="src">
                    Do not overload
                    <code>operator""</code>, i.e., do not introduce user-defined
                    literals.
                </span>
                また、<code>operator""</code>もオーバーロードしてはいけません。すなわち、ユーザー定義リテラルを導入してはなりません。
            </span>
            <span>
                <span class="src">
                    Do not use any such literals provided by others
                    (including the standard library).
                </span>
                そして、標準ライブラリも含めて、他者から提供されるいかなるリテラル演算子も使用してはなりません。
            </span>
        </p>

        <p>
            <span>
                <span class="src">
                    Type conversion operators are covered in the section on
                    <a href="#Implicit_Conversions">implicit conversions</a>.
                </span>
                型変換演算子については<a href="#Implicit_Conversions">暗黙的型変換</a>のセクションでカバーします。
            </span>
            <span>
                <span class="src">
                    The <code>=</code> operator is covered in the section on
                    <a href="#Copy_Constructors">copy constructors</a>.
                </span>
                代入演算子<code>=</code>は<a href="#Copy_Constructors">コピーコンストラクタ</a>のセクションでカバーします。
            </span>
            <span>
                <span class="src">
                    Overloading
                    <code>&lt;&lt;</code> for use with streams is covered in the
                    section on <a href="#Streams">streams</a>.
                </span>
                ストリーム用途での演算子<code>&lt;&lt;</code>のオーバーロードについては、<a href="#Streams">ストリーム</a>のセクションでカバーします。
            </span>
            <span>
                <span class="src">
                    See also the rules on
                    <a href="#Function_Overloading">function overloading</a>, which
                    apply to operator overloading as well.
                </span>
                また、すべての演算子のオーバーロードは<a href="#Function_Overloading">関数のオーバーロード</a>にあるルールも同様に適用されますので、あわせて参照してください。
            </span>
        </p>


    <h3 id="Access_Control">
        <span title="Access Control">アクセス制限</span>
    </h3>

    <p>
        <span>
            <span class="src">
                Make classes' data members <code>private</code>, unless they are
                <a href="#Constant_Names">constants</a>.
            </span>
            クラスのデータメンバは、<a href="#Constant_Names">定数</a>を除いて、すべて<code>private</code>にします。
        </span>
        <span>
            <span class="src">
                This simplifies reasoning about invariants, at the cost
                of some easy boilerplate in the form of accessors (usually <code>const</code>) if necessary.
            </span>
            このルールは、必要に応じて定型文的なgetter関数(通常は<code>const</code>)の実装を要しますが、それを差し引いても、クラスの不変条件に関する議論をシンプルにできるメリットがあります。
        </span>
    </p>
    <p>
        <span>
            <span class="src">
                For technical
                reasons, we allow data members of a test fixture class defined in a <code>.cc</code> file to
                be <code>protected</code> when using
                <a href="https://github.com/google/googletest">
                    Google
                    Test
                </a>.
            </span>
            技術的な理由により、<a href="https://github.com/google/googletest">Google Test</a>を使う場合は、
            テストフィクスチャクラスが<code>.cc</code>ファイル内で定義される場合に限り、そのデータメンバは<code>protected</code>であってもよいものとします。
        </span>
        <span>
            <span class="src">
                If a test fixture class is defined outside of the <code>.cc</code> file it is used in, for example in a <code>.h</code> file,
                make data members <code>private</code>.
            </span>
            テストフィクスチャクラスが、そのクラスを利用する<code>.cc</code>ファイルの外(たとえば<code>.h</code>ファイル内)で定義される場合は、データメンバは<code>private</code>でなければなりません。
        </span>
    </p>
    <h3 id="Declaration_Order">
        <span title="Declaration Order">宣言の順序</span>
    </h3>

    <p>
        <span>
            <span class="src">
                Group similar declarations together, placing <code>public</code> parts
                earlier.
            </span>
            似た宣言はグループにまとめ、<code>public</code>部分を先頭におきます。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                A class definition should usually start with a
                <code>public:</code> section, followed by
                <code>protected:</code>, then <code>private:</code>.
            </span>
            クラスの定義は、通常は<code>public:</code>セクションから始め、<code>protected:</code>、<code>private:</code>と続けます。
        </span>
        <span>
            <span class="src">
                Omit
                sections that would be empty.
            </span>
            空になるセクションは省略してください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Within each section, prefer grouping similar
                kinds of declarations together, and prefer the
                following order:
            </span>
            各セクションにおいて、似た種類の宣言はまとめるようにし、以下の順に並べるようにします。
        </span>
    </p>
    <ol>
        <li>
            <span>
                <span class="src">
                    Types and type aliases (<code>typedef</code>, <code>using</code>,
                    <code>enum</code>, nested structs and classes, and <code>friend</code> types)
                </span>
                型、型エイリアス(<code>typedef</code>, <code>using</code>,
                <code>enum</code>, ネストされた構造体やクラス, <code>friend</code>型)
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    (Optionally, for structs only) non-<code>static</code> data members
                </span>
                (構造体に限り、必要に応じて)非<code>static</code>データメンバ
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Static constants
                </span>
                静的定数
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Factory functions
                </span>
                ファクトリ関数
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Constructors and assignment operators
                </span>
                コンストラクタと代入演算子
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Destructor
                </span>
                デストラクタ
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    All other functions (<code>static</code> and non-<code>static</code> member
                    functions, and <code>friend</code> functions)
                </span>
                その他のすべての関数 (<code>static</code> と非<code>static</code> メンバ関数、<code>friend</code>関数)
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    All other data members (static and non-static)
                </span>
                上記以外の(静的/非静的)データメンバ
            </span>
        </li>
    </ol>

    <p>
        <span>
            <span class="src">
                Do not put large method definitions inline in the
                class definition.
            </span>
            クラス定義の中では、大きなメソッドの定義をインラインに行わないでください。
        </span>
        <span>
            <span class="src">
                Usually, only trivial or
                performance-critical, and very short, methods may be
                defined inline.
            </span>
            通常は、些細であるか、または、パフォーマンスが重要な、非常に短い関数のみをインラインで定義します。
        </span>
        <span>
            <span class="src">
                See <a href="#Inline_Functions">
                    Inline
                    Functions
                </a> for more details.
            </span>
            より詳細は<a href="#Inline_Functions">インライン関数</a>で述べます。
        </span>
    </p>

    <h2 id="Functions">
        <span title="Functions">関数</span>
    </h2>

    <a id="Function_Parameter_Ordering"></a>
    <a id="Output_Parameters"></a>
    <h3 id="Inputs_and_Outputs">
        <span title="Inputs and Outputs">入力と出力</span>
    </h3>

    <p>
        <span>
            <span class="src">
                The output of a C++ function is naturally provided via
                a return value and sometimes via output parameters (or in/out parameters).
            </span>
            C++関数の出力は、通常は戻り値経由で提供されますが、しばしば出力用(もしくは入出力用)の引数も使われます。
        </span>

    </p>

    <p>
        <span>
            <span class="src">
                Prefer using return values over output parameters: they
                improve readability, and often provide the same or better
                performance.
            </span>
            出力用引数よりは戻り値を使います。
            可読性が向上し、パフォーマンスも同等以上に得られます。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Prefer to return by value or, failing that, return by reference.
            </span>
            戻り値はできるだけ値返しで返し、何らかの事情によりそれができないときは参照返しにします。
        </span>
        <span>
            <span class="src">
                Avoid returning a pointer unless it can be null.
            </span>
            ポインタ返しは、戻り値としてnullを取りうる場合のみ使い、それ以外の場合は避けてください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Parameters are either inputs to the function, outputs from the
                function, or both.
            </span>
            関数における引数は、関数への入力用、関数からの出力用、あるいはそれらの両方を行う入出力用のいずれかに分類されます。
        </span>
        <span>
            <span class="src">
                Non-optional input parameters should usually be values
                or <code>const</code> references, while non-optional output and
                input/output parameters should usually be references (which cannot be null).
            </span>
            関数に渡す入力用引数のうち、入力必須とするものは通常は値渡しか<code>const</code>参照渡しで宣言します。出力用および入出力用引数で必須のものは、通常は非<code>const</code>参照渡し(nullを不可とするため)で宣言します。
        </span>
        <span>
            <span class="src">
                Generally, use <code>std::optional</code> to represent optional by-value
                inputs, and use a <code>const</code> pointer when the non-optional form would
                have used a reference.
            </span>
            入力用引数のうち、入力を必須としないものについては、<code>std::optional</code>で包んで値渡しするか、(参照渡しをしたいのであれば)<code>const</code>ポインタを使います。
        </span>
        <span>
            <span class="src">
                Use non-<code>const</code> pointers to represent
                optional outputs and optional input/output parameters.
            </span>
            出力用および入出力用引数のうち、必須としないものには非<code>const</code>ポインタを使います。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Avoid defining functions that require a <code>const</code> reference parameter
                to outlive the call, because <code>const</code> reference parameters bind
                to temporaries.
            </span>
            <code>const</code>参照引数は一時オブジェクトを束縛することもできるため、関数の定義において、関数呼び出しから戻った後にも渡された<code>const</code>参照引数の参照先が存続していることを期待してはいけません。
        </span>

        <span>
            <span class="src">
                Instead, find a way to eliminate the lifetime requirement
                (for example, by copying the parameter), or pass it by <code>const</code>
                pointer and document the lifetime and non-null requirements.
            </span>
            かわりに、寿命が存続していなくてもよいように実装する(例えば内部で引数をコピーしておく等)か、もしくは、その引数を<code>const</code>ポインタ渡しとして、寿命と非null性に関する要件をドキュメントに残すようにしてください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                When ordering function parameters, put all input-only
                parameters before any output parameters.
            </span>
            関数引数の順番を決めるときは、すべての入力専用引数を、いかなる出力用引数よりも先に配置してください。
        </span>

        <span>
            <span class="src">
                In particular,
                do not add new parameters to the end of the function just
                because they are new; place new input-only parameters before
                the output parameters.
            </span>
            特に、関数に後から新しい引数を追加するときであっても、新しく追加するからという理由だけで最後に追加することは避けてください。
            つまり、入力専用引数が新しくても、出力引数よりは前に並べてください。
        </span>

        <span>
            <span class="src">
                This is not a hard-and-fast rule.
            </span>
            とはいえ、これは絶対厳守のルールというわけでもありません。
        </span>

        <span>
            <span class="src">
                Parameters that
                are both input and output muddy the waters, and, as always,
                consistency with related functions may require you to bend the rule.
            </span>
            入力と出力の両方の役割を持つ引数は、明確な線引きが難しいものもあります。
            また、関連する関数との一貫性を保つためにはこのルールを曲げる必要があるかもしれません。
        </span>

        <span>
            <span class="src">
                Variadic functions may also require unusual parameter ordering.
            </span>
            これに加えて、可変長引数関数においても、通常とは異なる引数順序で並べる必要があるでしょう。
        </span>

    </p>

    <h3 id="Write_Short_Functions">
        <span title="Write Short Functions">関数は短く</span>
    </h3>

    <p>
        <span>
            <span class="src">
                Prefer small and focused functions.
            </span>
            関数は、短く、焦点を絞ったものにしましょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                We recognize that long functions are sometimes
                appropriate, so no hard limit is placed on functions
                length.
            </span>
            時には、長い関数であってもそれが適切なこともありますので、関数の長さに関する固定の限界値は定めません。
        </span>
        <span>
            <span class="src">
                If a function exceeds about 40 lines, think about
                whether it can be broken up without harming the structure
                of the program.
            </span>
            だいたい40行程度を超えるようであれば、プログラムの構造を害さずに、関数を分割することができないか考えてみてください。
        </span>
    </p>

    <p>
        <span>
            <span class="src"><!-- -->
                Even if your long function works perfectly now,
                someone modifying it in a few months may add new
                behavior.
            </span>
            長めの関数が現時点では完璧に動いていたとしても、数ヶ月後に誰かがそれを変更し、新しい動作を足すかもしれませんし、
        </span>
        <span>
            <span class="src">
                This could result in bugs that are hard to
                find.
            </span>
            その結果として、見つけるのが困難なバグに繋がるかもしれません。
        </span>
        <span>
            <span class="src">
                Keeping your functions short and simple makes it
                easier for other people to read and modify your code.
            </span>
            関数を短くシンプルに保っておけば、コードはより読みやすく、より変更しやすくなります。
        </span>
        <span>
            <span class="src">
                Small functions are also easier to test.
            </span>
            また、関数が小さければ、その分テストも容易になるでしょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                You could find long and complicated functions when
                working with
                some code.
            </span>
            作業をしていると、長く複雑なコードに出くわすこともあるでしょう。
        </span>
        <span>
            <span class="src">
                Do not be
                intimidated by modifying existing code: if working with
                such a function proves to be difficult, you find that
                errors are hard to debug, or you want to use a piece of
                it in several different contexts, consider breaking up
                the function into smaller and more manageable pieces.
            </span>
            既存のコードを変更することにおびえてはいけません。
            そのコードを取り扱うのが困難であると思ったとき、エラーをデバッグすることが困難であると思ったとき、あるいは関数の一部分だけを切り出して別のところで使いたいと思ったとき、その関数をより小さく扱いやすい複数の断片に分割できないか検討してみましょう。
        </span>
    </p>

    <h3 id="Function_Overloading">
        <span title="Function Overloading">関数のオーバーロード</span>
    </h3>

    <!-- -->
    <p>
        <span>
            <span class="src">
                Use overloaded functions (including constructors) only if a
                reader looking at a call site can get a good idea of what
                is happening without having to first figure out exactly
                which overload is being called.
            </span>
            コンストラクタを含め、関数オーバーロードするときは、コードの読者が呼び出し元のコードを読んだときに、どの実装が呼び出されるのか正確に把握せずとも、何が行われるのかは予想できるようにしてください。
        </span>
    </p>

    <p class="definition"></p>
    <p>
        <span>
            <span class="src">
                You may write a function that takes a <code>
                                    const
                                    std::string&amp;
                                </code> and overload it with another that
                takes <code>const char*</code>.
            </span>
            たとえば、<code>const std::string&amp;</code>を引数にとる関数と<code>const char*</code>を引数にとる関数とを書くことができます。
        </span>
        <span>
            <span class="src">
                However, in this case consider
                <code>std::string_view</code>
                instead.
            </span>
            (もっとも、このケースでは、かわりに<code>std::string_view</code>の採用を検討した方がよいですが……)
        </span>
    </p>

    <pre>class MyClass {
 public:
  void Analyze(const std::string &amp;text);
  void Analyze(const char *text, size_t textlen);
};
</pre>

    <p class="pros"></p>
    <p>
        <span>
            <span class="src">
                Overloading can make code more intuitive by allowing an
                identically-named function to take different arguments.
            </span>
            関数のオーバーロードを用いると、同じ関数名で引数の異なる関数を定義することができるため、これによってコードをより直感的にすることができます。
        </span>
        <span>
            <span class="src">
                It may be necessary for templatized code, and it can be
                convenient for Visitors.
            </span>
            この機能は、コードをテンプレート化するときに必要となったり、ビジターパターンを実装するときに役立ったりします。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Overloading based on <code>const</code> or ref qualification may make utility
                code more usable, more efficient, or both.
                (See <a href="http://abseil.io/tips/148">TotW 148</a> for more.)
            </span>
            メンバ関数における<code>const</code>修飾子や参照修飾子によるオーバーロードは、ユーティリティコードをより有用にしたり効率的にしたり、またその両方の恩恵をもたらします。
            (詳しくは <a href="http://abseil.io/tips/148">TotW 148</a> を見てください)
        </span>

    </p>
    <p class="cons"></p>
    <p>
        <span>
            <span class="src">
                If a function is overloaded by the argument types alone,
                a reader may have to understand C++'s complex matching
                rules in order to tell what's going on.
            </span>
            関数が引数の型だけでオーバーロードされているとき、コードの読者は、C++の複雑なマッチングルールについて理解していないと、何が起こるのかわからないかもしれません。
        </span>
        <span>
            <span class="src">
                Also many people
                are confused by the semantics of inheritance if a derived
                class overrides only some of the variants of a
                function.
            </span>
            また、複数のオーバーロードを持つ仮想関数を、派生先のクラスで部分的にオーバーライドした場合の挙動は、多くの人を困惑させています。
        </span>
    </p>
    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                You may overload a function when there are no semantic differences
                between variants.
            </span>
            オーバーロード同士の間で互いに意味上の違いがないときに限り、関数をオーバーロードしてもかまいません。
        </span>
        <span>
            <span class="src">
                These overloads may vary in types, qualifiers, or
                argument count.
            </span>
            これらのオーバーロードには、型が異なったり、修飾子が異なったり、引数の数が異なったりと、様々なものを含むことができます。
        </span>
        <span>
            <span class="src">
                However, a reader of such a call must not need to know
                which member of the overload set is chosen, only that <b>something</b>
                from the set is being called.
            </span>
            ただし、それらを呼び出す側のコードの読者には、具体的にどのオーバーロードが選ばれるのかまで追わせることのないようにしてください。つまり、それらの関数セットの中の<b>いずれか</b>が呼ばれるというところまでの理解で、コードを読めるようにしておいてください。
        </span>
        <span>
            <span class="src">
                If you can document all entries in the
                overload set with a single comment in the header, that is a good sign
                that it is a well-designed overload set.
            </span>
            あるオーバーロードのセットについてヘッダーファイルでコメントを書くとき、すべてのオーバーロードについてまとめて1つのコメントで賄えることが理想です。それができれば、関数オーバーロードをうまくデザインできている証です。
        </span>
    </p>

    <h3 id="Default_Arguments">
        <span title="Default Arguments">デフォルト引数</span>
    </h3>

    <p>
        <span>
            <span class="src">
                Default arguments are allowed on non-virtual functions
                when the default is guaranteed to always have the same
                value.
            </span>
            関数が仮想関数ではなく、かつ、常にデフォルト値が同じ値になることを保証する場合に限って、関数引数にデフォルト値を与えてもかまいません。
        </span>
        <span>
            <span class="src">
                Follow the same restrictions as for <a href="#Function_Overloading">function overloading</a>, and
                prefer overloaded functions if the readability gained with
                default arguments doesn't outweigh the downsides below.
            </span>
            <a href="#Function_Overloading">関数のオーバーロード</a>と同様の制限に従ってください。
            また、引数のデフォルト値を与えることによって得られる可読性よりも、後述するデメリットの方が勝るような場合は、かわりに関数のオーバーロードを使いましょう。
        </span>
    </p>

    <p class="pros"></p>
    <p>
        <span>
            <span class="src">
                Often you have a function that uses default values, but
                occasionally you want to override the defaults.
            </span>
            普段はデフォルトの値のまま使っている関数でも、時々別の値に変えて呼び出したいことがあります。
        </span>
        <span>
            <span class="src">
                Default
                parameters allow an easy way to do this without having to
                define many functions for the rare exceptions.
            </span>
            引数にデフォルト値を与えることによって、このような"時々"のための関数をたくさん定義することなく、簡単にやりたいことを実現できます。
        </span>
        <span>
            <span class="src">
                Compared
                to overloading the function, default arguments have a
                cleaner syntax, with less boilerplate and a clearer
                distinction between 'required' and 'optional'
                arguments.
            </span>
            関数のオーバーロードに比べて、このやり方は、文法的にきれいで、定型文も少なく済み、さらに、その引数が必須なのか任意なのか、より明確に区別することができます。
        </span>
    </p>
    <p class="cons"></p>
    <p>
        <span>
            <span class="src">
                Defaulted arguments are another way to achieve the
                semantics of overloaded functions, so all the <a href="#Function_Overloading">
                    reasons not to overload
                    functions
                </a> apply.
            </span>
            引数のデフォルト値を与える手法は、意味的には関数のオーバーロードの代替手段であるため、すべての<a href="#Function_Overloading">関数をオーバーロードしない理由</a>も適用されます。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                The defaults for arguments in a virtual function call are
                determined by the static type of the target object, and
                there's no guarantee that all overrides of a given function
                declare the same defaults.
            </span>
            仮想関数呼び出し時の引数のデフォルト値は、ターゲットとするオブジェクトの静的な型に基づいて決定されますが、すべての派生先でのオーバーライドにおいて同じ値が宣言されている保証がありません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Default parameters are re-evaluated at each call site,
                which can bloat the generated code.
            </span>
            引数のデフォルト値は、すべての呼び出し元で再評価されます。このため、生成されるコードのサイズが予想以上にふくれあがることがあります。
        </span>
        <span>
            <span class="src">
                Readers may also expect
                the default's value to be fixed at the declaration instead
                of varying at each call.
            </span>
            また、コードの読者も、関数の呼び出しごとにデフォルト値が変わるのではなく、宣言時点で決まった値に固定されていると考えるかもしれません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Function pointers are confusing in the presence of
                default arguments, since the function signature often
                doesn't match the call signature.
            </span>
            関数ポインタを引数のデフォルト値として与えると、その記述の仕方に困惑するかもしれません。関数のシグネチャはしばしば、呼び出し時のシグネチャと一致しないことがあるからです。
        </span>
        <span>
            <span class="src">
                Adding
                function overloads avoids these problems.
            </span>
            関数のオーバーロードであれば、これらの問題は回避することができます。
        </span>
    </p>
    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                Default arguments are banned on virtual functions, where
                they don't work properly, and in cases where the specified
                default might not evaluate to the same value depending on
                when it was evaluated.
            </span>
            仮想関数に対する引数のデフォルト値は、意図に反する動作をすることがあるため、全面禁止とします。また、評価されるタイミング次第で異なる値になりうる引数のデフォルト値も禁止します。
        </span>
        <span>
            <span class="src">
                (For example, don't write <code>
                                    void
                                    f(int n = counter++);
                                </code>.)
            </span>
            (たとえば、<code>void f(int n = counter++);</code>のようなコードは書いてはいけません。)
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                In some other cases, default arguments can improve the
                readability of their function declarations enough to
                overcome the downsides above, so they are allowed.
            </span>
            それら以外のケースにおいて、デフォルト値を与えることで、そのデメリットを差し引いても関数宣言の可読性を高められるという場合は、関数引数にデフォルト値を与えてもかまいません。
        </span>
        <span>
            <span class="src">
                When in
                doubt, use overloads.
            </span>
            迷ったときには、関数のオーバーロードを選択してください。
        </span>
    </p>

    <h3 id="trailing_return">
        <span title="Trailing Return Type Syntax">戻り値の型を後置する関数宣言構文</span>
    </h3>

    <p>
        <span>
            <span class="src">
                Use trailing return types only where using the ordinary syntax (leading
                return types) is impractical or much less readable.
            </span>
            戻り値の型を後置する関数宣言の構文は、従来からある通常の関数宣言構文(戻り値の型に始まる構文)を使うのが非現実的であったり、あるいは、その構文では可読性が非常に劣ってしまうという場合に限定して用います。
        </span>
    </p>
    <p class="definition"></p>
    <p>
        <span>
            <span class="src">
                C++ allows two different forms of function declarations.
            </span>
            C++の関数宣言には、2種類の異なる構文が存在します。
        </span>
        <span>
            <span class="src">
                In the older
                form, the return type appears before the function name.
                For example:
            </span>
            従来からある構文では、次のように、戻り値の型を関数名に先駆けて記述します。
        </span>
    </p>
    <pre>int foo(int x);
</pre>
    <p>
        <span>
            <span class="src">
                The newer form uses the <code>auto</code>
                keyword before the function name and a trailing return type after
                the argument list.
            </span>
            新しい形の構文では、まず<code>auto</code>キーワードを関数名の前に置き、引数リストの後に戻り値の型を書きます。
        </span>
        <span>
            <span class="src">
                For example, the declaration above could
                equivalently be written:
            </span>
            例として、先ほどの宣言と等価な宣言は次のように書けます。
        </span>
    </p>
    <pre>auto foo(int x) -&gt; int;
</pre>
    <p>
        <span>
            <span class="src">
                The trailing return type is in the function's scope.
            </span>
            後置される戻り値の型は関数内スコープになります。
        </span>
        <span>
            <span class="src">
                This doesn't
                make a difference for a simple case like <code>int</code> but it matters
                for more complicated cases, like types declared in class scope or
                types written in terms of the function parameters.
            </span>
            <code>int</code>のような単純なケースではこれらの間に違いはありませんが、型が複雑になる場合、たとえば、型がクラススコープで宣言されている場合や、型が関数の引数リスト内の語によって表現される場合は、この違いが重要になってきます。
        </span>
    </p>

    <p class="pros"></p>
    <p>
        <span>
            <span class="src">
                Trailing return types are the only way to explicitly specify the
                return type of a <a href="#Lambda_expressions">lambda expression</a>.
            </span>
            戻り値の型を後置する構文は、<a href="#Lambda_expressions">ラムダ式</a>の戻り値の型を明示できる唯一の方法です。
        </span>
        <span>
            <span class="src">
                In some cases the compiler is able to deduce a lambda's return type,
                but not in all cases.
            </span>
            コンパイラにラムダ式の戻り値の型を推論させられる場合もありますが、常にそれができるというわけではありません。
        </span>
        <span>
            <span class="src">
                Even when the compiler can deduce it automatically,
                sometimes specifying it explicitly would be clearer for readers.
            </span>
            あるいは、コンパイラによって自動的に型が推論できる場合であっても、型を明示的に記述することで、コードの可読性を向上させられる場合もあります。
        </span>
    </p>
    <p>
        <span>
            <span class="src">
                Sometimes it's easier and more readable to specify a return type
                after the function's parameter list has already appeared.
            </span>
            戻り値の型を引数リストの後に置くことで、コードがより簡単になり、可読性が高まることがあります。
        </span>
        <span>
            <span class="src">
                This is
                particularly true when the return type depends on template parameters.
            </span>
            特に、戻り値の型がテンプレートパラメータによって決まる場合、このことはよくあてはまります。
        </span>
        <span>
            <span class="src">
                For example:
            </span>
            次に例を示します。
        </span>
    </p>
    <div>
        <pre>    template &lt;typename T, typename U&gt;
    auto add(T t, U u) -&gt; decltype(t + u);
</pre>
        <span>
            <span class="src">
                versus
            </span>
            上に比べて、次のコードはどうでしょうか。
        </span>
        <pre>    template &lt;typename T, typename U&gt;
    decltype(declval&lt;T&amp;&gt;() + declval&lt;U&amp;&gt;()) add(T t, U u);
</pre>
    </div>
    <p class="cons"></p>
    <p>
        <span>
            <span class="src">
                Trailing return type syntax is relatively new and it has no
                analogue in C++-like languages such as C and Java, so some readers may
                find it unfamiliar.
            </span>
            戻り値の型を後置する関数宣言構文は、比較的新しく、C言語やJavaなどの他のC++系言語を見ても類似の構文がありません。このため、コードの読者にとって馴染みが薄いかもしれません。
        </span>
    </p>
    <p>
        <span>
            <span class="src">
                Existing code bases have an enormous number of function
                declarations that aren't going to get changed to use the new syntax,
                so the realistic choices are using the old syntax only or using a mixture
                of the two.
            </span>
            既存のコードベースには既に膨大な数の関数宣言がありますが、それらが新しい構文に置き換わるということは、おそらく今後もないでしょう。
            このため、現実的な選択肢は、古い構文だけを使い続けるのか、新旧両方の構文を混ぜて使っていくかのどちらかです。
        </span>
        <span>
            <span class="src">
                Using a single version is better for uniformity of style.
            </span>
            そして、スタイルの一様性を保つためには、1種類だけを使うことが好ましいです。
        </span>
    </p>
    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                In most cases, continue to use the older style of function
                declaration where the return type goes before the function name.
            </span>
            ほとんどの場合において、従来ながらの、戻り値の型を関数名に先駆けて書く構文を使い続けてください。
        </span>
        <span>
            <span class="src">
                Use the new trailing-return-type form only in cases where it's
                required (such as lambdas) or where, by putting the type after the
                function's parameter list, it allows you to write the type in a much
                more readable way.
            </span>
            新しい、戻り値の型を後置する関数宣言構文は、ラムダ式などにおいてその構文を必須とする場合や、あるいは、引数リストの後に戻り値の型を置くことによって型が大幅に読みやすくなる場合に限って使用を認めます。
        </span>
        <span>
            <span class="src">
                The latter case should be rare; it's mostly an
                issue in fairly complicated template code, which is
                <a href="#Template_metaprogramming">discouraged in most cases</a>.
            </span>
            とはいえ、後者の状況はレアケースでしょう。それらのほとんどは、テンプレートコードが複雑すぎることに起因しており、そして、ほとんどの場合において<a href="#Template_metaprogramming">複雑なテンプレートは非推奨</a>です。
        </span>
    </p>

    <h2 id="Google-Specific_Magic">
        <span title="Google-Specific Magic">Google特有のマジック</span>
    </h2>

    <p>
        <span>
            <span class="src">
                There are various tricks and utilities that
                we use to make C++ code more robust, and various ways we use
                C++ that may differ from what you see elsewhere.
            </span>
            Googleでは、C++のコードをより堅牢にするために、様々なトリックやユーティリティを使っています。
            これらの手法の中には、一般的なC++の使い方とは異なる部分があるかもしれません。
        </span>
    </p>

    <h3 id="Ownership_and_Smart_Pointers">
        <span title="Ownership and Smart Pointers">オブジェクトの所有権とスマートポインタ</span>
    </h3>

    <p>
        <span>
            <span class="src">
                Prefer to have single, fixed owners for dynamically
                allocated objects.
            </span>
            動的に確保されるオブジェクトは、単一の固定された所有者に属するようにします。
        </span>
        <span>
            <span class="src">
                Prefer to transfer ownership with smart
                pointers.
            </span>
            オブジェクトの所有権を移すときには、スマートポインタを使ってそれを表現します。
        </span>
    </p>

    <p class="definition"></p>
    <p>
        <span>
            <span class="src">
                "Ownership" is a bookkeeping technique for managing
                dynamically allocated memory (and other resources).
            </span>
            「所有権」とは、動的に確保されるメモリ(や、その他のリソース)を管理するための帳簿的なテクニックの一つです。
        </span>
        <span>
            <span class="src">
                The
                owner of a dynamically allocated object is an object or
                function that is responsible for ensuring that it is
                deleted when no longer needed.
            </span>
            動的に確保されるオブジェクトは、1つのオブジェクトもしくは1つの関数に<em>所有</em>され、その所有者であるオブジェクトや関数は、確保したオブジェクトが不要になったとき、確実にそれを解放する責任を負います。
        </span>
        <span>
            <span class="src">
                Ownership can sometimes be
                shared, in which case the last owner is typically
                responsible for deleting it.
            </span>
            所有権は複数の所有者の間で共有されることもあり、この場合には、最後の所有者が解放の責任を負うのが典型的です。
        </span>
        <span>
            <span class="src">
                Even when ownership is not
                shared, it can be transferred from one piece of code to
                another.
            </span>
            あるいは、所有権を共有せずとも、あるコードから他のコードへと、オブジェクトの所有権が移されることもあります。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                "Smart" pointers are classes that act like pointers,
                e.g., by overloading the <code>*</code> and
                <code>-&gt;</code> operators.
            </span>
            「スマート」ポインタとは、ポインタのように振る舞うクラスで、たとえば、演算子<code>*</code>と<code>-&gt;</code>をオーバーロードしています。
        </span>
        <span>
            <span class="src">
                Some smart pointer types
                can be used to automate ownership bookkeeping, to ensure
                these responsibilities are met.
            </span>
            スマートポインタの中には、所有権管理を自動的に行い、解放責任を確実に果たすために使えるものがあります。
        </span>
        <span>
            <span class="src">
                <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">
                    <code>std::unique_ptr</code>
                </a> is a smart pointer type
                introduced in C++11, which expresses exclusive ownership
                of a dynamically allocated object; the object is deleted
                when the <code>std::unique_ptr</code> goes out of scope.
            </span>
            <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr"><code>std::unique_ptr</code></a>は、C++11で導入されたスマートポインタのひとつで、動的確保されるオブジェクトに対して排他的な所有権を持つことを表現するために使われます。
            <code>std::unique_ptr</code>によって所有されるオブジェクトは、<code>std::unique_ptr</code>がスコープ外となったときに自動的に解放されます。
        </span>
        <span>
            <span class="src">
                It cannot be copied, but can be <em>moved</em> to
                represent ownership transfer.
            </span>
            <code>std::unique_ptr</code>はコピーできませんが、所有権を移すために<em>ムーブ</em>することはできます。
        </span>
        <span>
            <span class="src">
                <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">
                    <code>std::shared_ptr</code>
                </a> is a smart pointer type
                that expresses shared ownership of
                a dynamically allocated object.
            </span>
            <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>は、動的確保されたオブジェクトの所有権を他と共有することを表現するために使われるスマートポインタです。
        </span>

        <span>
            <span class="src">
                <code>std::shared_ptr</code>s
                can be copied; ownership of the object is shared among
                all copies, and the object is deleted when the last
                <code>std::shared_ptr</code> is destroyed.
            </span>
            <code>std::shared_ptr</code>はコピーすることができ、オブジェクトの所有権は、それらのすべてのコピー同士の間で共有されます。最後の<code>std::shared_ptr</code>インスタンスが破壊されるときに、所有するオブジェクトが解放されます。
        </span>
    </p>
    <p class="pros"></p>
    <ul>
        <li>
            <span>
                <span class="src">
                    It's virtually impossible to manage dynamically
                    allocated memory without some sort of ownership
                    logic.
                </span>
                所有権の概念がなければ、動的確保されるメモリを管理するのは実質不可能でしょう。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Transferring ownership of an object can be cheaper
                    than copying it (if copying it is even possible).
                </span>
                オブジェクト自体をコピーすることに比べて、所有権の移動は低コストに済みます。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Transferring ownership can be simpler than
                    'borrowing' a pointer or reference, because it reduces
                    the need to coordinate the lifetime of the object
                    between the two users.
                </span>
                参照やポインタでオブジェクトを<em>借りる</em>よりも、所有権を移してしまう方が、それらを扱う二者間でオブジェクトの生存期間に関する認識をあわせやすく、プログラムの構造をシンプルにできます。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Smart pointers can improve readability by making
                    ownership logic explicit, self-documenting, and
                    unambiguous.
                </span>
                スマートポインタを用いてオブジェクトの所有権に関するロジックを明示的に表現することで、それ自体がドキュメントの役割を果たし、コードの可読性が高まります。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Smart pointers can eliminate manual ownership
                    bookkeeping, simplifying the code and ruling out large
                    classes of errors.
                </span>
                スマートポインタを用いることで、オブジェクトの所有権を手作業で管理する手間から解放されます。これによって、コードがシンプルになり、所有権にまつわる様々な種類のバグを埋め込む可能性もまとめて排除できます。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    For <code>const</code> objects, shared ownership can be a simple
                    and efficient alternative to deep copying.
                </span>
                <code>const</code>なオブジェクトにおいて、その所有権を共有すれば、オブジェクトをディープコピーするのに比べて、シンプルかつ効率的な代替手段となります。
            </span>
        </li>
    </ul>

    <p class="cons"></p>
    <ul>
        <li>
            <span>
                <span class="src">
                    Ownership must be represented and transferred via
                    pointers (whether smart or plain).
                </span>
                オブジェクトの所有権の概念を取り扱うときは、ポインタがスマートであるなしに関わらず、いずれにせよ、何らかのポインタを経由して取り扱うことになりますが、
            </span>
            <span>
                <span class="src">
                    Pointer semantics
                    are more complicated than value semantics, especially
                    in APIs: you have to worry not just about ownership,
                    but also aliasing, lifetime, and mutability, among
                    other issues.
                </span>
                ポインタの概念は、値を直接取り扱うよりも複雑です。とりわけAPIの層では、所有権についてだけではなく、エリアシングや、寿命や、変更可能性など、様々な点について考慮しなければならなくなります。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    The performance costs of value semantics are often
                    overestimated, so the performance benefits of ownership
                    transfer might not justify the readability and
                    complexity costs.
                </span>
                値を直接扱う場合のパフォーマンスコストは、しばしば、実際にかかるコストよりも高めに見積もられがちです。このため、パフォーマンスコストの低減を目当てに所有権を移す方法を採用しても、そのメリットは、コードの可読性低下や複雑化などのデメリットに見合わないかもしれません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    APIs that transfer ownership force their clients
                    into a single memory management model.
                </span>
                所有権を移動させるようなAPIは、ユーザーに単一のメモリ管理モデルを採用することを強制します。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Code using smart pointers is less explicit about
                    where the resource releases take place.
                </span>
                スマートポインタを扱うコードは、リソースの解放がどこで行われるのか、コードの見た目からわかりにくくなります。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <code>std::unique_ptr</code> expresses ownership
                    transfer using move semantics, which are
                    relatively new and may confuse some programmers.
                </span>
                <code>std::unique_ptr</code> は、ムーブで所有権の移動を表現しますが、このムーブの概念自体が新しく、プログラマーによっては困惑してしまうかもしれません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Shared ownership can be a tempting alternative to
                    careful ownership design, obfuscating the design of a
                    system.
                </span>
                注意深く所有権に関する設計を行うかわりに、単に所有権を共有させて済ませてしまうやり方は、プログラマーにとって魅惑的な代替手段に見えるかもしれません。しかし、それを選んでしまうと、システム全体のデザインがわかりにくくなってしまいます。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Shared ownership requires explicit bookkeeping at
                    run-time, which can be costly.
                </span>
                所有権を共有するためには、実行時にそれを管理する必要があります。これによって、思いのほかプログラムの性能が低下してしまうかもしれません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    In some cases (e.g., cyclic references), objects
                    with shared ownership may never be deleted.
                </span>
                たとえば循環参照を作ってしまった場合など、所有権を共有したオブジェクトが一切解放されなくなってしまうことがあります。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Smart pointers are not perfect substitutes for
                    plain pointers.
                </span>
                スマートポインタは、生のポインタで実現できることを完全には代替しません。
            </span>
        </li>
    </ul>

    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                If dynamic allocation is necessary, prefer to keep
                ownership with the code that allocated it.
            </span>
            動的にオブジェクトを確保する必要があるときは、それを行うコードにオブジェクトの所有権を持たせるようにしましょう。
        </span>
        <span>
            <span class="src">
                If other code
                needs access to the object, consider passing it a copy,
                or passing a pointer or reference without transferring
                ownership.
            </span>
            他のコードからそのオブジェクトにアクセスしたいときは、オブジェクトをコピーして渡すか、所有権を移さずにポインタか参照を渡す方法をまず検討してください。
        </span>
        <span>
            <span class="src">
                Prefer to use <code>std::unique_ptr</code> to
                make ownership transfer explicit.
            </span>
            所有権を移すときは、それを明示的に表現するために、<code>std::unique_ptr</code>を使いましょう。
        </span>
        <span>
            <span class="src">
                For example:
            </span>
            以下に例を示します。
        </span>
    </p>

    <pre>std::unique_ptr&lt;Foo&gt; FooFactory();
void FooConsumer(std::unique_ptr&lt;Foo&gt; ptr);
</pre>

    <p>
        <span>
            <span class="src">
                Do not design your code to use shared ownership
                without a very good reason.
            </span>
            非常によい理由でもない限り、オブジェクトの所有権を共有する設計にはしないでください。
        </span>
        <span>
            <span class="src">
                One such reason is to avoid
                expensive copy operations, but you should only do this if
                the performance benefits are significant, and the
                underlying object is immutable (i.e.,
                <code>std::shared_ptr&lt;const Foo&gt;</code>).
            </span>
            ここでいう「よい理由」には、たとえばオブジェクトをコピーする高いコストを避けたいから、といったものが挙げられますが、その場合であっても、そのパフォーマンス上のメリットが非常に大きく、かつ、対象となるオブジェクトが不変である(すなわち、<code>std::shared_ptr&lt;const Foo&gt;</code>)場合に限定すべきです。
        </span>
        <span>
            <span class="src">
                If you
                do use shared ownership, prefer to use
                <code>std::shared_ptr</code>.
            </span>
            これらを踏まえて、所有権を共有させることを選ぶ場合は、<code>std::shared_ptr</code>を使いましょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Never use <code>std::auto_ptr</code>.
            </span>
            <code>std::auto_ptr</code>の使用は禁止します。
        </span>
        <span>
            <span class="src">
                Instead, use
                <code>std::unique_ptr</code>.
            </span>
            かわりに、<code>std::unique_ptr</code>を使ってください。
        </span>
    </p>

    <h3 id="cpplint">
        <span title="cpplint">cpplint</span>
    </h3>

    <p>
        <span>
            <span class="src">
                Use <code>cpplint.py</code>
                to detect style errors.
            </span>
            <code>cpplint.py</code>を使ってスタイルに関する問題を検出しましょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                <code>cpplint.py</code>
                is a tool that reads a source file and identifies many
                style errors.
            </span>
            <code>cpplint.py</code>は、ソースファイルを読み込ませると、スタイルに関するたくさんのエラーを識別してくれるツールです。
        </span>
        <span>
            <span class="src">
                It is not perfect, and has both false
                positives and false negatives, but it is still a valuable
                tool.
            </span>
            このツールは完璧ではなく、ときに誤検出や見逃しもありますが、それでも十分に有用であることには違いありません。
        </span>
        <span>
            <span class="src">
                False positives can be ignored by putting <code>
                                // NOLINT
                            </code> at the end of the line or
                <code>// NOLINTNEXTLINE</code> in the previous line.
            </span>
            偽陽性の誤判定がなされる場合は、行末に<code>// NOLINT</code>を書くか、直前の行に<code>// NOLINTNEXTLINE</code>を書くことで、無視させることができます。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Some projects have instructions on
                how to run <code>cpplint.py</code> from their project
                tools.
            </span>
            プロジェクトによっては、プロジェクトツールで<code>cpplint.py</code>を起動する手順が用意されている場合があります。
        </span>
        <span>
            <span class="src">
                If the project you are contributing to does not,
                you can download
                <a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/cpplint/cpplint.py">
                    <code>cpplint.py</code>
                </a> separately.
            </span>
            それ以外の場合、<a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/cpplint/cpplint.py"><code>cpplint.py</code></a>から個別にダウンロードすることができます。
        </span>
    </p>

    <h2 id="Other_C++_Features">
        <span title="Other C++ Features">その他のC++の機能</span>
    </h2>

    <h3 id="Rvalue_references">
        <span title="Rvalue References">右辺値参照(rvalue reference)</span>
    </h3>

    <p>
        <span>
            <span class="src">
                Use rvalue references only in certain special cases listed below.
            </span>
            右辺値参照は、以下に挙げるような特殊な場合に限り使用します。
        </span>
    </p>

    <p class="definition"></p>
    <p>
        <span>
            <span class="src">
                Rvalue references
                are a type of reference that can only bind to temporary
                objects.
            </span>
            右辺値参照(rvalue reference)とは、一時オブジェクトのみを束縛する参照のことです。
        </span>
        <span>
            <span class="src">
                The syntax is similar to traditional reference
                syntax.
            </span>
            その文法は従来からある参照の文法に似ています。
        </span>
        <span>
            <span class="src">
                For example, <code>void f(std::string&amp;&amp; s);
                </code> declares a function whose argument is an
                rvalue reference to a <code>std::string</code>.
            </span>
            たとえば、<code>void f(string&amp;&amp; s);</code>は、<code>std::string</code>への右辺値参照を引数にとる関数を宣言しています。
        </span>
    </p>

    <p id="Forwarding_references">
        <span>
            <span class="src">
                When the token '&amp;&amp;' is applied to
                an unqualified template argument in a function
                parameter, special template argument deduction
                rules apply.
            </span>
            関数の仮引数において、修飾子のないテンプレート引数に <code>&amp;&amp;</code> が使われた場合、特殊なテンプレート引数推論ルールが適用されます。
        </span>
        <span>
            <span class="src">
                Such a reference is called a forwarding reference.
            </span>
            このような特殊な参照は、「転送参照(Forwarding Reference)」と呼ばれます。(訳注:従来はユニバーサル参照(Universal Reference)と呼ばれていましたが、C++17で転送参照という語が定められました)
        </span>
    </p>
    <p class="pros"></p>
    <ul>
        <li>
            <span>
                <span class="src">
                    Defining a move constructor (a constructor taking
                    an rvalue reference to the class type) makes it
                    possible to move a value instead of copying it.
                </span>
                ムーブコンストラクタ(そのクラス型への右辺値参照をとるコンストラクタ)を定義すると、値をコピーするかわりにムーブすることができるようになります。
            </span>
            <span>
                <span class="src">
                    If
                    <code>v1</code> is a <code>std::vector&lt;std::string&gt;</code>,
                    for example, then <code>auto v2(std::move(v1))</code>
                    will probably just result in some simple pointer
                    manipulation instead of copying a large amount of data.
                </span>
                たとえば、変数<code>v1</code>が<code>std::vector&lt;std::string&gt;</code>であるとき、<code>auto v2(std::move(v1))</code>とすれば、おそらく、大量のデータのコピーを発生させることなく、単なるポインタ操作だけで済ませられるでしょう。
            </span>
            <span>
                <span class="src">
                    In many cases this can result in a major performance
                    improvement.
                </span>
                このような動作は、多くの場合において、大きなパフォーマンス向上に繋がるでしょう。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Rvalue references make it possible to implement
                    types that are movable but not copyable, which can be
                    useful for types that have no sensible definition of
                    copying but where you might still want to pass them as
                    function arguments, put them in containers, etc.
                </span>
                右辺値参照によって、ムーブ可能かつコピー不可な型を実装することができるようになります。型に意味のあるコピーを定義できないときであっても、関数の引数に渡したりコンテナに格納したりできるようになるため便利です。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <code>std::move</code> is necessary to make
                    effective use of some standard-library types, such as
                    <code>std::unique_ptr</code>.
                </span>
                たとえば<code>std::unique_ptr</code>のような、いくつかの標準ライブラリを有効に使うためには、<code>std::move</code>は必須です。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <a href="#Forwarding_references">Forwarding references</a> which
                    use the rvalue reference token, make it possible to write a
                    generic function wrapper that forwards its arguments to
                    another function, and works whether or not its
                    arguments are temporary objects and/or const.
                </span>
                右辺値参照と同じ記号を使う<a href="#Forwarding_references">転送参照</a>を用いると、引数をほかの関数に転送する汎用的なラッパー関数を書くことができます。
                これは、引数が一時オブジェクトであるなしに、constであるなしに関わらず動作します。
            </span> 
            <span>
                <span class="src">
                    This is called 'perfect forwarding'.
                </span>
                これを「完全転送(perfect forwarding)」と呼びます。
            </span>

        </li>
    </ul>

    <p class="cons"></p>
    <ul>
        <li>
            <span>
                <span class="src">
                    Rvalue references are not yet widely understood.
                </span>
                右辺値参照は、まだ広く理解されていません。
            </span>
            <span>
                <span class="src">
                    Rules like reference
                    collapsing and the special deduction rule for forwarding references
                    are somewhat obscure.
                </span>
                まして、参照の折りたたみ(reference collapsing)や転送参照に対する特殊な推論ルールなどに至っては、おぼろげにしか理解されていません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Rvalue references are often misused.
                </span>
                右辺値参照は、しばしば間違った使い方で使われます。
            </span>
            <span>
                <span class="src">
                    Using rvalue
                    references is counter-intuitive in signatures where the argument is expected
                    to have a valid specified state after the function call, or where no move
                    operation is performed.
                </span>
                右辺値参照は、その見た目に対して非直感的な動作をします。
                たとえば、右辺値参照の引数を与えた関数呼び出しの後にも有効な状態を持っていそうに見えたり、ムーブ操作が行われているようには見えなかったりします。
            </span>
        </li>
    </ul>

    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                Do not use rvalue references (or apply the <code>&amp;&amp;</code>
                qualifier to methods), except as follows:
            </span>
            右辺値参照(や、メソッドの<code>&amp;&amp;</code>参照修飾子)は、以下の場合を除き、使ってはいけません。
        </span>
    </p>

    <ul>
        <li>
            <span>
                <span class="src">
                    You may use them to define move constructors and move assignment
                    operators (as described in
                    <a href="#Copyable_Movable_Types">Copyable and Movable Types</a>)
                </span>
                ムーブコンストラクタ・ムーブ代入演算子(詳細は<a href="#Copyable_Movable_Types">コピー可能な型・ムーブ可能な型</a>にて記載)を定義するためであれば、右辺値参照を使ってもかまいません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    You may use them to define <code>&amp;&amp;</code>-qualified methods that
                    logically "consume" <code>*this</code>, leaving it in an unusable
                    or empty state.
                </span>
                <code>*this</code>を論理的に<em>消費</em>して、それ以降使用不可(あるいは空の状態)にするようなメソッドを定義するためであれば、右辺値修飾子(<code>&amp;&amp;</code>修飾子)を使ってもかまいません。
            </span>
            <span>
                <span class="src">
                    Note that this applies only to method qualifiers (which come
                    after the closing parenthesis of the function signature); if you want to
                    "consume" an ordinary function parameter, prefer to pass it by value.
                </span>
                ただし、あくまでメソッドの修飾子(関数シグネチャの閉じ丸括弧のあとに続く修飾子)にのみが認められるということに注意してください。関数引数を<em>消費</em>する場合については、単に値渡しする方法が優先します。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    You may use forwarding references in conjunction with <code>
                    <a href="http://en.cppreference.com/w/cpp/utility/forward">std::forward</a></code>,
                    to support perfect forwarding.
                </span>
                完全転送(perfect forwarding)を実現するために<a href="http://en.cppreference.com/w/cpp/utility/forward">std::forward</a>とあわせた転送参照を使ってもかまいません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    You may use them to define pairs of overloads, such as one taking
                    <code>Foo&amp;&amp;</code> and the other taking <code>const Foo&amp;</code>.
                </span>
                オーバーロードの組を定義するためであれば、右辺値参照を使ってもかまいません。
                たとえば<code>Foo&amp;&amp;</code>を引数にとる関数オーバーロードと<code>const Foo&amp;</code>を引数にとる関数オーバーロードを用意すると都合がよい場合があります。
            </span>
            <span>
                <span class="src">
                    Usually the preferred solution is just to pass by value, but an overloaded
                    pair of functions sometimes yields better performance and is sometimes
                    necessary in generic code that needs to support a wide variety of types.
                </span>
                通常は、単純な値渡しを採用するのがもっとも好ましいですが、このようなオーバーロード関数の組は、それらを別々に用意することでパフォーマンスが向上したり、広く様々な型を受け入れる汎用的なコードを書くときには必須となったりします。
            </span>
            <span>
                <span class="src">
                    As always: if you're writing more complicated code for the sake of
                    performance, make sure you have evidence that it actually helps.
                </span>
                ただし、パフォーマンスの都合でコードを複雑化させるときは、いつものように、そのコード変更が実際にパフォーマンスを向上させているという証拠を用意するようにしてください。
            </span>
        </li>
    </ul>

    <h3 id="Friends"><a title="Friends">フレンド</a></h3>

    <p>
        <span>
            <span class="src">
                We allow use of <code>friend</code> classes and functions,
                within reason.
            </span>
            合理的な範囲内であれば、<code>friend</code>クラスや<code>friend</code>関数を使ってもかまいません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Friends should usually be defined in the same file so
                that the reader does not have to look in another file to
                find uses of the private members of a class.
            </span>
            フレンドに指定する対象は、通常は同じファイル内で定義してください。
            そうすることで、そのフレンドによってプライベートメンバがどう扱われるのか、コードの読者が他のファイルに定義を探しに行かずともよくなります。
        </span>
        <span>
            <span class="src">
                A common use
                of <code>friend</code> is to have a
                <code>FooBuilder</code> class be a friend of
                <code>Foo</code> so that it can construct the inner state
                of <code>Foo</code> correctly, without exposing this
                state to the world.
            </span>
            よくあるフレンドの使い方は、たとえば、<code>FooBuilder</code>クラスを<code>Foo</code>クラスのフレンドにして、<code>Foo</code>の内部状態を全世界に晒すことなく<code>FooBuilder</code>に正しく構築させられるようにするといったパターンです。
        </span>
        <span>
            <span class="src">
                In some cases it may be useful to
                make a unittest class a friend of the class it tests.
            </span>
            ほかにも、たとえばあるクラスのユニットテストを担うクラスをそのフレンドにしておくと有用なこともあります。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Friends extend, but do not break, the encapsulation
                boundary of a class.
            </span>
            フレンドの仕組みは、クラスのカプセル化の境界を壊すことなく拡張することができます。
        </span>
        <span>
            <span class="src">
                In some cases this is better than
                making a member <code>public</code> when you want to give only one
                other class access to it.
            </span>
            ある特定のクラスにだけメンバへのアクセス権を与えたいとき、そのメンバを単に<code>public</code>にするよりも、フレンドを用いる方が適切な場合があります。
        </span>
        <span>
            <span class="src">
                However, most classes should
                interact with other classes solely through their public
                members.
            </span>
            ただし、原則としては、ほとんどのクラス間のやりとりは<code>public</code>メンバを通してのみ行うようにします。
        </span>
    </p>
    <h3 id="Exceptions"><span title="Exceptions">例外</span></h3>

    <p>
        <span>
            <span class="src">
                We do not use C++ exceptions.
            </span>
            私たちはC++の例外を使いません。
        </span>
    </p>

    <p class="pros"></p>
    <ul>
        <li>
            <span>
                <span class="src">
                    Exceptions allow higher levels of an application to
                    decide how to handle "can't happen" failures in deeply
                    nested functions, without the obscuring and error-prone
                    bookkeeping of error codes.
                </span>
                例外の機構を用いると、深くネストされた関数の中で起きた<em>起こらないはずの</em>失敗について、不明瞭で取り違えやすい帳簿的なエラーコードを扱うことなく、アプリケーションのより高い層でその処理方法を決定できるようになります。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Exceptions are used by most other
                    modern languages.
                </span>
                例外機構は、多くの現代的言語で採用されています。
            </span>
            <span>
                <span class="src">
                    Using them in C++ would make it more
                    consistent with Python, Java, and the C++ that others
                    are familiar with.
                </span>
                C++でも例外を取り入れれば、PythonやJavaや、多くの人にとって馴染みのあるC++との一貫性がより高まるでしょう。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Some third-party C++ libraries use exceptions, and
                    turning them off internally makes it harder to
                    integrate with those libraries.
                </span>
                サードパーティ製のC++ライブラリには例外を使用しているものもあります。
                内部的に例外機構自体を無効にしてしまうと、そのようなライブラリを統合するのが難しくなってしまいます。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Exceptions are the only way for a constructor to
                    fail.
                </span>
                例外は、コンストラクタ内の失敗を伝えられる唯一の手段です。
            </span>
            <span>
                <span class="src">
                    We can simulate this with a factory function or
                    an <code>Init()</code> method, but these require heap
                    allocation or a new "invalid" state, respectively.
                </span>
                例外を使わなくても、ファクトリ関数や<code>Init()</code>メソッドを用いれば、初期化時のエラーを伝えることができるようにはなります。しかし、これらの代替手段は、ヒープの確保を必要としたり、新たに<em>不正である</em>ことを表すための状態を導入することを必要としたりします。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Exceptions are really handy in testing
                    frameworks.
                </span>
                例外は、テストフレームワークにとって、非常に手頃な手段といえます。
            </span>
        </li>
    </ul>

    <p class="cons"></p>
    <ul>
        <li>
            <span>
                <span class="src">
                    When you add a <code>throw</code> statement to an
                    existing function, you must examine all of its
                    transitive callers.
                </span>
                既存の関数に<code>throw</code>文を追加しようとするとき、その関数の呼び出し元について、推移的なものまで含めて、すべて調べなければなりません。
            </span>
            <span>
                <span class="src">
                    Either they must make at least the
                    basic exception safety guarantee, or they must never
                    catch the exception and be happy with the program
                    terminating as a result.
                </span>
                そして、それらの呼び出し元が最低限の基本的な例外安全保証を満たしているか、例外を一切キャッチせずプログラムが途中で終了しても問題ない作りになっているか、のいずれかでなければなりません。
            </span>
            <span>
                <span class="src">
                    For instance, if
                    <code>f()</code> calls <code>g()</code> calls
                    <code>h()</code>, and <code>h</code> throws an
                    exception that <code>f</code> catches, <code>g</code>
                    has to be careful or it may not clean up properly.
                </span>
                例として、たとえば<code>f()</code>が<code>g()</code>を呼び、<code>g()</code>が<code>h()</code>を呼んでいるときに、<code>h</code>が例外を投げ<code>f</code>がキャッチしたときのことを考えてみましょう。
                この場合は、<code>g</code>においても慎重にならないと、<code>g</code>が確保したリソースがきちんと解放されなくなってしまうかもしれません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    More generally, exceptions make the control flow of
                    programs difficult to evaluate by looking at code:
                    functions may return in places you don't expect.
                </span>
                より一般的には、例外が使われているプログラムは、その見た目からプログラムコードの流れを評価することが難しくなります。例外が投げられると、関数内の途中の思いもしないところから、呼び出し元に処理が戻ってしまいます。
            </span>
            <span>
                <span class="src">
                    This
                    causes maintainability and debugging difficulties.
                </span>
                これは、メンテナンス性の低下や、デバッグの難しさにつながります。
            </span>
            <span>
                <span class="src">
                    You
                    can minimize this cost via some rules on how and where
                    exceptions can be used, but at the cost of more that a
                    developer needs to know and understand.
                </span>
                これらのコストは、例外をどこでどのようにならば使ってよいかのルールを設けることで、最小限に抑えられそうに思えます。しかし、その代償として、今度は、すべての開発者がそれらのルールを知って理解しておく必要が生じ、それらが、より高いコストとなるかもしれません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Exception safety requires both RAII and different
                    coding practices.
                </span>
                例外安全なプログラムを書くためには、RAIIと、それと異なるコーディング手法との両方を必要とします。
            </span>
            <span>
                <span class="src">
                    Lots of supporting machinery is
                    needed to make writing correct exception-safe code
                    easy.
                </span>
                正しく例外安全なコードを簡単に書けるようにするためには、多くのサポート機構を必要とします。
            </span>
            <span>
                <span class="src">
                    Further, to avoid requiring readers to understand
                    the entire call graph, exception-safe code must isolate
                    logic that writes to persistent state into a "commit"
                    phase.
                </span>
                さらに、コード読者が呼び出しグラフ全体を理解していなければならないという事態を避けるためには、例外安全なコードでは、永続的な状態を書き込むロジックを<em>コミット</em>段階に分割しておかなければなりません。
            </span>
            <span>
                <span class="src">
                    This will have both benefits and costs (perhaps
                    where you're forced to obfuscate code to isolate the
                    commit).
                </span>
                これには、良い面もありますが悪い面もあります。
                おそらく、コミットを行うコードを分離するために、コードが複雑化するのを避けられないはずです。
            </span>
            <span>
                <span class="src">
                    Allowing exceptions would force us to always
                    pay those costs even when they're not worth it.
                </span>
                例外を使うことを認めたなら、たとえ価値が見合わないところでも、常にこれらのコストを払い続けることになります。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Turning on exceptions adds data to each binary
                    produced, increasing compile time (probably slightly)
                    and possibly increasing address space pressure.
                </span>
                例外を有効にすると、実行バイナリに追加のデータが生成されます。これによって、(わずかながら)コンパイルの所要時間が延びたり、使用可能なアドレス空間が圧迫されたりするかもしれません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    The availability of exceptions may encourage
                    developers to throw them when they are not appropriate
                    or recover from them when it's not safe to do so.
                </span>
                例外を使用可能にしていると、本来適切でない箇所で例外を投げたり、本来安全ではない回復を試みたりすることを、開発者に促してしまうかもしれません。
            </span>
            <span>
                <span class="src">
                    For
                    example, invalid user input should not cause exceptions
                    to be thrown.
                </span>
                たとえば、ユーザーの入力が不正だったとしても、それは例外を投げるべき事柄ではありません。
            </span>
            <span>
                <span class="src">
                    We would need to make the style guide
                    even longer to document these restrictions!
                </span>
                例外を使うことを認めるためには、そのようなことまでこのガイドに記述することになるため、このスタイルガイドをもっともっと長くしなければなりません！
            </span>
        </li>
    </ul>

    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                On their face, the benefits of using exceptions
                outweigh the costs, especially in new projects.
            </span>
            表面的には、特に新規のプロジェクトでは、例外を有効にするメリットが、そのコストよりも上回るでしょう。
        </span>
        <span>
            <span class="src">
                However,
                for existing code, the introduction of exceptions has
                implications on all dependent code.
            </span>
            しかし、既存のコードに例外を導入すると、すべての依存コードにも影響を与えてしまいます。
        </span>
        <span>
            <span class="src">
                If exceptions can be
                propagated beyond a new project, it also becomes
                problematic to integrate the new project into existing
                exception-free code.
            </span>
            新しいプロジェクトから例外が伝播してくる可能性があるとなれば、そのようなプロジェクトを例外を扱えない既存のコードと統合することは、やはり問題となります。
        </span>
        <span>
            <span class="src">
                Because most existing C++ code at
                Google is not prepared to deal with exceptions, it is
                comparatively difficult to adopt new code that generates
                exceptions.
            </span>
            この点において、Googleのほとんどの既存のC++コードは例外を扱う準備ができていないため、新しいコードが例外を生成するのであれば、それらを採用するのは比較的難しくなってしまいます。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Given that Google's existing code is not
                exception-tolerant, the costs of using exceptions are
                somewhat greater than the costs in a new project.
            </span>
            Googleの既存コードは例外を扱えるようになっていないため、新規プロジェクトで例外を扱う場合に比べて、そのコストはいくぶん大きなものになります。
        </span>
        <span>
            <span class="src">
                The
                conversion process would be slow and error-prone.
            </span>
            これらの対応には時間がかかるでしょうし、ミスも起こりやすいでしょう。
        </span>
        <span>
            <span class="src">
                We
                don't believe that the available alternatives to
                exceptions, such as error codes and assertions, introduce
                a significant burden.
            </span>
            私たちは、例外のかわりに、エラーコードやアサーションといった代替手段を使うことが、大きな負担をもたらすとは考えていません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Our advice against using exceptions is not predicated
                on philosophical or moral grounds, but practical ones.
            </span>
            このガイドで述べている例外に関するアドバイスは、哲学的あるいは道徳的な根拠によるものではなく、むしろ、実践的な根拠に基づいたものです。
        </span>
        <span>
            <span class="src">
                Because we'd like to use our open-source
                projects at Google and it's difficult to do so if those
                projects use exceptions, we need to advise against
                exceptions in Google open-source projects as well.
            </span>
            私たちは、Googleでオープンソースプロジェクトを使いたいと考えていますが、新しいプロジェクトで例外が扱われていると、そのプロジェクトを採用するのが難しくなってしまいます。このため、Googleのオープンソースプロジェクトに対しても、例外を避けるようにアドバイスする必要があります。
        </span>
        <span>
            <span class="src">
                Things would probably be different if we had to do it all
                over again from scratch.
            </span>
            もし、最初からすべてのことをやり直すとしたら、何かが違っていたかもしれません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                This prohibition also applies to exception handling related
                features such as
                <code>std::exception_ptr</code> and
                <code>std::nested_exception</code>.
            </span>
            例外を禁止するルールは、<code>std::exception_ptr</code>、<code>std::nested_exception</code>などの、例外処理に関する機能についても同様に適用します。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                There is an <a href="#Windows_Code">exception</a> to
                this rule (no pun intended) for Windows code.
            </span>
            なお、例外については<a href="#Windows_Code">Windowsのコードに関する例外</a>があります(ダジャレじゃないですよ)。
        </span>
    </p>

    <h3 id="noexcept"><code>noexcept</code></h3>

    <p>
        <span>
            <span class="src">
                Specify <code>noexcept</code> when it is useful and correct.
            </span>
            有用かつ正しいとき<code>noexcept</code>を指定します。
        </span>
    </p>

    <p class="definition">
    </p>
    <p>
        <span>
            <span class="src">
                The <code>noexcept</code> specifier is used to specify whether
                a function will throw exceptions or not.
            </span>
            <code>noexcept</code>指定子は、関数が例外を投げるか否かを指定するために使われます。
        </span>
        <span>
            <span class="src">
                If an exception
                escapes from a function marked <code>noexcept</code>, the program
                crashes via <code>std::terminate</code>.
            </span>
            <code>noexcept</code>とマークされた関数から例外が抜け出すと、プログラムは <code>std::terminate</code> を介してクラッシュします。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                The <code>noexcept</code> operator performs a compile-time
                check that returns true if an expression is declared to not
                throw any exceptions.
            </span>
            <code>noexcept</code>演算子は、与えられた式の宣言から、式が一切の例外を投げないと判定される場合に真となるコンパイル時のチェックを実行します。
        </span>
    </p>

    <p class="pros">
    </p>
    <ul>
        <li>
            <span>
                <span class="src">
                    Specifying move constructors as <code>noexcept</code>
                    improves performance in some cases, e.g.,
                    <code>std::vector&lt;T&gt;::resize()</code> moves rather than
                    copies the objects if T's move constructor is
                    <code>noexcept</code>.
                </span>
                ムーブコンストラクタを <code>noexcept</code> として指定すると、パフォーマンスが向上することがあります。
                たとえば、<code>std::vector&lt;T&gt;::resize()</code>において、<code>T</code>のムーブコンストラクタが<code>noexcept</code>指定されていれば、オブジェクトはコピーではなくムーブされます。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Specifying <code>noexcept</code> on a function can
                    trigger compiler optimizations in environments where
                    exceptions are enabled, e.g., compiler does not have to
                    generate extra code for stack-unwinding, if it knows
                    that no exceptions can be thrown due to a
                    <code>noexcept</code> specifier.
                </span>
                関数を<code>noexcept</code>に指定すると、例外が有効になっている環境でコンパイラの最適化をトリガーできるかもしれません。
                たとえば、<code>noexcept</code>指定子によって、関数が例外を投げないことがわかっている場合、コンパイラはスタックアンワインド(スタックの巻き戻し)のための余分なコードを生成する必要がなくなるでしょう。
            </span>
        </li>
    </ul>

    <p class="cons">
    </p>
    <ul>
        <li>
            <span>
                <span class="src">
                    In projects following this guide
                    that have exceptions disabled it is hard
                    to ensure that <code>noexcept</code>
                    specifiers are correct, and hard to define what
                    correctness even means.
                </span>
                このガイドに沿って例外を無効にしているプロジェクトでは、<code>noexcept</code>指定子の正しさを確かめることは難しく、そもそも、その正しさとは何を意味するのかを定義することさえ困難です。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    It's hard, if not impossible, to undo <code>noexcept</code>
                    because it eliminates a guarantee that callers may be relying
                    on, in ways that are hard to detect.
                </span>
                一度指定してしまった<code>noexcept</code>を取り消すことは、不可能ではないにせよ、困難な作業になることがあります。関数の呼び出し元のコードが<code>noexcept</code>性に依存した実装を行っていた場合、<code>noexcept</code>を取り消すことで呼び出し元のコードの前提条件を崩してしまうことになります。そして、そのことを検出すること難しいからです。
            </span>
        </li>
    </ul>

    <p class="decision">
    </p>
    <p>
        <span>
            <span class="src">
                You may use <code>noexcept</code> when it is useful for
                performance if it accurately reflects the intended semantics
                of your function, i.e., that if an exception is somehow thrown
                from within the function body then it represents a fatal error.
            </span>
            関数の意図するセマンティクスを正確に反映している場合、すなわち、もし例外が投げられたとしたらそれは致命的なエラーを表している場合において、<code>noexcept</code>がパフォーマンスに貢献するのであれば、これを使用してかまいません。
        </span>
        <span>
            <span class="src">
                You can assume that <code>noexcept</code> on move constructors
                has a meaningful performance benefit.
            </span>
            ムーブコンストラクタの <code>noexcept</code> には、有意なパフォーマンス上の利点があると考えてかまいません。
        </span>
        <span>
            <span class="src">
                If you think
                there is significant performance benefit from specifying
                <code>noexcept</code> on some other function, please discuss it
                with
                your project leads.
            </span>
            それ以外の関数において<code>noexcept</code>によって大きなパフォーマンスが得られると考える場合は、プロジェクトリーダーと相談して決めてください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Prefer unconditional <code>noexcept</code> if exceptions are
                completely disabled (i.e., most Google C++ environments).
            </span>
            例外を完全に無効にしている環境(すなわち、ほとんどのGoogleのC++環境)では、条件のない<code>noexcept</code>を使ってください。
        </span>
        <span>
            <span class="src">
                Otherwise, use conditional <code>noexcept</code> specifiers
                with simple conditions, in ways that evaluate false only in
                the few cases where the function could potentially throw.
            </span>
            それ以外の場合は、シンプルな条件とともに条件付きの <code>noexcept</code> 指定子を使用してください。
            これらで指定する条件は、関数が潜在的に例外を投げる可能性のある少数のケースでのみ偽に評価されるようにします。
        </span>
        <span>
            <span class="src">
                The tests might include type traits check on whether the
                involved operation might throw (e.g.,
                <code>std::is_nothrow_move_constructible</code> for
                move-constructing objects), or on whether allocation can throw
                (e.g., <code>absl::default_allocator_is_nothrow</code> for
                standard default allocation).
            </span>
            たとえば、呼び出す操作が例外を投げるか否か(ムーブコンストラクトにおける<code>std::is_nothrow_move_constructible</code>)や、メモリ確保操作が例外を投げるか否か(デフォルトのアロケート操作に対する<code>absl::default_allocator_is_nothrow</code>)などの、型トレイトに関するチェックなどが含まれるでしょう。
        </span>
        <span>
            <span class="src">
                Note in many cases the only
                possible cause for an exception is allocation failure (we
                believe move constructors should not throw except due to
                allocation failure), and there are many applications where it’s
                appropriate to treat memory exhaustion as a fatal error rather
                than an exceptional condition that your program should attempt
                to recover from.
            </span>
            なお、多くの場合において、例外の唯一の原因はアロケーション(メモリやリソース確保)操作の失敗であることに注意してください。(ムーブコンストラクタはリソース確保操作の失敗以外で例外を投げるべきではありません。)
            そして、このようなメモリの枯渇は、多くのアプリケーションにおいて、プログラムが回復を試みるべき状況ではなく、単なる致命的なエラーとして扱う方が適切です。
        </span>
        <span>
            <span class="src">
                Even for other
                potential failures you should prioritize interface simplicity
                over supporting all possible exception throwing scenarios:
                instead of writing a complicated <code>noexcept</code> clause
                that depends on whether a hash function can throw, for example,
                simply document that your component doesn’t support hash
                functions throwing and make it unconditionally
                <code>noexcept</code>.
            </span>
            その他の潜在的に起こりえるエラーに関しても、考えられるすべての種類の例外シナリオに対応を試みるのではなく、インターフェースをシンプルに保つことを優先します。たとえば、与えられたハッシュ関数が例外を投げるか否かを判定するための複雑な<code>noexcept</code>クロージャを書くかわりに、その関数のドキュメントにおいて例外を投げるハッシュ関数をサポートしないことを表明し、条件なしの<code>noexcept</code>指定子でマークしてしまうのはひとつのやり方でしょう。
        </span>
    </p>

    <h3 id="Run-Time_Type_Information__RTTI_"><span title="Run-Time Type Information (RTTI)">実行時型情報(RTTI)</span></h3>

    <p>
        <span>
            <span class="src">
                Avoid using run-time type information (RTTI).
            </span>
            実行時型情報(RTTI)は使わないでください。
        </span>
    </p>

    <p class="definition"></p>
    <p>
        <span>
            <span class="src">
                RTTI allows a
                programmer to query the C++ class of an object at
                run-time.
            </span>
            RTTIを用いると、プログラマーは実行時にオブジェクトのC++クラスを調べることができます。
        </span>
        <span>
            <span class="src">
                This is done by use of <code>typeid</code> or
                <code>dynamic_cast</code>.
            </span>
            これは、<code>typeid</code>や<code>dynamic_cast</code>を使うことで実現されます。
        </span>
    </p>
    <p class="pros"></p>
    <p>
        <span>
            <span class="src">
                The standard alternatives to RTTI (described below)
                require modification or redesign of the class hierarchy
                in question.
            </span>
            RTTIに対する標準的な代替手段(後述)を使おうとすると、対象とするクラスの階層構造の変更や再設計が必要になってしまいます。
        </span>
        <span>
            <span class="src">
                Sometimes such modifications are infeasible
                or undesirable, particularly in widely-used or mature
                code.
            </span>
            既にそのコードが広く使われていたり成熟していたりすると、このような変更を施すことはもはや実現不可能であったり、あるいは望ましくありません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                RTTI can be useful in some unit tests.
            </span>
            RTTIはユニットテストにおいても有用な場面があります。
        </span>
        <span>
            <span class="src">
                For example, it
                is useful in tests of factory classes where the test has
                to verify that a newly created object has the expected
                dynamic type.
            </span>
            たとえば、ファクトリクラスをテストするとき、正しい型のオブジェクトが生成できているか検証するために、RTTIを用いることができます。
        </span>
        <span>
            <span class="src">
                It is also useful in managing the
                relationship between objects and their mocks.
            </span>
            また、オブジェクトとそのモックとの関係を管理するのにも有用です。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                RTTI is useful when considering multiple abstract
                objects.
            </span>
            RTTIは、多数の抽象オブジェクトを考えるときにも有用です。
        </span>
        <span>
            <span class="src">
                Consider
            </span>
            以下の例を見てください。
        </span>
    </p>

    <pre>bool Base::Equal(Base* other) = 0;
bool Derived::Equal(Base* other) {
  Derived* that = dynamic_cast&lt;Derived*&gt;(other);
  if (that == nullptr)
    return false;
  ...
}
</pre>

    <p class="cons"></p>
    <p>
        <span>
            <span class="src">
                Querying the type of an object at run-time frequently
                means a design problem.
            </span>
            実行時にオブジェクトの型を調べることは、大抵の場合、プログラムに設計上の問題があることを意味しています。
        </span>
        <span>
            <span class="src">
                Needing to know the type of an
                object at runtime is often an indication that the design
                of your class hierarchy is flawed.
            </span>
            実行時にオブジェクトの型を知る必要があるということは、しばしば、クラス階層構造の設計に欠陥があることを示しています。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Undisciplined use of RTTI makes code hard to maintain.
            </span>
            無秩序にRTTIが使われると、コードのメンテナンスが困難になります。
        </span>
        <span>
            <span class="src">
                It can lead to type-based decision trees or switch
                statements scattered throughout the code, all of which
                must be examined when making further changes.
            </span>
            このようなコードでは、型に基づく決定木やswitch文がコード中のあちこちに散乱してしまいます。将来コードを変更するときには、それらのすべてを確かめなくてはならなくなってしまいます。
        </span>
    </p>

    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                RTTI has legitimate uses but is prone to abuse, so you
                must be careful when using it.
            </span>
            RTTIには妥当な使い方もありますが、逸脱した使われ方をする傾向にあります。RTTIを扱うときは十分注意してください。
        </span>
        <span>
            <span class="src">
                You may use it freely in
                unittests, but avoid it when possible in other code.
            </span>
            ユニットテストにおいては、自由にRTTIを使ってもかまいません。それ以外のコードにおいては可能な限り避けてください。
        </span>
        <span>
            <span class="src">
                In
                particular, think twice before using RTTI in new code.
            </span>
            特に、新しいコードでRTTIを使おうとする前に、もう一度よく考えてみてください。
        </span>
        <span>
            <span class="src">
                If
                you find yourself needing to write code that behaves
                differently based on the class of an object, consider one
                of the following alternatives to querying the type:
            </span>
            もし、オブジェクトのクラスに応じて挙動を変えるコードを書く必要が生じたときは、型を調べるかわりに次のいずれかの代替手段を検討してください。
        </span>
    </p>

    <ul>
        <li>
            <span>
                <span class="src">
                    Virtual methods are the preferred way of executing
                    different code paths depending on a specific subclass
                    type.
                </span>
                もっとも好ましいのは、仮想関数を用いることです。
                仮想関数を使えば、派生クラス型に応じて実行するコードパスを変えられます。
            </span>
            <span>
                <span class="src">
                    This puts the work within the object itself.
                </span>
                この方法であれば、必要な処理をそのオブジェクト自身に書くことができます。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    If the work belongs outside the object and instead
                    in some processing code, consider a double-dispatch
                    solution, such as the Visitor design pattern.
                </span>
                処理がオブジェクトの外にある何らかのコードに属している場合は、Visitorデザインパターンのような、二重ディスパッチを適用できることがあります。
            </span>
            <span>
                <span class="src">
                    This
                    allows a facility outside the object itself to
                    determine the type of class using the built-in type
                    system.
                </span>
                この方法であれば、オブジェクトの外にある機能が、組み込みの型システムを使って型を決定できます。
            </span>
        </li>
    </ul>

    <p>
        <span>
            <span class="src">
                When the logic of a program guarantees that a given
                instance of a base class is in fact an instance of a
                particular derived class, then a
                <code>dynamic_cast</code> may be used freely on the
                object.
            </span>
            プログラムの構造上、ある基底クラスのインスタンスが、特定の派生クラスのインスタンスであることが保証されている場合は、そのオブジェクトに対して<code>dynamic_cast</code>を使ってもかまいません。
        </span>
        <span>
            <span class="src">
                Usually one
                can use a <code>static_cast</code> as an alternative in
                such situations.
            </span>
            通常、このような場合においては、代替手段として<code>static_cast</code>を使うこともできます。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Decision trees based on type are a strong indication
                that your code is on the wrong track.
            </span>
            型による分岐が必要になったときは、そのコードが間違った方向に進んでいることを強く示しています。
        </span>
    </p>

    <pre class="badcode">if (typeid(*data) == typeid(D1)) {
  ...
} else if (typeid(*data) == typeid(D2)) {
  ...
} else if (typeid(*data) == typeid(D3)) {
...
</pre>

    <p>
        <span>
            <span class="src">
                Code such as this usually breaks when additional
                subclasses are added to the class hierarchy.
            </span>
            このようなコードは、大抵の場合、クラスの階層構造に新たな派生クラスが増えたとき、破綻してしまいます。
        </span>
        <span>
            <span class="src">
                Moreover,
                when properties of a subclass change, it is difficult to
                find and modify all the affected code segments.
            </span>
            さらに、派生クラスの性質が変わったときに、その影響があるすべてのコードを検索して変更することは非常に難しいでしょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Do not hand-implement an RTTI-like workaround.
            </span>
            RTTIのようなものを自前で実装するのはやめてください。
        </span>
        <span>
            <span class="src">
                The
                arguments against RTTI apply just as much to workarounds
                like class hierarchies with type tags.
            </span>
            ここまでのRTTIに関する議論は、たとえばオブジェクトに型を表すタグをつけて識別するような、自作の仕組みであっても同様に当てはまります。
        </span>
        <span>
            <span class="src">
                Moreover,
                workarounds disguise your true intent.
            </span>
            その上、このような回避手段を取ると、本当にやりたいことの意図が見えにくくなってしまいます。
        </span>
    </p>

    <h3 id="Casting"><span title="Casting">キャスト</span></h3>

    <p>
        <span>
            <span class="src">
                Use C++-style casts
                like <code>static_cast&lt;float&gt;(double_value)</code>, or brace
                initialization for conversion of arithmetic types like
                <code>int64_t y = int64_t{1} &lt;&lt; 42</code>.
            </span>
            キャストには、<code>static_cast&lt;float&gt;(double_value)</code>のようなC++スタイルのキャストを使います。
            算術型の変換には、<code>int64_t y = int64_t{1} &lt;&lt; 42</code>のような、波括弧初期化を使います。
        </span>
        <span>
            <span class="src">
                Do not use
                cast formats like <code>(int)x</code> unless the cast is to
                <code>void</code>.
            </span>
            <code>void</code>へのキャストを除いて<code>(int)x</code>の形のキャストは使ってはいけません。
        </span>
        <span>
            <span class="src">
                You may use cast formats like <code>T(x)</code> only when
                <code>T</code> is a class type.
            </span>
            なお、型<code>T</code>がクラスであるときに限り、<code>T(x)</code>のような形のキャストを使用してもかまいません。
        </span>
    </p>

    <p class="definition"></p>
    <p>
        <span>
            <span class="src">
                C++ introduced a
                different cast system from C that distinguishes the types
                of cast operations.
            </span>
            C++のキャストは、その操作の種類によって区別される、C言語とは異なるキャストシステムを導入しています。
        </span>
    </p>
    <p class="pros"></p>
    <p>
        <span>
            <span class="src">
                The problem with C casts is the ambiguity of the operation;
                sometimes you are doing a <em>conversion</em>
                (e.g., <code>(int)3.5</code>) and sometimes you are doing
                a <em>cast</em> (e.g., <code>(int)"hello"</code>).
            </span>
            C言語のキャストの問題点は、その操作が曖昧であることです。
            これらは、ときには<em>変換</em>(例:<code>(int)3.5</code>)であり、ときには<em>キャスト</em>(例:<code>(int)"hello"</code>)を表しています。
        </span>
        <span>
            <span class="src">
                Brace
                initialization and C++ casts can often help avoid this
                ambiguity.
            </span>
            波括弧初期化とC++のキャストを使えば、このような曖昧さはなくなります。
        </span>
        <span>
            <span class="src">
                Additionally, C++ casts are more visible when searching for
                them.
            </span>
            加えて、C++のキャストを使っていれば、それら検索したときに見つけやすくもなります。
        </span>
    </p>
    <p class="cons"></p>
    <p>
        <span>
            <span class="src">
                The C++-style cast syntax is verbose and cumbersome.
            </span>
            C++スタイルのキャストの文法は長くて面倒くさいです。
        </span>
    </p>
    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                In general, do not use C-style casts.
            </span>
            原則として、C言語スタイルのキャストは使ってはいけません。
        </span>
        <span>
            <span class="src">
                Instead, use these C++-style casts when
                explicit type conversion is necessary.
            </span>
            明示的に型変換が必要な場合は、C言語スタイルのキャストのかわりに、C++スタイルのキャストを使ってください。
        </span>
    </p>

    <ul>
        <li>
            <span>
                <span class="src">
                    Use brace initialization to convert arithmetic types
                    (e.g., <code>int64_t{x}</code>).
                </span>
                算術型の変換には、波括弧による初期化を使用してください(例:<code>int64_t{x}</code>)。
            </span>
            <span>
                <span class="src">
                    This is the safest approach because code
                    will not compile if conversion can result in information loss.
                </span>
                この方法は、型変換によって情報が失われるときにコンパイルエラーとなるため、それを防ぐ最も安全な手段です。
            </span>
            <span>
                <span class="src">
                    The
                    syntax is also concise.
                </span>
                また構文も簡潔です。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Use <code>absl::implicit_cast</code>
                    to safely cast up a type hierarchy,
                    e.g., casting a <code>Foo*</code> to a
                    <code>SuperclassOfFoo*</code> or casting a
                    <code>Foo*</code> to a <code>const Foo*</code>.
                </span>
                型階層におけるアップキャスト(基底クラスへのキャスト)を安全に行うためには<code>absl::implicit_cast</code>を使ってください。
                これには<code>Foo*</code>から<code>SuperclassOfFoo*</code>のようなキャストや、
                <code>Foo*</code>から<code>const Foo*</code>のようなキャストを含みます。
            </span>
            <span>
                <span class="src">
                    C++
                    usually does this automatically but some situations
                    need an explicit up-cast, such as use of the
                    <code>?:</code> operator.
                </span>
                通常、C++では、この種類のキャストは自動的に行われますが、<code>?:</code>演算子を使うときなどの一部の場面において、明示的なアップキャストの記述を必要とする場合があります。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Use <code>static_cast</code> as the equivalent of a C-style cast
                    that does value conversion, when you need to
                    explicitly up-cast a pointer from a class to its superclass, or when
                    you need to explicitly cast a pointer from a superclass to a
                    subclass.
                </span>
                明示的にあるクラスのポインタを基底クラスのポインタにアップキャストしたいときや、
                明示的にある基底クラスのポインタを派生クラスのポインタにダウンキャストしたいときは、
                値の変換を行うC言語スタイルのキャストと等価な、<code>static_cast</code>を使用してください。
            </span>
            <span>
                <span class="src">
                    In this last case, you must be sure your object is
                    actually an instance of the subclass.
                </span>
                このうち、ダウンキャストを行う場合については、オブジェクトが実際にその派生クラスのインスタンスであることが確信できていないといけません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Use <code>const_cast</code> to remove the
                    <code>const</code> qualifier (see <a href="#Use_of_const">const</a>).
                </span>
                <code>const</code>修飾子(<a href="#Use_of_const">const</a>を参照)を外すためには<code>const_cast</code>を使ってください。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Use <code>reinterpret_cast</code> to do unsafe conversions of
                    pointer types to and from integer and other pointer
                    types,
                    including <code>void*</code>.
                </span>
                ポインタ型と整数型との間の変換や、型の異なるポインタ型との間の変換(<code>void*</code>も含みます)のような、安全でない変換を行う場合は<code>reinterpret_cast</code>を使ってください。
            </span>
            <span>
                <span class="src">
                    Use this
                    only if you know what you are doing and you understand the aliasing
                    issues.
                </span>
                ただし、<code>reinterpret_cast</code>を使うのは、自分が何をしているのか理解していて、エイリアシングの問題についても十分理解している場合に限定してください。
            </span>
            <span>
                <span class="src">
Also, consider dereferencing the pointer (without a cast) and
  using <code>absl::bit_cast</code> to cast the resulting value.
                </span>
                あるいは、ポインタをキャストせずに参照外し(dereference)してから、<code>absl::bit_cast</code>によって値自体をキャストする方法も検討してください。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Use <code>absl::bit_cast</code> to interpret the raw bits of a
                    value using a different type of the same size (a type pun), such as
                    interpreting the bits of a <code>double</code> as
                    <code>int64_t</code>.
                </span>
                <code>double</code>のビット列を<code>int64_t</code>として解釈するような、
                生のビット列を同じサイズの違う型に再解釈(type-punning)したいときは、<code>absl::bit_cast</code>を使用してください。
            </span>
        </li>

    </ul>

    <p>
        <span>
            <span class="src">
                See the <a href="#Run-Time_Type_Information__RTTI_">
                RTTI section</a> for guidance on the use of
                <code>dynamic_cast</code>.
            </span>
            <code>dynamic_cast</code>に関するガイドについては<a href="#Run-Time_Type_Information__RTTI_">実行時型情報(RTTI)のセクション</a>も参照してください。
        </span>
    </p>

    <h3 id="Streams"><span title="Streams">ストリーム</span></h3>

    <p>
        <span>
            <span class="src">
                Use streams where appropriate, and stick to "simple"
                usages.
            </span>
            適切な場合にはストリームを使います。ただし「シンプルな使い方」にとどめるようにします。
        </span>
        <span>
            <span class="src">
                Overload <code>&lt;&lt;</code> for streaming only for types
                representing values, and write only the user-visible value, not any
                implementation details.
            </span>
            ストリームのための<code>&lt;&lt;</code>演算子のオーバーロードは、何らかの値を表す型に対してのみ行います。
            また、その演算子の実装について、値を人間が判読可能な形で出力するためだけの実装にとどめ、それ以外の詳細な実装を行わないようにしてください。
        </span>
    </p>

    <p class="definition"></p>
    <p>
        <span>
            <span class="src">
                Streams are the standard I/O abstraction in C++, as
                exemplified by the standard header <code>&lt;iostream&gt;</code>.
            </span>
            ストリームは、標準ヘッダー<code>&lt;iostream&gt;</code>でも例示されているように、C++における標準的な入出力の抽象概念です。
        </span>
        <span>
            <span class="src">
                They are widely used in Google code, mostly for debug logging
                and test diagnostics.
            </span>
            Googleのコードにおいても、主にデバッグのログやテスト診断を目的として、広く使われています。
        </span>
    </p>
    <p class="pros"></p>
    <p>
        <span>
            <span class="src">
                The <code>&lt;&lt;</code> and <code>&gt;&gt;</code>
                stream operators provide an API for formatted I/O that
                is easily learned, portable, reusable, and extensible.
            </span>
            ストリーム演算子<code>&lt;&lt;</code>と<code>&gt;&gt;</code>は、学びやすく、移植性があり、再利用可能かつ拡張性のある、書式化されたI/OのためのAPIを提供します。
        </span>
        <span>
            <span class="src">
                <code>printf</code>, by contrast, doesn't even support
                <code>std::string</code>, to say nothing of user-defined types,
                and is very difficult to use portably.
            </span>
            これとは対照的に、<code>printf</code>は、ユーザ定義型はおろか、<code>std::string</code>すらサポートしませんし、
            その使い方において移植可能性を保つのも非常に難しいです。
        </span>
        <span>
            <span class="src">
                <code>printf</code> also obliges you to choose among the
                numerous slightly different versions of that function,
                and navigate the dozens of conversion specifiers.
            </span>
            さらに、<code>printf</code>には、微妙に異なるたくさんのバージョンが存在し、その変換指定子も非常にたくさん存在します。
            <code>printf</code>を使おうとすることは、それらから適切なものを選んで適切に使用することを強制されるということを意味します。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Streams provide first-class support for console I/O
                via <code>std::cin</code>, <code>std::cout</code>,
                <code>std::cerr</code>, and <code>std::clog</code>.
            </span>
            ストリームは、<code>std::cin</code>や<code>std::cout</code>、<code>std::cerr</code>、<code>std::clog</code>を通して、最上級のコンソール入出力をサポートします。
        </span>
        <span>
            <span class="src">
                The C APIs do as well, but are hampered by the need to
                manually buffer the input.
            </span>
            もちろん、C言語のAPIを使っても同様のことは実現できますが、その場合、入力を手動でバッファする必要があるため、いくぶん面倒になります。
        </span>
    </p>
    <p class="cons"></p>
    <ul>
        <li>
            <span>
                <span class="src">
                    Stream formatting can be configured by mutating the
                    state of the stream.
                </span>
                ストリームが値をどうフォーマットするかの設定は、そのストリーム自体の状態を変更することで実現されますが、
            </span>
            <span>
                <span class="src">
                    Such mutations are persistent, so
                    the behavior of your code can be affected by the entire
                    previous history of the stream, unless you go out of your
                    way to restore it to a known state every time other code
                    might have touched it.
                </span>
                このような状態変更は、一度変更されると永続的に残ります。
                このため、他のコードがストリームの状態を変更しているかもしれない箇所では、毎回、わざわざストリームの状態を目的のものに復元してやらねばなりません。
                さもなくば、それまでに行われたストリーム操作のすべてが、コードの挙動に影響を及ぼしてしまうでしょう。
            </span>
            <span>
                <span class="src">
                    User code can not only modify the
                    built-in state, it can add new state variables and behaviors
                    through a registration system.
                </span>
                また、ユーザコードは、組み込みの状態を変更できるばかりでなく、新しい状態変数や挙動を追加することもできてしまいます。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    It is difficult to precisely control stream output, due
                    to the above issues, the way code and data are mixed in
                    streaming code, and the use of operator overloading (which
                    may select a different overload than you expect).
                </span>
                ストリームの出力を正確にコントロールするのは難しいことです。
                これには、ここまで述べてきた問題点の他、ストリームを扱う際にコードとデータが混ざったり、演算子オーバーロードの使い方(想定と異なるオーバーロードが選ばれてしまうかもしれない等)が関わってきたりするためです。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    The practice of building up output through chains
                    of <code>&lt;&lt;</code> operators interferes with
                    internationalization, because it bakes word order into the
                    code, and streams' support for localization is  <a href="http://www.boost.org/doc/libs/1_48_0/libs/locale/doc/html/rationale.html#rationale_why">
                    flawed</a>.
                </span>
                ストリームにおいて<code>&lt;&lt;</code>演算子を連ねて出力を構築する手法は、出力される語句の順序をコード上で固定してしまうため、国際化対応を行う際の障壁になります。
                また、ストリーム多言語対応機能自体にも<a href="http://www.boost.org/doc/libs/1_48_0/libs/locale/doc/html/rationale.html#rationale_why">欠陥があります</a>。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    The streams API is subtle and complex, so programmers must
                    develop experience with it in order to use it effectively.
                </span>
                ストリームのAPIは繊細かつ複雑です。
                このため、それらを効率的に使いこなせるようになるためには、それなりの開発経験を要します。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Resolving the many overloads of <code>&lt;&lt;</code> is
                    extremely costly for the compiler.
                </span>
                コンパイラにとって、たくさんの<code>&lt;&lt;</code>演算子オーバーロードの中から、どれを呼び出すか決定する仕事は、非常にコストがかかる工程です。
            </span>
            <span>
                <span class="src">
                    When used pervasively in a
                    large code base, it can consume as much as 20% of the parsing
                    and semantic analysis time.
                </span>
                大きなコードベースで、これらのオーバーロードがあまねく使われたとき、構文解析と意味解析の時間のうちの20%相当をも消費することがあります。
            </span>
        </li>
    </ul>

    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                Use streams only when they are the best tool for the job.
            </span>
            ストリームは、それが目的を果たすための最良のツールとなるときに限って採用しましょう。
        </span>
        <span>
            <span class="src">
                This is typically the case when the I/O is ad-hoc, local,
                human-readable, and targeted at other developers rather than
                end-users.
            </span>
            ストリームが適している典型例としては、(エンドユーザー向けではなく)他の開発者が利用することを目的とした、アドホックかつ局所的で、人間が判読可能なI/Oを行いたい場合などが相当します。
        </span>
        <span>
            <span class="src">
                Be consistent with the code around you, and with the
                codebase as a whole; if there's an established tool for
                your problem, use that tool instead.
            </span>
            ただし、その際でも、周りのコードやコードベース全体と一貫性を保つようにしてください。
            もし、課題を解決する手段として、すでにストリームとは別のツールを使うことが確立されているのであれば、それに倣う方が適切です。
        </span>

        <span>
            <span class="src">
                In particular,

                logging libraries are usually a better
                choice than <code>std::cerr</code> or <code>std::clog</code>
                for diagnostic output, and the libraries in

                <code>absl/strings</code>
                or the equivalent are usually a
                better choice than <code>std::stringstream</code>.
            </span>
            特に、通常、診断系の出力を行うためには<code>std::cerr</code>や<code>std::clog</code>よりも、何らかのログ出力ライブラリを使う方がベターな選択です。
            また、<code>std::stringstream</code>よりも、<code>absl/strings</code>にあるライブラリや同等のものを使う方がベターな選択でしょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Avoid using streams for I/O that faces external users or
                handles untrusted data.
            </span>
            外部ユーザーの目に触れる場所や、信頼できないデータを取り扱うときは、ストリームを使うのは避けましょう。
        </span>
        <span>
            <span class="src">
                Instead, find and use the appropriate
                templating libraries to handle issues like internationalization,
                localization, and security hardening.
            </span>
            そのような目的においては、多言語化などの問題に対応し、かつ、セキュリティ的にも強化された、適切なテンプレートエンジンを探し、それを使うようにしてください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                If you do use streams, avoid the stateful parts of the
                streams API (other than error state), such as <code>imbue()</code>,
                <code>xalloc()</code>, and <code>register_callback()</code>.
            </span>
            どうしてもストリームを使うときは、(エラーに関する状態を除いて、)ストリームの内部状態を変更するようなAPI(<code>imbue()</code>や<code>xalloc()</code>、<code>register_callback()</code>など)を使うのは避けましょう。
        </span>
        <span>
            <span class="src">
                Use explicit formatting functions (such as
                <code>absl::StreamFormat()</code>) rather than
                stream manipulators or formatting flags to control formatting
                details such as number base, precision, or padding.
            </span>
            基数や精度、出力幅などを設定したいときは、ストリームマニピュレータやフラグなどのかわりに、明示的ななフォーマット関数(たとえば<code>absl::StreamFormat()</code>)を使いましょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Overload <code>&lt;&lt;</code> as a streaming operator
                for your type only if your type represents a value, and
                <code>&lt;&lt;</code> writes out a human-readable string
                representation of that value.
            </span>
            独自の型にストリーム演算子の<code>&lt;&lt;</code>をオーバーロードするのは、その型が何らかの値を表す型である場合に限定してください。
            また、その際、<code>&lt;&lt;</code>の実装は、その値の(人間が判読可能な)文字列表現を書き出すだけにとどめてください。
        </span>
        <span>
            <span class="src">
                Avoid exposing implementation
                details in the output of <code>&lt;&lt;</code>; if you need to print
                object internals for debugging, use named functions instead
                (a method named <code>DebugString()</code> is the most common
                convention).
            </span>
            <code>&lt;&lt;</code>演算子によって、クラスの内部実装を公開することは避けてください。
            たとえば、デバッグ目的でオブジェクトの内部表現を出力したいときは、<code>&lt;&lt;</code>演算子ではなく、名前付きの関数を使うようにしてください。
            (この目的では、<code>DebugString()</code>という名前のメンバ関数を持たせるのが、もっとも一般的な慣習です)。
        </span>
    </p>

    <h3 id="Preincrement_and_Predecrement"><span title="Preincrement and Predecrement">前置インクリメントと前置デクリメント</span></h3>

    <p>
        <span>
            <span class="src">
                Use the prefix form (<code>++i</code>) of the increment and
                decrement operators unless you need postfix semantics.
            </span>
            インクリメント演算子とデクリメント演算子は、後置(<code>i++</code>)する必要がない限り、前置(<code>++i</code>)します。
        </span>
    </p>

    <p class="definition"></p>
    <p>
        <span>
            <span class="src">
                When a variable
                is incremented (<code>++i</code> or <code>i++</code>) or
                decremented (<code>--i</code> or <code>i--</code>) and
                the value of the expression is not used, one must decide
                whether to preincrement (decrement) or postincrement
                (decrement).
            </span>
            変数をインクリメント(<code>++i</code>もしくは<code>i++</code>)あるいはデクリメント(<code>--i</code>もしくは<code>i--</code>)する際に、その式の結果が使われないときに、前置インクリメント(デクリメント)と後置インクリメント(デクリメント)のどちらを使うか決めなければなりません。
        </span>
    </p>
    <p class="pros"></p>
    <p>
        <span>
            <span class="src">
                A postfix increment/decrement expression evaluates to the value
                <i>as it was before it was modified</i>.
            </span>
            後置インクリメント/デクリメント式は、<em>更新前の値</em>に評価されます。
        </span>
        <span>
            <span class="src">
                This can result in code that is more
                compact but harder to read.
            </span>
            結果的に、コードを、よりコンパクトにできる場合がありますが、読みにくくもなります。
        </span>
        <span>
            <span class="src">
                The prefix form is generally more readable, is
                never less efficient, and can be more efficient because it doesn't need to
                make a copy of the value as it was before the operation.
            </span>
            一方で、演算子を前置する形は、一般に読みやすく、決して非効率にはなることもありません。むしろ、操作前の値のコピーをとっておく必要がない分、より効率的になることもあります。
        </span>
    </p>
    <p class="cons"></p>
    <p>
        <span>
            <span class="src">
                The tradition developed, in C, of using post-increment, even
                when the expression value is not used, especially in
                <code>for</code> loops.
            </span>
            伝統的な開発において、特にC言語では、特に<code>for</code>ループなどの式の結果が使われない場合でも、後置する形が使われていました。
        </span>
        <span>
            <span class="src">
                Some find post-increment easier
                to read, since the "subject" (<code>i</code>) precedes
                the "verb" (<code>++</code>), just like in English.
            </span>
            後置インクリメントは、英語のように、主語(<code>i</code>)の後に動詞(<code>++</code>)と続くため、こちらの方が読みやすいと感じる人もいます。
        </span>
    </p>
    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                Use prefix increment/decrement, unless the code explicitly
                needs the result of the postfix increment/decrement expression.
            </span>
            コードが、明示的に後置インクリメント・デクリメントの式の結果を必要としない限り、前置インクリメント・デクリメントを使用してください。
        </span>
    </p>

    <h3 id="Use_of_const"><span title="Use of const">constの使い方</span></h3>
    <p>
        <span>
            <span class="src">
                In APIs, use <code>const</code> whenever it makes sense.
            </span>
            APIにおいて、合理的なときは常に<code>const</code>を使います。
        </span>
        <span>
            <span class="src">
                <code>constexpr</code> is a better choice for some uses of
                const.
            </span>
            また、<code>const</code>よりも<code>constexpr</code>を用いる方がより適切な場合もあります。
        </span>
    </p>

    <p class="definition"></p>
    <p>
        <span>
            <span class="src">
                Declared variables and parameters can be preceded
                by the keyword <code>const</code> to indicate the variables
                are not changed (e.g., <code>const int foo</code>).
            </span>
            <code>const int foo</code>のように、変数宣言や引数宣言に<code>const</code>キーワードを前置することで、それら変数が不変であることを示すことができます。
        </span>
        <span>
            <span class="src">
                Class
                functions can have the <code>const</code> qualifier to
                indicate the function does not change the state of the
                class member variables (e.g., <code>class Foo { int
                Bar(char c) const; };</code>).
            </span>
            また、<code>class Foo { int Bar(char c) const; };</code>のように、クラスのメンバ関数に<code>const</code>修飾子をつけることで、その関数がクラスのメンバ変数の状態を変更しないことを示すことができます。
        </span>
    </p>
    <p class="pros"></p>
    <p>
        <span>
            <span class="src">
                Easier for people to understand how variables are being
                used.
            </span>
            <code>const</code>宣言された変数は変更されないことが保証されるため、コードの読者にとって、その変数がコードにおいてどう扱われるか理解しやすくなります。
        </span>
        <span>
            <span class="src">
                Allows the compiler to do better type checking,
                and, conceivably, generate better code.
            </span>
            コンパイラにとっても、よりよい型チェックを行うことができ、ひょっとすると、よりよいコードを生成できるかもしれません。
        </span>
        <span>
            <span class="src">
                Helps people
                convince themselves of program correctness because they
                know the functions they call are limited in how they can
                modify your variables.
            </span>
            何らかの関数を呼ぶときでも、引数が<code>const</code>修飾されていれば、それらの引数に渡す変数が変更されないことがわかるため、そのプログラムの正しさについて納得しやすくなります。
        </span>
        <span>
            <span class="src">
                Helps people know what functions
                are safe to use without locks in multi-threaded
                programs.
            </span>
            マルチスレッドプログラムにおいては、どの関数をロックなしに呼び出せるか判断するためのヒントにもなります。
        </span>
    </p>
    <p class="cons"></p>
    <p>
        <span>
            <span class="src">
                <code>const</code> is viral: if you pass a
                <code>const</code> variable to a function, that function
                must have <code>const</code> in its prototype (or the
                variable will need a <code>const_cast</code>).
            </span>
            <code>const</code>は伝染します。
            <code>const</code>変数を関数に渡すときは、関数宣言においても<code>const</code>で修飾されていなければなりません(さもなくば、<code>const_cast</code>を必要とします)。
        </span>
        <span>
            <span class="src">
                This can
                be a particular problem when calling library
                functions.
            </span>
            これは、特に、ライブラリ関数を呼び出すときに問題になることがあります。
        </span>
    </p>
    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                We strongly recommend using <code>const</code>
                in APIs (i.e., on function parameters, methods, and
                non-local variables) wherever it is meaningful and accurate.
            </span>
            API(すなわち、関数引数やメソッド、非ローカル変数)を宣言するとき、意義がありかつ正しいときは、いつでも常に<code>const</code>を使うことを強く推奨します。
        </span>
        <span>
            <span class="src">
                This
                provides consistent, mostly compiler-verified documentation
                of what objects an operation can mutate.
            </span>
            これらの<code>const</code>は、各操作においてどのオブジェクトが変更される可能性があるのかに関する、一貫した、かつ、コンパイラによる検証済みのドキュメントの役割を果たします。
        </span>
        <span>
            <span class="src">
                Having
                a consistent and reliable way to distinguish reads from writes
                is critical to writing thread-safe code, and is useful in
                many other contexts as well.
            </span>
            一貫性と信頼性をもって変数の読み込みと書き込みを区別することは、スレッドセーフなコードを書くときには不可欠であり、また、その他の多くの文脈においても同様に有用でしょう。
        </span>
        <span>
            <span class="src">
                In particular:
            </span>
            特に以下の場合です。
        </span>
    </p>

    <ul>
        <li>
            <span>
                <span class="src">
                    If a function guarantees that it will not modify an argument
                    passed by reference or by pointer, the corresponding function parameter
                    should be a reference-to-const (<code>const T&amp;</code>) or
                    pointer-to-const (<code>const T*</code>), respectively.
                </span>
                参照渡しやポインタ渡しされる関数引数について、関数がそれらの変数を変更しないことを保証したいときは、対応する引数を<code>const</code>参照(<code>const T&amp;</code>)か、<code>const</code>ポインタ(<code>const T*</code>)とします。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    For a function parameter passed by value, <code>const</code> has
                    no effect on the caller, thus is not recommended in function
                    declarations.
                </span>
                値渡しの関数引数については、<code>const</code>は呼び出す側に影響を与えないため、関数宣言の中では非推奨とします。
            </span>
            <span>
                <span class="src">
                    See
                    <a href="https://abseil.io/tips/109">TotW #109</a>.
                </span>
                <a href="https://abseil.io/tips/109">TotW #109</a>を参照してください。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Declare methods to be <code>const</code> unless they
                    alter the logical state of the object (or enable the user to modify
                    that state, e.g., by returning a non-<code>const</code> reference, but that's
                    rare), or they can't safely be invoked concurrently.
                </span>
                クラスのメソッドは、そのメソッドがオブジェクトの論理的な状態を変更せず、かつ、複数のスレッドから同時に安全に呼び出せるとき、常に<code>const</code>修飾子をつけて宣言してください。
                (ここでいう論理的な状態の変更には、レアケースですが、関数がメンバへの非<code>const</code>参照を返すことによって、ユーザーがオブジェクトを直接変更できるようにすることも含まれます。)
            </span>
        </li>
    </ul>

    <p>
        <span>
            <span class="src">
                Using <code>const</code> on local variables is neither encouraged
                nor discouraged.
            </span>
            ローカル変数に<code>const</code>をつけるか否かは、推奨にも非推奨にもしません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                All of a class's <code>const</code> operations should be safe
                to invoke concurrently with each other.
            </span>
            また、クラスのすべての<code>const</code>な操作は、それらが互いに同時に呼び出されても安全であるようにしてください。
        </span>
        <span>
            <span class="src">
                If that's not feasible, the class must
                be clearly documented as "thread-unsafe".
            </span>
            そうでない場合は、そのクラスのスレッド安全性について、明確にドキュメントに記述してください。
        </span>
    </p>

    <h4 class="stylepoint_subsection"><span title="Where to put the const">constをどこに置くか</span></h4>

    <p>
        <span>
            <span class="src">
                Some people favor the form <code>int const *foo</code>
                to <code>const int* foo</code>.
            </span>
            人によっては、<code>const int* foo</code>という形より<code>int const *foo</code>の形を好む人もいます。
        </span>
        <span>
            <span class="src">
                They argue that this is
                more readable because it's more consistent: it keeps the
                rule that <code>const</code> always follows the object
                it's describing.
            </span>
            彼らの主張は「そちらの方が、常に<code>const</code>がオブジェクトの後に続くというルールを一貫して保てるため、可読性が高い」というものです。
        </span>
        <span>
            <span class="src">
                However, this consistency argument
                doesn't apply in codebases with few deeply-nested pointer
                expressions since most <code>const</code> expressions
                have only one <code>const</code>, and it applies to the
                underlying value.
            </span>
            しかし、この一貫性に関する主張は、深くネストされたポインタの表現には当てはまりません。
            ほとんどの<code>const</code>の式において、<code>const</code>は1度だけ表れ、かつ、それはポインタが指し示す先の値に対して適用されることが多いためです。
        </span>
        <span>
            <span class="src">
                In such cases, there's no consistency
                to maintain.
            </span>
            そのような場合は、もはや一貫性は保たれません。
        </span>
        <span>
            <span class="src">
                Putting the <code>const</code> first is
                arguably more readable, since it follows English in
                putting the "adjective" (<code>const</code>) before the
                "noun" (<code>int</code>).
            </span>
            一方で、<code>const</code>を先に置く方法は、英文法の語順(形容詞<code>const</code>の後に名詞<code>int</code>が続く)と一致するため、おそらく、こちらの方が読みやすく感じられることでしょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                That said, while we encourage putting
                <code>const</code> first, we do not require it.
            </span>
            以上より、<code>const</code>を先に置く形式を推奨しますが、これを必須のルールとはしません。
        </span>
        <span>
            <span class="src">
                But be
                consistent with the code around you!
            </span>
            ただし、周囲のコードとの一貫性は保つようにしてください。
        </span>
    </p>

    <h3 id="Use_of_constexpr"><span title="Use of constexpr">constexpr, constinit, constevalの使い方</span></h3>

    <p>
        <span>
            <span class="src">
                Use <code>constexpr</code> to define true
                constants or to ensure constant initialization.
            </span>
            真の定数を宣言したいとき、あるいは、定数初期化を保証したいときには、<code>constexpr</code>を使います。
        </span>
        <span>
            <span class="src">
Use <code>constinit</code> to ensure constant
initialization for non-constant variables.
            </span>
            非定数変数に対する定数初期化を保証したいときは、<code>constinit</code>を使います。
        </span>
    </p>

    <p class="definition"></p>
    <p>
        <span>
            <span class="src">
                Some variables can be declared <code>constexpr</code>
                to indicate the variables are true constants, i.e., fixed at
                compilation/link time.
            </span>
            変数を<code>constexpr</code>で宣言すると、それらは真の定数(すなわち、コンパイル時かリンク時に確定した値)になります。
        </span>
        <span>
            <span class="src">
                Some functions and constructors
                can be declared <code>constexpr</code> which enables them
                to be used in defining a <code>constexpr</code>
                variable.
            </span>
            関数やコンストラクタを<code>constexpr</code>で宣言すると、それらは<code>constexpr</code>変数の定義のためにも用いることができるようになります。
        </span>
        <span>
            <span class="src">
                Functions can be declared <code>consteval</code>
                to restrict their use to compile time.
            </span>
            関数を<code>consteval</code>で宣言すると、それらの関数についてコンパイル時にのみ呼び出せるように制限できます。
        </span>
    </p>
    <p class="pros"></p>
    <p>
        <span>
            <span class="src">
                Use of <code>constexpr</code> enables definition of
                constants with floating-point expressions rather than
                just literals; definition of constants of user-defined
                types; and definition of constants with function
                calls.
            </span>
            <code>constexpr</code>を用いると、ただのリテラルでない浮動小数点の式による定数や、ユーザ定義の型の定数、関数呼び出しを伴う定数を宣言することができます。
        </span>
    </p>
    <p class="cons"></p>
    <p>
        <span>
            <span class="src">
                Prematurely marking something as <code>constexpr</code> may cause
                migration problems if later on it has to be downgraded.
            </span>
            早まった<code>constexpr</code>宣言は、後にダウングレードの必要が生じた際に、妨げとなるかもしれません。
        </span>
        <span>
            <span class="src">
                Current restrictions on what is allowed in <code>constexpr</code>
                functions and constructors may invite obscure workarounds
                in these definitions.
            </span>
            また、現時点の<code>constexpr</code>関数・コンストラクタにはできることに制限があるため、その制限を回避したいがための回りくどい手法をコードに引き込んでしまうかもしれません。
        </span>
    </p>
    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                <code>constexpr</code> definitions enable a more
                robust specification of the constant parts of an
                interface.
            </span>
            <code>constexpr</code>を用いると、インターフェースにおける不変な部分の仕様をより堅牢にすることができます。
        </span>
        <span>
            <span class="src">
                Use <code>constexpr</code> to specify true
                constants and the functions that support their
                definitions.
            </span>
            真の定数や、それらの定義に用いる関数を定義するためには、<code>constexpr</code>を使ってください。
        </span>
        <span>
            <span class="src">
                <code>consteval</code> may be used for
                code that must not be invoked at runtime.
            </span>
            実行時に呼び出されてはならないコードのためには、<code>consteval</code>を使ってもかまいません。
        </span>
        <span>
            <span class="src">
                Avoid complexifying function definitions to
                enable their use with <code>constexpr</code>.
            </span>
            ただし、関数を<code>constexpr</code>にする目的だけのために、定義を複雑化させるのは避けてください。
        </span>
        <span>
            <span class="src">
                Do not use
                <code>constexpr</code> or <code>consteval</code> to force inlining.
            </span>
            また、インライン化を強制する目的では<code>constexpr</code>や<code>consteval</code>を使ってはいけません。
        </span>
    </p>

    <h3 id="Integer_Types"><span title="Integer Types">整数型</span></h3>

    <p>
        <span>
            <span class="src">
                Of the built-in C++ integer types, the only one used
                is
                <code>int</code>.
            </span>
            C++の組み込みの整数型の中では、使ってよいのは<code>int</code>だけです。
        </span>
        <span>
            <span class="src">
                If a program needs an integer type of a
                different size, use
                an exact-width integer type from
                <code>&lt;cstdint&gt;</code>, such as
                <code>int16_t</code>.
            </span>
            プログラムで異なるサイズの整数型を必要とするときは、<code>&lt;cstdint&gt;</code>から、(<code>int16_t</code>のような、)サイズが厳密に決められている整数型を使ってください。
        </span>
        <span>
            <span class="src">
                If you have a
                value that could ever be greater than or equal to 2^31,
                use a 64-bit type such as <code>int64_t</code>.
            </span>
            値が2³¹以上になりうる変数を取り扱う場合は、<code>int64_t</code>のような64ビット型を使ってください
        </span>
        <span>
            <span class="src">
                Keep in mind that even if your value won't ever be too large
                for an <code>int</code>, it may be used in intermediate
                calculations which may require a larger type.
            </span>
            また、値が<code>int</code>の範囲内に収まるとわかっていても、その計算過程でより大きな型を必要とする場合があるため、その点に常に注意してください。
        </span>
        <span>
            <span class="src">
                When in doubt,
                choose a larger type.
            </span>
            迷ったときには大きい型を選びましょう。
        </span>
    </p>

    <p class="definition"></p>
    <p>
        <span>
            <span class="src">
                C++ does not specify exact sizes for the integer types
                like <code>int</code>.
            </span>
            C++の仕様では、<code>int</code>に類する整数型のサイズが定めてられていません。
        </span>
        <span>
            <span class="src">
                Common sizes on contemporary architectures are
                16 bits for <code>short</code>, 32 bits for <code>int</code>, 32 or 64
                bits for <code>long</code>, and 64 bits for <code>long long</code>,
                but different platforms make different choices, in particular
                for <code>long</code>.
            </span>
            現代的なアーキテクチャにおいては、<code>short</code>は16ビット、<code>int</code>は32ビット、<code>long</code>は32ビットか64ビット、<code>long long</code>は64ビットという環境が一般的ですが、これらの整数型のサイズはプラットフォームごとに異なり、特に<code>long</code>には注意が必要です。
        </span>
    </p>
    <p class="pros"></p>
    <p>
        <span>
            <span class="src">
                Uniformity of declaration.
            </span>
            画一的な宣言を用いることができます。
        </span>
    </p>
    <p class="cons"></p>
    <p>
        <span>
            <span class="src">
                The sizes of integral types in C++ can vary based on
                compiler and architecture.
            </span>
            C++の整数型のサイズは、コンパイラとアーキテクチャによって異なることがあります。
        </span>
    </p>
    <p class="decision"></p>

    <p>
        <span>
            <span class="src">
                The standard library header <code>&lt;cstdint&gt;</code> defines types
                like <code>int16_t</code>, <code>uint32_t</code>,
                <code>int64_t</code>, etc.
            </span>
            標準ライブラリヘッダーの<code>&lt;cstdint&gt;</code>によって、<code>int16_t</code>や<code>uint32_t</code>、<code>int64_t</code>などの型が定義されています。
        </span>
        <span>
            <span class="src">
                You should always use
                those in preference to <code>short</code>, <code>unsigned
                long long</code> and the like, when you need a guarantee
                on the size of an integer.
            </span>
            整数型のサイズを保証する必要があるときは、<code>short</code>や<code>unsigned long long</code>などの組み込み型ではなく、常にサイズの明示された型を使いましょう。
        </span>
        <span>
            <span class="src">
                Prefer to omit the <code>std::</code>
                prefix for these types, as the extra 5 characters do
                not merit the added clutter.
            </span>
            また、これらの型については、<code>std::</code>を省略しましょう。この余分な5文字は、その乱雑さに見合うメリットがないためです。
        </span>
        <span>
            <span class="src">
                Of the built-in integer types, only
                <code>int</code> should be used.
            </span>
            組み込みの整数型については、<code>int</code>のみを使います。
        </span>
        <span>
            <span class="src">
                When appropriate, you
                are welcome to use standard type aliases like
                <code>size_t</code> and <code>ptrdiff_t</code>.
            </span>
            また、適切な場合は<code>size_t</code>や<code>ptrdiff_t</code>などの標準の型エイリアスを使うことも、もちろんかまいません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                We use <code>int</code> very often, for integers we
                know are not going to be too big, e.g., loop counters.
            </span>
            <code>int</code>は非常によく使われます。たとえばループカウンタなど、そこまで大きくなることがないとわかっている単なる整数については、
        </span>
        <span>
            <span class="src">
                Use plain old <code>int</code> for such things.
            </span>
            Plain Old な<code>int</code>を使ってください。
        </span>
        <span>
            <span class="src">
                You
                should assume that an <code>int</code> is

                at least 32 bits, but don't
                assume that it has more than 32 bits.
            </span>
            <code>int</code>は最低でも32ビットあると仮定してかまいません。しかし、32ビットよりも大きいと仮定してはいけません。
        </span>
        <span>
            <span class="src">
                If you need a 64-bit
                integer type, use <code>int64_t</code> or <code>uint64_t</code>.
            </span>
            64ビットの整数型が必要なときは、<code>int64_t</code>か<code>uint64_t</code>を使ってください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                For integers we know can be "big",
                use
                <code>int64_t</code>.
            </span>
            整数が大きくなるかもしれないときは<code>int64_t</code>を使ってください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                You should not use the unsigned integer types such as
                <code>uint32_t</code>, unless there is a valid
                reason such as representing a bit pattern rather than a
                number, or you need defined overflow modulo 2^N.
            </span>
            <code>unsigned</code>の整数型(<code>uint32_t</code>等)は、何らか明確が理由がなければ使ってはいけません。
            <code>unsigned</code>型は、たとえば、変数が数値ではなくビットパターンを表しているときや、あるいは、2^Nでの剰余によるオーバーフロー時の動作を定義したいときなどに適しています。
        </span>
        <span>
            <span class="src">
                In
                particular, do not use unsigned types to say a number
                will never be negative.
            </span>
            特に、整数が決して負にならないことを表現するために<code>unsigned</code>型を使ってはいけません。
        </span>
        <span>
            <span class="src">
                Instead, use
                assertions for this.
            </span>
            この目的では、かわりにアサーションを使ってください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                If your code is a container that returns a size, be
                sure to use a type that will accommodate any possible
                usage of your container.
            </span>
            何らかのコンテナ型を作るときは、そのサイズを返すための型として、そのコンテナ型がどのような使われ方をしても対応可能な型を選んでください。
        </span>
        <span>
            <span class="src">
                When in doubt, use a larger type
                rather than a smaller type.
            </span>
            迷ったときは、より大きな型を選びましょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Use care when converting integer types.
            </span>
            整数型の変換には注意してください。
        </span>
        <span>
            <span class="src">
                Integer conversions and
                promotions can cause undefined behavior, leading to security bugs and
                other problems.
            </span>
            整数型の変換や拡張は、ときに未定義動作を引き起こし、セキュリティ上のバグやその他の問題に繋がることがあります。
        </span>
    </p>
    <h4><span title="On Unsigned Integers"><code>unsigned</code>整数型について</span></h4>

    <p>
        <span>
            <span class="src">
                Unsigned integers are good for representing bitfields and modular
                arithmetic.
            </span>
            <code>unsigned</code>整数型は、ビットフィールドや剰余演算に有用です。
        </span>
        <span>
            <span class="src">
                Because of historical accident, the C++ standard also uses
                unsigned integers to represent the size of containers - many members
                of the standards body believe this to be a mistake, but it is
                effectively impossible to fix at this point.
            </span>
            歴史的な事情により、C++標準では、コンテナのサイズを表すために<code>unsigned</code>整数型が使われています。
            多くのC++標準化委員会のメンバーがこれを失敗だったと考えていますが、もはや現在において修正は不可能です。
        </span>
        <span>
            <span class="src">
                The fact that unsigned
                arithmetic doesn't model the behavior of a simple integer, but is
                instead defined by the standard to model modular arithmetic (wrapping
                around on overflow/underflow), means that a significant class of bugs
                cannot be diagnosed by the compiler.
            </span>
            標準によって定義される<code>unsigned</code>整数演算は、単純な整数演算の挙動をモデル化したものではなく、(オーバーフロー・アンダーフロー時に周回する)合同算術をモデル化したものです。
            このことは、これに起因する様々なバグについて、コンパイラが診断できないということを意味します。
        </span>
        <span>
            <span class="src">
                In other cases, the defined
                behavior impedes optimization.
            </span>
            また、このような挙動の定義のために、コンパイラによる最適化が妨げられることもあります。
        </span>
    </p>
    <p>
        <span>
            <span class="src">
                That said, mixing signedness of integer types is responsible for an
                equally large class of problems.
            </span>
            これらのことから、<code>signed</code>整数型と<code>unsigned</code>整数型を混在させてしまうと、それもまた同様に様々なバグの要因となります。
        </span>
        <span>
            <span class="src">
                The best advice we can provide: try
                to use iterators and containers rather than pointers and sizes, try
                not to mix signedness, and try to avoid unsigned types (except for
                representing bitfields or modular arithmetic).
            </span>
            ここでの最大限のアドバイスとしては、「コンテナについて、ポインタやサイズではなく、イテレータを使うようにする」「<code>signed</code>整数型と<code>unsigned</code>整数型が混在しないようにする」「そもそも、(ビットフィールドと合同演算を行いたい以外で)<code>unsigned</code>整数型を使うのを避ける」というところです。
        </span>
        <span>
            <span class="src">
                Do not use an unsigned
                type merely to assert that a variable is non-negative.
            </span>
            変数が常に非負であることを主張する目的では、その程度のことで<code>unsigned</code>型を使ってはいけません。
        </span>
    </p>

    <h3 id="64-bit_Portability"><span title="64-bit Portability">64ビットへの移植性</span></h3>

    <p>
        <span>
            <span class="src">
                Code should be 64-bit and 32-bit friendly.
            </span>
            コードは64ビットと32ビットの両方にフレンドリーであるべきです。
        </span>
        <span>
            <span class="src">
                Bear in mind
                problems of printing, comparisons, and structure alignment.
            </span>
            printするときの問題、比較するときの問題、構造体のアラインメントの問題を常に心にとめておいてください。
        </span>
    </p>

    <ul>
        <li>
            <p>
                <span>
                    <span class="src">
                        Correct portable <code>printf()</code> conversion specifiers for
                        some integral typedefs rely on macro expansions that we find unpleasant to
                        use and impractical to require (the <code>PRI</code> macros from
                        <code>&lt;cinttypes&gt;</code>).
                    </span>
                    整数型とその<code>typedef</code>に対する、正しく移植性のある<code>printf()</code>の書式指定子については、<code>&lt;cinttypes&gt;</code>に含まれる<code>PRI</code>マクロ群に頼ることになります。しかし、これらは些か不格好であり、使用を必須とするのもあまり現実的ではありません。
                </span>
                <span>
                    <span class="src">
                        Unless there is no reasonable alternative
                        for your particular case, try to avoid or even upgrade APIs that rely on the
                        <code>printf</code> family.
                    </span>
                    合理的な代替手段がないときを除き、なるべく<code>printf</code>ファミリに依存するAPIを使うのは避け、あるいは、それらのAPIのアップグレードを試みてください。
                </span>
                <span>
                    <span class="src">
                        Instead use a library supporting typesafe numeric
                        formatting, such as
                        <a href="https://github.com/abseil/abseil-cpp/blob/master/absl/strings/str_cat.h"><code>StrCat</code></a>
                        or
                        <a href="https://github.com/abseil/abseil-cpp/blob/master/absl/strings/substitute.h"><code>Substitute</code></a>
                        for fast simple conversions,

                        or <a href="#Streams"><code>std::ostream</code></a>.
                    </span>
                    <code>printf</code>のかわりとして、型安全な数値フォーマットが可能なライブラリ、たとえば、<a href="https://github.com/abseil/abseil-cpp/blob/master/absl/strings/str_cat.h"><code>StrCat</code></a>や、
                    高速でシンプルな変換には<a href="https://github.com/abseil/abseil-cpp/blob/master/absl/strings/substitute.h"><code>Substitute</code></a>、
                    もしくは、<a href="#Streams"><code>std::ostream</code></a>などを使ってください。
                </span>
            </p>

            <p>
                <span>
                    <span class="src">
                        Unfortunately, the <code>PRI</code> macros are the only portable way to
                        specify a conversion for the standard bitwidth typedefs (e.g.,
                        <code>int64_t</code>, <code>uint64_t</code>, <code>int32_t</code>,
                        <code>uint32_t</code>, etc).
                    </span>
                    残念ながら、サイズが厳密に決められている整数型(<code>int64_t</code>, <code>uint64_t</code>, <code>int32_t</code>, <code>uint32_t</code>等)を文字列変換する方法として、唯一、移植性を保つことができるのは<code>PRI</code>系マクロを用いる方法だけです。
                </span>
                <span>
                    <span class="src">
                        Where possible, avoid passing arguments of types specified by bitwidth
                        typedefs to <code>printf</code>-based APIs.
                    </span>
                    可能であれば、このようなサイズ固定の整数型を<code>printf</code>系のAPIに渡すこと自体を避けてください。
                </span>
                <span>
                    <span class="src">
                        Note that it is acceptable
                        to use typedefs for which printf has dedicated length modifiers, such as
                        <code>size_t</code> (<code>z</code>),
                        <code>ptrdiff_t</code> (<code>t</code>), and
                        <code>maxint_t</code> (<code>j</code>).
                    </span>
                    なお、<code>printf</code>で、専用の長さ指定子が定められている型を用いるのはかまいません。たとえば、
                    <code>size_t</code>に対する<code>z</code>、
                    <code>ptrdiff_t</code>に対する<code>t</code>、
                    <code>maxint_t</code>に対する<code>j</code>などがこれにあたります。
                </span>
            </p>
        </li>
        <li>
            <span>
                <span class="src">
                    Remember that <code>sizeof(void *)</code> !=
                    <code>sizeof(int)</code>.
                </span>
                <code>sizeof(void *)</code> != <code>sizeof(int)</code>であることを忘れないでください。
            </span>
            <span>
                <span class="src">
                    Use <code>intptr_t</code> if
                    you want a pointer-sized integer.
                </span>
                ポインタと同じサイズの整数型が必要なときは、<code>intptr_t</code>を使ってください。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    You may need to be careful with structure
                    alignments, particularly for structures being stored on
                    disk.
                </span>
                構造体のアラインメントには注意が必要です。
                特にその構造体がディスクに保存される場合にこのことは重要です。
            </span>
            <span>
                <span class="src">
                    Any class/structure with a
                    <code>int64_t</code>/<code>uint64_t</code>
                    member will by default end up being 8-byte aligned on a
                    64-bit system.
                </span>
                64ビットシステムでは、<code>int64_t</code>や<code>uint64_t</code>を含むクラスや構造体は、デフォルトで8バイト境界にアラインメントされます。
            </span>
            <span>
                <span class="src">
                    If you have such structures being shared
                    on disk between 32-bit and 64-bit code, you will need
                    to ensure that they are packed the same on both
                    architectures.
                </span>
                もし、このような構造体をディスクに保存し、32ビットコードと64ビットコードとの間で共有するような場合は、双方のアーキテクチャにおいて構造体が同じようにパックされることを保証する必要があるでしょう。
            </span>
            <span>
                <span class="src">
                    Most compilers offer a way to
                    alter structure alignment.
                </span>
                ほとんどのコンパイラにおいて、構造体のアラインメントを変更する手段が提供されています。
            </span>
            <span>
                <span class="src">
                    For gcc, you can use
                    <code>__attribute__((packed))</code>.
                </span>
                たとえば、GCCでは<code>__attribute__((packed))</code>を使うことができますし、
            </span>
            <span>
                <span class="src">
                    MSVC offers
                    <code>#pragma pack()</code> and
                    <code>__declspec(align())</code>.
                </span>
                MSVCは<code>#pragma pack()</code>と<code>__declspec(align())</code>を提供しています。
            </span>
        </li>

        <li>
            <p>
                <span>
                    <span class="src">
                        Use <a href="#Casting">braced-initialization</a> as needed to create
                        64-bit constants. For example:
                    </span>
                    64ビット定数を作るためには、次の例のように、波括弧初期化を使ってください。
                </span>
            </p>
            <pre>int64_t my_value{0x123456789};
uint64_t my_mask{uint64_t{3} &lt;&lt; 48};
</pre>
        </li>
    </ul>


    <h3 id="Preprocessor_Macros"><span title="Preprocessor Macros">プリプロセッサマクロ</span></h3>

    <p>
        <span>
            <span class="src">
                Avoid defining macros, especially in headers; prefer
                inline functions, enums, and <code>const</code> variables.
            </span>
            マクロを定義しないでください。
            特にヘッダーではマクロを定義しないでください。
            かわりに、インライン関数や、列挙型、<code>const</code>変数を用いましょう。
        </span>
        <span>
            <span class="src">
                Name macros with a project-specific prefix.
            </span>
            マクロの名前にはプロジェクト固有の接頭辞(接頭辞)をつけます。
        </span>
        <span>
            <span class="src">
                Do not use
                macros to define pieces of a C++ API.
            </span>
            C++ APIの定義としてマクロを使ってはいけません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Macros mean that the code you see is not the same as
                the code the compiler sees.
            </span>
            マクロを使うと、あなたが見ているコードと、コンパイラが見ているコードとが同じではなくなります。
        </span>
        <span>
            <span class="src">
                This can introduce unexpected
                behavior, especially since macros have global scope.
            </span>
            このことは、(特にマクロはグローバルスコープを持つため、)予期せぬ挙動を招くことがあります。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                The problems introduced by macros are especially severe
                when they are used to define pieces of a C++ API,
                and still more so for public APIs.
            </span>
            マクロによって引き起こされる問題は、マクロがC++のAPIの一部として定義されているとき、さらに、それらが公開APIであるときに、特に深刻になります。
        </span>
        <span>
            <span class="src">
                Every error message from
                the compiler when developers incorrectly use that interface
                now must explain how the macros formed the interface.
            </span>
            開発者がインターフェースを誤って使用した場合に、コンパイラが生成する各エラーメッセージで、インターフェースがマクロによってどう形成されているのかを説明していなければなりません。
        </span>
        <span>
            <span class="src">
                Refactoring and analysis tools have a dramatically harder
                time updating the interface.
            </span>
            また、マクロを使うと、リファクタリングツールや解析ツールにおいて、インターフェースを更新するために、劇的な時間が掛かるようになります。
        </span>
        <span>
            <span class="src">
                As a consequence, we
                specifically disallow using macros in this way.
            </span>
            結論として、この用途でのマクロは明確に禁止とします。
        </span>
        <span>
            <span class="src">
                For example, avoid patterns like:
            </span>
            たとえば、次のようなパターンは避けてください。
        </span>
    </p>

    <pre class="badcode">class WOMBAT_TYPE(Foo) {
  // ...

 public:
  EXPAND_PUBLIC_WOMBAT_API(Foo)

  EXPAND_WOMBAT_COMPARISONS(Foo, ==, &lt;)
};
</pre>

    <p>
        <span>
            <span class="src">
                Luckily, macros are not nearly as necessary in C++ as
                they are in C.
            </span>
            幸いなことに、C++ではC言語に比べてほとんどマクロを必要としません。
        </span>
        <span>
            <span class="src">
                Instead of using a macro to inline
                performance-critical code, use an inline function.
            </span>
            パフォーマンスクリティカルなコードをインライン化する目的では、マクロではなく、インライン関数を使うことができます。
        </span>
        <span>
            <span class="src">
                Instead of using a macro to store a constant, use a
                <code>const</code> variable.
            </span>
            定数を保持するためには、マクロではなく、<code>const</code>変数を使うことができます。
        </span>
        <span>
            <span class="src">
                Instead of using a macro to
                "abbreviate" a long variable name, use a reference.
            </span>
            長い名前の変数への省略形を作るためには、マクロではなく、参照を使うことができます。
        </span>
        <span>
            <span class="src">
                Instead of using a macro to conditionally compile code
                ... well, don't do that at all (except, of course, for
                the <code>#define</code> guards to prevent double
                inclusion of header files).
            </span>
            条件によってコンパイルされるコードを変えるためには、マクロではなく……いや、そもそも、そのようなことはしないでください(もちろん、ヘッダファイルにおけるインクルードガードは例外です)。
        </span>
        <span>
            <span class="src">
                It makes testing much more
                difficult.
            </span>
            そのようなことをすると、テストが非常に難しくなります。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Macros can do things these other techniques cannot,
                and you do see them in the codebase, especially in the
                lower-level libraries.
            </span>
            マクロは、他の手段では不可能なことを実現します。
            既存のコードベースでは、特に低レベルライブラリにおいて、それらを見かけることがあるでしょう。
        </span>
        <span>
            <span class="src">
                And some of their special features
                (like stringifying, concatenation, and so forth) are not
                available through the language proper.
            </span>
            また、マクロを使えば、たとえば、シンボルの文字列化や連結などの、言語系では提供されていない特殊な機能を利用することもできます。
        </span>
        <span>
            <span class="src">
                But before using a
                macro, consider carefully whether there's a non-macro way
                to achieve the same result.
            </span>
            それでも、マクロを使う前に、それ以外の方法で同様のことが実現できないか、よくよく検討してください。
        </span>
        <span>
            <span class="src">
                If you need to use a macro to
                define an interface, contact
                your project leads to request
                a waiver of this rule.
            </span>
            どうしてもマクロを使ってインターフェースを定義しなければならないときには、このルールの放棄について、プロジェクトリーダーと相談してください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                The following usage pattern will avoid many problems
                with macros; if you use macros, follow it whenever
                possible:
            </span>
            マクロを使うときは以下に示すパターンに従うと、それにまつわる多くの問題を避けることができます。もし、マクロを使うのであれば、可能な限りこれらに従ってください。
        </span>
    </p>

    <ul>
        <li>
            <span>
                <span class="src">
                    Don't define macros in a <code>.h</code> file.
                </span>
                <code>.h</code>ファイル内ではマクロを定義してはいけません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <code>#define</code> macros right before you use
                    them, and <code>#undef</code> them right after.
                </span>
                マクロは、使う直前に<code>#define</code>し、使い終わったらすぐに<code>#undef</code>してください。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Do not just <code>#undef</code> an existing macro
                    before replacing it with your own; instead, pick a name
                    that's likely to be unique.
                </span>
                既存のマクロを自分のものに置き換える目的で<code>#undef</code>してはいけません。かわりに、あなたのマクロにユニークな名前をつけてください。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Try not to use macros that expand to unbalanced C++
                    constructs, or at least document that behavior
                    well.
                </span>
                アンバランスなC++の構造に展開されるマクロを使うのは避けてください。
                あるいは、少なくとも、その挙動について十分にドキュメントを記述してください。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Prefer not using <code>##</code> to generate
                    function/class/variable names.
                </span>
                関数名やクラス名、変数名を生成するために<code>##</code>を使うのはやめましょう。
            </span>
        </li>
    </ul>

    <p>
        <span>
            <span class="src">
                Exporting macros from headers (i.e., defining them in a header
                without <code>#undef</code>ing them before the end of the header)
                is extremely strongly discouraged.
            </span>
            ヘッダーからマクロをエクスポートすること(すなわち、ヘッダーでマクロを定義し、そのまま<code>#undef</code>しないこと)は、まったく非常に強く非推奨です。
        </span>
        <span>
            <span class="src">
                If you do export a macro from a
                header, it must have a globally unique name.
            </span>
            どうしても、ヘッダーからマクロをエクスポートする場合は、必ずグローバルにユニークな名前をつけてください。
        </span>
        <span>
            <span class="src">
                To achieve this, it
                must be named with a prefix consisting of your project's namespace
                name (but upper case).
            </span>
            これを達成するために、マクロの名前には、そのプロジェクトのnamespaceの名前をすべて大文字にして接頭辞としてつけるようにしてください。
        </span>
    </p>
    <h3 id="0_and_nullptr/NULL"><span title="0 and nullptr/NULL"><code>0</code>と<code>nullptr</code>と<code>NULL</code></span></h3>

    <p>
        <span>
            <span class="src">
                Use <code>nullptr</code> for pointers, and <code>'\0'</code> for chars (and
                not the <code>0</code> literal).
            </span>
            ポインタには<code>nullptr</code>、文字には<code>'\0'</code>を使います。これらの目的でリテラルの<code>0</code>は使いません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                For pointers (address values), use <code>nullptr</code>, as this
                provides type-safety.
            </span>
            ポインタ(アドレス値)には、<code>nullptr</code>を使ってください。<code>nullptr</code>ならば型安全です。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Use <code>'\0'</code> for the null character.
            </span>
            ヌル文字には<code>'\0'</code>を使ってください。
        </span>
        <span>
            <span class="src">
                Using the correct type makes
                the code more readable.
            </span>
            正しい型を使うことで、コードがより読みやすくなります。
        </span>
    </p>
    <h3 id="sizeof"><span title="sizeof"><code>sizeof</code></span></h3>

    <p>
        <span>
            <span class="src">
                Prefer <code>sizeof(<var>varname</var>)</code> to
                <code>sizeof(<var>type</var>)</code>.
            </span>
            <code>sizeof(<var>型</var>)</code>よりも<code>sizeof(<var>変数名</var>)</code>の形を使いましょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Use <code>sizeof(<var>varname</var>)</code> when you
                take the size of a particular variable.
            </span>
            具体的な変数のサイズを知りたいときには<code>sizeof(<var>変数名</var>)</code>とします。
        </span>
        <span>
            <span class="src">
                <code>sizeof(<var>varname</var>)</code> will update
                appropriately if someone changes the variable type either
                now or later.
            </span>
            <code>sizeof(<var>変数名</var>)</code>の形を使っていれば、将来、変数の型が変更された場合でも、適切に追従することができます。
        </span>
        <span>
            <span class="src">
                You may use
                <code>sizeof(<var>type</var>)</code> for code unrelated
                to any particular variable, such as code that manages an
                external or internal data format where a variable of an
                appropriate C++ type is not convenient.
            </span>
            一方で、コードが具体的な変数に結びつかないときには<code>sizeof(<var>型</var>)</code>の形を使ってもかまいません。
            たとえば、以下の例のように、適切なC++の型の変数を用いてしまっては不便な、外部または内部のデータフォーマットそのものを扱う場合などがあてはまります。
        </span>
    </p>
    <pre>MyStruct data;
memset(&amp;data, 0, sizeof(data));
</pre>

    <div>
        <div class="src">
            <pre class="badcode">memset(&amp;data, 0, sizeof(MyStruct));
</pre>
        </div>
        <pre class="badcode">memset(&amp;data, 0, sizeof(MyStruct));  // これは避ける
</pre>
    </div>

    <pre>if (raw_size &lt; sizeof(int)) {
  LOG(ERROR) &lt;&lt; "compressed record not big enough for count: " &lt;&lt; raw_size;
  return false;
}
</pre>

    <a id="auto"></a>
    <h3 id="Type_deduction"><span title="Type Deduction (including auto)">型推論(<code>auto</code>を含む)</span></h3>


    <p>
        <span>
            <span class="src">
                Use type deduction only if it makes the code clearer to readers who aren't
                familiar with the project, or if it makes the code safer.
            </span>
            型推論は、型推論によってプロジェクトに不慣れなコード読者にとってコードが読みやすくなることを期待できる場合や、型推論によってコードをより安全にできる場合に限って使います。
        </span>
        <span>
            <span class="src">
                Do not use it
                merely to avoid the inconvenience of writing an explicit type.
            </span>
            明示的に型を記述するのが面倒だからという理由で型推論を使ってはいけません。
        </span>
    </p>

    <p class="definition">
    </p>

    <p>
        <span>
            <span class="src">
                There are several contexts in which C++ allows (or even requires) types to
                be deduced by the compiler, rather than spelled out explicitly in the code:
            </span>
            C++では、いくつかの文脈において、型を明示するかわりにコンパイラによって型が推論されることを許す(あるいは、そうしなければならない)ことがあります。
        </span>
    </p>
    <dl>
        <dt>
            <span>
                <span class="src">
                    <a href="https://en.cppreference.com/w/cpp/language/template_argument_deduction">Function template argument deduction</a>
                </span>
                <a href="https://en.cppreference.com/w/cpp/language/template_argument_deduction">関数テンプレートの実引数推論</a>
            </span>
        </dt>
        <dd>
            <span>
                <span class="src">
                    A function template can be invoked without explicit template arguments.
                </span>
                関数テンプレートは、明示的にテンプレート引数を与えずとも呼び出すことができます。
            </span>
            <span>
                <span class="src">
                    The compiler deduces those arguments from the types of the function
                    arguments:
                </span>
                コンパイラは、これらの引数を関数に渡された実引数の型からテンプレート引数を推論します。
            </span>
            <div>
                <div class="src"><pre class="neutralcode">template &lt;typename T&gt;
void f(T t);

f(0);  // Invokes f&lt;int&gt;(0)</pre></div><pre class="neutralcode">template &lt;typename T&gt;
void f(T t);
    
f(0);  // f&lt;int&gt;(0) を呼び出す</pre></div>
        </dd>
        <dt>
            <span>
                <span class="src">
                    <a href="https://en.cppreference.com/w/cpp/language/auto"><code>auto</code> variable declarations</a>
                </span>
                <a href="https://en.cppreference.com/w/cpp/language/auto"><code>auto</code>変数宣言</a>
            </span>
        </dt>
        <dd>
            <span>
                <span class="src">
                    A variable declaration can use the <code>auto</code> keyword in place
                    of the type.
                </span>
                変数宣言では、型のかわりに<code>auto</code>キーワードを使うことができます。
            </span>

            <span>
                <span class="src">
                    The compiler deduces the type from the variable's
                    initializer, following the same rules as function template argument
                    deduction with the same initializer (so long as you don't use curly braces
                    instead of parentheses).
                </span>
                コンパイラは、変数の初期化子から、関数テンプレートの実引数推論と同じ規則に従って変数の型を推論します(丸括弧のかわりに波括弧を使用しない限り)。
            </span>
            <div><div class="src"><pre class="neutralcode">auto a = 42;  // a is an int
auto&amp; b = a;  // b is an int&amp;
auto c = b;   // c is an int
auto d{42};   // d is an int, not a std::initializer_list&lt;int&gt;</pre></div><pre class="neutralcode">auto a = 42;  // a は int型
auto&amp; b = a;  // b は int&amp;型
auto c = b;   // c は int型
auto d{42};   // d は int型 ※ std::initializer_list&lt;int&gt;ではない</pre></div>
            <span>
                <span class="src">
                    <code>auto</code> can be qualified with <code>const</code>, and can be
                    used as part of a pointer or reference type, but it can't be used as a
                    template argument.
                </span>
                <code>auto</code>は<code>const</code>で修飾することができ、また、ポインタまたは参照型の一部として用いることもできますが、テンプレート引数にはできません。
            </span>
            <span>
                <span class="src">
                    A rare variant of this syntax uses
                    <code>decltype(auto)</code> instead of <code>auto</code>, in which case
                    the deduced type is the result of applying
                    <a href="https://en.cppreference.com/w/cpp/language/decltype"><code>decltype</code></a>
                    to the initializer.
                </span>
                また、この文法のまれに登場する変種として、<code>auto</code>のかわりに<code>decltype(auto)</code>というものもあります。
                <code>decltype(auto)</code>を使った場合は、初期化子を<a href="https://en.cppreference.com/w/cpp/language/decltype"><code>decltype</code></a>に渡したときに行われる型推論と同じ規則に従って、その結果の型に解決されることになります。
            </span>
        </dd>
        <dt>
            <span>
                <span class="src">
                    <a href="https://en.cppreference.com/w/cpp/language/function#Return_type_deduction">Function return type deduction</a>
                </span>
                <a href="https://en.cppreference.com/w/cpp/language/function#Return_type_deduction">関数戻り値の型推論</a>
            </span>
        </dt>
        <dd>
            <span>
                <span class="src">
                    <code>auto</code> (and <code>decltype(auto)</code>) can also be used in
                    place of a function return type.
                </span>
                <code>auto</code> (と<code>decltype(auto)</code>)は、関数の戻り値の型として用いることもできます。
            </span>
            <span>
                <span class="src">
                    The compiler deduces the return type from
                    the <code>return</code> statements in the function body, following the same
                    rules as for variable declarations:
                </span>
                コンパイラは、関数本体の<code>return</code>文から、変数宣言のときと同じ規則に従って、戻り値の型を推論します。
            </span>
            <div>
                <div class="src">
                    <pre class="neutralcode">auto f() { return 0; }  // The return type of f is int</pre>
                </div>
                <pre class="neutralcode">auto f() { return 0; }  // f の戻り値の型は int</pre>
            </div>

            <span>
                <span class="src">
                    <a href="#Lambda_expressions">Lambda expression</a> return types can be
                    deduced in the same way, but this is triggered by omitting the return type,
                    rather than by an explicit <code>auto</code>.
                </span>
                <a href="#Lambda_expressions">ラムダ式</a>の戻り値の型も同じ方法で推論させることができます。
                ただし、ラムダ式の場合は、明示的な<code>auto</code>ではなく、単に戻り値の型を省略したときに型推論が行われます。
            </span>
            <span>
                <span class="src">
                    Confusingly,
                    <a href="#trailing_return">trailing return type</a> syntax for functions
                    also uses <code>auto</code> in the return-type position, but that doesn't
                    rely on type deduction; it's just an alternate syntax for an explicit
                    return type.
                </span>
                なお、<a href="#trailing_return">関数宣言の末尾に戻り値の型を書く構文</a>でも戻り値の型の位置に<code>auto</code>が置かれます。
                紛らわしいですが、これは、戻り値の型が明示された別の形の構文にすぎず、この<code>auto</code>は型推論とは関係がありません。
            </span>
        </dd>
        <dt>
            <span>
                <span class="src">
                    <a href="https://isocpp.org/wiki/faq/cpp14-language#generic-lambdas">Generic lambdas</a>
                </span>
                <a href="https://isocpp.org/wiki/faq/cpp14-language#generic-lambdas">ジェネリックラムダ</a>
            </span>
        </dt>
        <dd>
            <span>
                <span class="src">
                    A lambda expression can use the <code>auto</code> keyword in place of
                    one or more of its parameter types.
                </span>
                ラムダ式では、1つ以上の仮引数の型のかわりに<code>auto</code>キーワードを用いることができます。
            </span>
            <span>
                <span class="src">
                    This causes the lambda's call operator
                    to be a function template instead of an ordinary function, with a separate
                    template parameter for each <code>auto</code> function parameter:
                </span>
                ラムダ式で、1つ以上<code>auto</code>仮引数を宣言すると、その関数呼び出し演算子(<code>operator()</code>)が通常の関数ではなく関数テンプレートとなり、
                各<code>auto</code>仮引数ごとに個別のテンプレート引数が割り当てられます。
            </span>
            <div>
                <div class="src">
                    <pre class="neutralcode">// Sort `vec` in decreasing order
std::sort(vec.begin(), vec.end(), [](auto lhs, auto rhs) { return lhs &gt; rhs; });</pre>
                </div>
                <pre class="neutralcode">// `vec` を降順ソート
std::sort(vec.begin(), vec.end(), [](auto lhs, auto rhs) { return lhs &gt; rhs; });</pre>
            </div>

            
        </dd>
        <dt>
            <span>
                <span class="src">
                    <a href="https://isocpp.org/wiki/faq/cpp14-language#lambda-captures">Lambda init captures</a>
                </span>
                <a href="https://isocpp.org/wiki/faq/cpp14-language#lambda-captures">ラムダの初期化キャプチャ</a>
            </span>
        </dt>
        <dd>
            <span>
                <span class="src">
                    Lambda captures can have explicit initializers, which can be used to
                    declare wholly new variables rather than only capturing existing ones:
                </span>
                ラムダのキャプチャでは、既存変数をキャプチャできるだけではなく、明示的な初期化子を与えることで、まったく新しい変数を宣言することもできます。
            </span>
            <div>
                <div class="src">
                    <pre class="neutralcode">[x = 42, y = "foo"] { ...
}  // x is an int, and y is a const char*</pre>
                </div>
                <pre class="neutralcode">[x = 42, y = "foo"] { ...
}  // x は int で、y は const char*</pre>
            </div>
            
            <span>
                <span class="src">
                    This syntax doesn't allow the type to be specified; instead, it's deduced
                    using the rules for <code>auto</code> variables.
                </span>
                この構文において、変数の型を明示的に指定することはできません。かわりに<code>auto</code>変数宣言時のルールに従って型推論が行われます。
            </span>
        </dd>
        <dt>
            <span>
                <span class="src">
                    <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">Class template argument deduction</a>
                </span>
                <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">クラス テンプレートの引数推論</a>
            </span>
        </dt>
        <dd>
            <span>
                <span class="src">
                    See <a href="#CTAD">below</a>.
                </span>
                これについては、<a href="#CTAD">後述します</a>。
            </span>
        </dd>
        <dt>
            <span>
                <span class="src">
                    <a href="https://en.cppreference.com/w/cpp/language/structured_binding">Structured bindings</a>
                </span>
                <a href="https://en.cppreference.com/w/cpp/language/structured_binding">構造化束縛</a>
            </span>
        </dt>
        <dd>
            <span>
                <span class="src">
                    When declaring a tuple, struct, or array using <code>auto</code>, you can
                    specify names for the individual elements instead of a name for the whole
                    object; these names are called "structured bindings", and the whole
                    declaration is called a "structured binding declaration".
                </span>
                <code>auto</code>を使ってタプルや構造体や配列を宣言するとき、オブジェクト全体に名前をつけるかわりに、個々の要素に名前をつけることもできます。
                これらの名前のことを「構造化束縛(structured binding)」と呼び、その宣言全体を「構造化束縛宣言(structured binding declaration)」と呼びます。
            </span>
            <span>
                <span class="src">
                    This syntax
                    provides no way of specifying the type of either the enclosing object
                    or the individual names:
                </span>
                この構文においては、全体を囲むオブジェクトの型も、個々の要素の型も、いずれも明示的に指定する方法はありません。
            </span>
            <pre class="neutralcode">auto [iter, success] = my_map.insert({key, value});
if (!success) {
    iter-&gt;second = value;
}</pre>
            <span>
                <span class="src">
                    The <code>auto</code> can also be qualified with <code>const</code>,
                    <code>&amp;</code>, and <code>&amp;&amp;</code>, but note that these qualifiers
                    technically apply to the anonymous tuple/struct/array, rather than the
                    individual bindings.
                </span>
                この<code>auto</code>は、<code>const</code>、<code>&amp;</code>、および <code>&amp;&amp;</code>で修飾することもできます。ただし、これらの修飾子は、技術的には、個々の要素に対してではなく、その宣言で作られる無名のタプルや構造体、配列そのものに適用されていることに注意してください。
            </span>
            <span>
                <span class="src">
                    The rules that determine the types of the bindings
                    are quite complex; the results tend to be unsurprising, except that
                    the binding types typically won't be references even if the declaration
                    declares a reference (but they will usually behave like references anyway).
                </span>
                これらの束縛変数の型を決定するルールはかなり複雑です。
                結果的には、概ね想像通りの挙動にはなるのですが、構造化束縛宣言が参照である場合であっても、各々の束縛変数の型は参照型にはならないことには注意が必要です(ただし、いずれにせよ、それらは参照であるかのように振る舞います)。
            </span>
        </dd>
    </dl>

    <p>
        <span>
            <span class="src">
                (These summaries omit many details and caveats; see the links for further
                information.)
            </span>
            (ここまでの要約においては、多くの詳細と注釈すべき事項が割愛されています。より詳しい知識を得るべく、各リンク先も参照するようにしてください)
        </span>
    </p>

    <p class="pros"></p>
    <ul>
        <li>
            <span>
                <span class="src">
                    C++ type names can be long and cumbersome, especially when they
                    involve templates or namespaces.
                </span>
                C++の型名は、長く、扱いにくいものになることがあります。特にテンプレートや名前空間が絡んだときには顕著です。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    When a C++ type name is repeated within a single declaration or a
                    small code region, the repetition may not be aiding readability.
                </span>
                C++の型名は、1つの宣言や小さなコードブロックの中で何度も繰り返されることがありますが、そのような繰り返しが可読性の助けになることはありません。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    It is sometimes safer to let the type be deduced, since that avoids
                    the possibility of unintended copies or type conversions.
                </span>
                意図しないコピーや型変換の可能性を避けるために、むしろ型を推論させる方が安全な場合もあります。
            </span>
        </li>
    </ul>

    <p class="cons"></p>

    <p>
        <span>
            <span class="src">
                C++ code is usually clearer when types are explicit,
                especially when type deduction would depend on information from
                distant parts of the code.
            </span>
            C++のコードは、通常は、型が明示されている方が明確でわかりやすいものになります。
            特に、型推論のために必要な情報が、コードの離れた場所に位置していると、コードを理解しにくくなることがあります。
        </span>
        <span>
            <span class="src">
                In expressions
                like:
            </span>
            次のような例を考えてみましょう。
        </span>
    </p>

    <pre class="badcode">auto foo = x.add_foo();
auto i = y.Find(key);
</pre>

    <p>
        <span>
            <span class="src">
                it may not be obvious what the resulting types are if the type
                of <code>y</code> isn't very well known, or if <code>y</code> was
                declared many lines earlier.
            </span>
            このコードにおいて、<code>y</code>の型が十分有名でなかったり、あるいは、<code>y</code>が何十行も前に宣言されていたりすると、結果の型が何であるかは明確でなくなります。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Programmers have to understand when type deduction will or won't
                produce a reference type, or they'll get copies when they didn't
                mean to.
            </span>
            また、プログラマーは、型推論によってどの場合に参照型が生成され、どの場合に通常の型が生成されるのか、しっかり理解していなければなりません。さもなくば、意図せずオブジェクトのコピーを得ることになるでしょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                If a deduced type is used as part of an
                interface, then a
                programmer might change its type while only intending to
                change its value, leading to a more radical API change
                than intended.
            </span>
            型推論がインターフェースの一部として使われてしまっている場合、プログラマーはその値だけを変えるつもりで、うっかり、型をも変えてしまうかもしれません。これによって、本来意図したよりも大きなAPIの変更を招いてしまうかもしれません。
        </span>
    </p>

    <p class="decision">
    </p>

    <p>
        <span>
            <span class="src">
                The fundamental rule is: use type deduction only to make the code
                clearer or safer, and do not use it merely to avoid the
                inconvenience of writing an explicit type.
            </span>
            基本的なルールとして、型推論は、型推論によってコードが明確になる、もしくは、安全になるというときに限って使用するようにしましょう。型を明示的に記述するのが面倒だ、という理由で使ってはいけません。
        </span>
        <span>
            <span class="src">
                When judging whether the
                code is clearer, keep in mind that your readers are not necessarily
                on your team, or familiar with your project, so types that you and
                your reviewer experience as unnecessary clutter will very often
                provide useful information to others.
            </span>
            コードが明確であるかどうかの判定基準を考えるときには、コードの読者として、同じチームに属しているわけでも、プロジェクトに詳しいわけでもない人を想定してください。
            コードの著者やレビュアーにとっては無用に散らかっているように感じられる型の記述であっても、他の人たちにとっては有益な情報源となっていることはよくあるケースです。
        </span>
        <span>
            <span class="src">
                For example, you can assume that
                the return type of <code>make_unique&lt;Foo&gt;()</code> is obvious,
                but the return type of <code>MyWidgetFactory()</code> probably isn't.
            </span>
            たとえば、<code>std::make_unique&lt;Foo&gt;()</code>の戻り値の型は明確であると見なせますが、<code>MyWidgetFactory()</code>の戻り値の型が明確であるとはおそらく言えないでしょう。
        </span>
    </p>
    <p>
        <span>
            <span class="src">
                These principles apply to all forms of type deduction, but the
                details vary, as described in the following sections.
            </span>
            これらの原則は、すべての形の型推論に当てはまりますが、細かいところで異なる点もあるため、以降のセクションで詳しく説明していきます。
        </span>
    </p>

    <h4 title="Function template argument deduction">関数テンプレートの引数推論</h4>
    <p>
        <span>
            <span class="src">
                Function template argument deduction is almost always OK.
            </span>
            関数テンプレート引数の型推論は、ほとんどの場合において問題ありません。
        </span>
        <span>
            <span class="src">
                Type deduction
                is the expected default way of interacting with function templates,
                because it allows function templates to act like infinite sets of ordinary
                function overloads.
            </span>
            関数テンプレートにおいては、型推論を用いることがむしろ通常の方法として想定されており、それによって、関数テンプレートが無限のオーバーロードを持つ関数集合であるかのように振る舞わせることができるようになります。
        </span>
        <span>
            <span class="src">
                Consequently, function templates are almost always
                designed so that template argument deduction is clear and safe, or
                doesn't compile.
            </span>
            したがって、関数テンプレートでは、ほとんど常に、そのテンプレート引数を明確かつ安全に推論できるか、さもなくばコンパイルエラーになるように設計されています。
        </span>
    </p>

    <h4 title="Local variable type deduction">ローカル変数の型推論</h4>
    <p>
        <span>
            <span class="src">
                For local variables, you can use type deduction to make the code clearer
                by eliminating type information that is obvious or irrelevant, so that
                the reader can focus on the meaningful parts of the code:
            </span>
            ローカル変数については、明確あるいは不適切な型に関する情報を省き、それによってコードをより明確にできるときに、型推論を用いてもかまいません。
            これによって、コード読者がコードの本質的な部分に集中できるようになります。次の2つの例を見比べてみてください。
        </span>
    </p>
    <pre class="neutralcode">std::unique_ptr&lt;WidgetWithBellsAndWhistles&gt; widget =
    std::make_unique&lt;WidgetWithBellsAndWhistles&gt;(arg1, arg2);
absl::flat_hash_map&lt;std::string,
                    std::unique_ptr&lt;WidgetWithBellsAndWhistles&gt;&gt;::const_iterator
    it = my_map_.find(key);
std::array&lt;int, 6&gt; numbers = {4, 8, 15, 16, 23, 42};</pre>

    <pre class="goodcode">auto widget = std::make_unique&lt;WidgetWithBellsAndWhistles&gt;(arg1, arg2);
auto it = my_map_.find(key);
std::array numbers = {4, 8, 15, 16, 23, 42};</pre>

    <p>
        <span>
            <span class="src">
                Types sometimes contain a mixture of useful information and boilerplate,
                such as <code>it</code> in the example above: it's obvious that the
                type is an iterator, and in many contexts the container type and even the
                key type aren't relevant, but the type of the values is probably useful.
            </span>
            型には、上述の例における<code>it</code>のように、有益な情報とただの定型文との両方が混在していることがあります。
            <code>it</code>がイテレータ型であることは明確ですし、多くの文脈でコンテナの型や、ときにはキーの型さえも不要な情報ですが、値の型に関しての情報は有益となるかもしれません。
        </span>
        <span>
            <span class="src">
                In such situations, it's often possible to define local variables with
                explicit types that convey the relevant information:
            </span>
            このような状況では、大抵の場合、型を明示したローカル変数を定義することによって、関連する情報を伝えることができます。
        </span>
    </p>
                <div>
                <div class="src">
                    <pre class="goodcode">if (auto it = my_map_.find(key); it != my_map_.end()) {
    WidgetWithBellsAndWhistles&amp; widget = *it-&gt;second;
    // Do stuff with `widget`
}</pre>
                </div>
                <pre class="goodcode">if (auto it = my_map_.find(key); it != my_map_.end()) {
    WidgetWithBellsAndWhistles&amp; widget = *it-&gt;second;
    // `widget`に関する操作を行う
}</pre>
            </div>
    
    <p>
        <span>
            <span class="src">
                If the type is a template instance, and the parameters are
                boilerplate but the template itself is informative, you can use
                class template argument deduction to suppress the boilerplate.
            </span>
            型がテンプレートインスタンスであって、その引数はただのボイラープレートであるがテンプレート自体の名前には有益な情報を含むような場合には、クラステンプレートの実引数推論を利用して、ボイラープレートの部分を抑制することができます。
        </span>
        <span>
            <span class="src">
                However,
                cases where this actually provides a meaningful benefit are quite rare.
            </span>
            ただし、これらが実際に意味のある利益をもたらすのはレアケースです。
        </span>
        <span>
            <span class="src">
                Note that class template argument deduction is also subject to a
                <a href="#CTAD">separate style rule</a>.
            </span>
            なお、クラステンプレートの実引数推論については、<a href="#CTAD">別のスタイルルール</a>にも従う必要があることに注意してください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Do not use <code>decltype(auto)</code> if a simpler option will work,
                because it's a fairly obscure feature, so it has a high cost in code
                clarity.
            </span>
            <code>decltype(auto)</code>については、より単純な手段で十分な場合には、わざわざ<code>decltype(auto)</code>を使ってはいけません。<code>decltype(auto)</code>は、かなり難しい機能であるため、コードの明確さの面で大きなコストになります。
        </span>
    </p>

    <h4 title="Return type deduction">戻り値の型推論</h4>

    <p>
        <span>
            <span class="src">
                Use return type deduction (for both functions and lambdas) only if the
                function body has a very small number of <code>return</code> statements,
                and very little other code, because otherwise the reader may not be able
                to tell at a glance what the return type is.
            </span>
            戻り値の型推論は、通常の関数とラムダ式とのどちらの場合でも、関数本体に含まれる<code>return</code>文の数が非常に少なく、かつ、その他のコードがほとんどない場合に限って使用してください。コードの読者が、関数を一目見て戻り値の型を判断できないような場合は避けてください。
        </span>
        <span>
            <span class="src">
                Furthermore, use it only
                if the function or lambda has a very narrow scope, because functions with
                deduced return types don't define abstraction boundaries: the implementation
                <em>is</em> the interface.
            </span>
            さらに言えば、戻り値の型推論を用いるのは、その関数やラムダが非常に狭いスコープから使われる場合のみに限定する方がよいでしょう。戻り値の型を推論に委ねる関数は、抽象化の境界を定義せず、<em>その実装そのものがそのままインターフェースとなる</em>ためです。
        </span>
        <span>
            <span class="src">
                In particular, public functions in header files
                should almost never have deduced return types.
            </span>
            特に、ヘッダーファイルで公開される関数では、戻り値の型の推論は、ほとんど、まったく、用いるべきではありません。
        </span>
    </p>

    <h4 title="Parameter type deduction">引数の型推論</h4>

    <p>
        <span>
            <span class="src">
                <code>auto</code> parameter types for lambdas should be used with caution,
                because the actual type is determined by the code that calls the lambda,
                rather than by the definition of the lambda.
            </span>
            ラムダ式の<code>auto</code>引数には注意が必要です。
            これは、引数の実際の型が、ラムダの定義ではなく、ラムダを呼び出すコードによって決定されるためです。
        </span>
        <span>
            <span class="src">
                Consequently, an explicit
                type will almost always be clearer unless the lambda is explicitly called
                very close to where it's defined (so that the reader can easily see both),
                or the lambda is passed to an interface so well-known that it's
                obvious what arguments it will eventually be called with (e.g.,
                the <code>std::sort</code> example above).
            </span>
            したがって、
            ラムダの定義とその呼び出しがすぐ近くにあり、両者のコードを容易に見つけられるときや、
            あるいは、ラムダが非常によく知られたインターフェース(<code>std::sort</code>など)に渡されていて、呼び出し時の実引数が何になるか容易に想像できるときなどを除けば、
            それ以外は、ほとんど常に、ラムダの引数の型を明示する方がコードがわかりやすくなります。
        </span>
    </p>

    <h4 title="Lambda init captures">ラムダ式の初期化キャプチャ</h4>

    <p>
        <span>
            <span class="src">
                Init captures are covered by a <a href="#Lambda_expressions">more specific
                  style rule</a>, which largely supersedes the general rules for
                type deduction.
            </span>
            初期化キャプチャに関しては、<a href="#Lambda_expressions">より具体的なスタイルルール</a>によってカバーします。これは、型推論の一般的なルールに大きく取って代わるものです。
        </span>
    </p>

    <h4 title="Structured bindings">構造化束縛</h4>

    <p>
        <span>
            <span class="src">
                Unlike other forms of type deduction, structured bindings can actually
                give the reader additional information, by giving meaningful names to the
                elements of a larger object.
            </span>
            他の形式の型推論とは異なり、構造化束縛では、大きなオブジェクトの各要素に意味のある名前をつけられるため、コード読者に追加の情報を提供することができます。
        </span>
        <span>
            <span class="src">
                This means that a structured binding declaration
                may provide a net readability improvement over an explicit type, even in cases
                where <code>auto</code> would not.
            </span>
            これは、その<code>auto</code>が可読性の向上に貢献しないとしても、構造化束縛宣言を用いた方が、型を明示的に書いたのに比べて、全体としての可読性を向上させられるかもしれないことを意味します。
        </span>
        <span>
            <span class="src">
                Structured bindings are especially
                beneficial when the object is a pair or tuple (as in the <code>insert</code>
                example above), because they don't have meaningful field names to begin with,
                but note that you generally <a href="#Structs_vs._Tuples">shouldn't use
                    pairs or tuples</a> unless a pre-existing API like <code>insert</code>
                forces you to.
            </span>
            構造化束縛が特に真価を発揮するのは、(上記例の<code>insert</code>のように、)束縛対象のオブジェクトがペアやタプルのような、もともと意味のあるフィールド名を持っていないような場合です。
            (ただし、<code>insert</code>などの既存のAPIによって強制される場合を除いて、そもそも<a href="#Structs_vs._Tuples">ペアやタプルは使うべきではありません</a>。)
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                If the object being bound is a struct, it may sometimes be helpful to
                provide names that are more specific to your usage, but keep in mind that
                this may also mean the names are less recognizable to your reader than the
                field names.
            </span>
            束縛対象のオブジェクトが構造体である場合、その場での各フィールドの使い方に特化した名前を付け直すことが役立つときがあります。
            ただし、コード読者にとって、その新しい名前が元のフィールド名よりも見分けにくくなるかもしれないことは念頭においてください。
        </span>
        <span>
            <span class="src">
                We recommend using a comment to indicate the name of the
                underlying field, if it doesn't match the name of the binding, using the
                same syntax as for function parameter comments:
            </span>
            束縛名と元のフィールド名とを一致させない場合は、関数引数のコメントと同じ構文で、元のフィールド名をコメントとして記述することをおすすめします。
        </span>
    </p>
    <pre>auto [/*field_name1=*/bound_name1, /*field_name2=*/bound_name2] = ...</pre>
    <p>
        <span>
            <span class="src">
                As with function parameter comments, this can enable tools to detect if
                you get the order of the fields wrong.
            </span>
            こうすることで、関数引数のコメントと同様に、フィールドの順序が間違っていないかどうかを、ツールに検出してもらうこともできるようになるでしょう。
        </span>
    </p>

    <h3 id="CTAD"><span title="Class Template Argument Deduction">クラステンプレートのテンプレート引数推論(CTAD)</span></h3>

    <p>
        <span>
            <span class="src">
                Use class template argument deduction only with templates that have
                explicitly opted into supporting it.
            </span>
            クラステンプレートの引数推論は、それに対応していることを明示しているテンプレートでのみ利用します。
        </span>
    </p>

    <p class="definition">
    </p>
    <p>
        <span>
            <span class="src">
                <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">Class
                    template argument deduction</a> (often abbreviated "CTAD") occurs when
                a variable is declared with a type that names a template, and the template
                argument list is not provided (not even empty angle brackets):
            </span>
            <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">クラステンプレートのテンプレート引数推論</a>(しばしば "CTAD" と略される)は、
            変数の型がテンプレート名で宣言され、かつ、その宣言でテンプレートの引数リストが与えられなかった場合(空の山括弧もない)に行われます。
        </span>
    </p>
    <div><div class="src"><pre class="neutralcode">std::array a = {1, 2, 3};  // `a` is a std::array&lt;int, 3&gt;</pre></div>
    <pre class="neutralcode">std::array a = {1, 2, 3};  // `a` は std::array&lt;int, 3&gt;</pre></div>
    <p>
        <span>
            <span class="src">
                The compiler deduces the arguments from the initializer using the
                template's "deduction guides", which can be explicit or implicit.
            </span>
            コンパイラは、そのテンプレートの明示的または暗黙的な「推論ガイド」を使用して、初期化子からテンプレート引数を推論します。
        </span>
    </p>
    <p>
        <span>
            <span class="src">
                Explicit deduction guides look like function declarations with trailing
                return types, except that there's no leading <code>auto</code>, and the
                function name is the name of the template.
            </span>
            明示的な推論ガイドの見た目は、戻り値の型を末尾におく関数宣言のような形をしていますが、先頭に<code>auto</code>がなく、その関数名がテンプレートの名前になっています。
        </span>
        <span>
            <span class="src">
                For example, the above example
                relies on this deduction guide for <code>std::array</code>:
            </span>
            たとえば、上記の例は、<code>std::array</code>の次の推論ガイドに依存しています。
        </span>
    </p>
    <pre class="neutralcode">namespace std {
    template &lt;class T, class...U&gt;
    array(T, U...) -&gt; std::array&lt;T, 1 + sizeof...(U)&gt;;
}</pre>
    <p>
        <span>
            <span class="src">
                Constructors in a primary template (as opposed to a template specialization)
                also implicitly define deduction guides.
            </span>
            (テンプレートの特殊化とは異なり)プライマリテンプレートのコンストラクタも、推論ガイドを暗黙的に定義します。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                When you declare a variable that relies on CTAD, the compiler selects
                a deduction guide using the rules of constructor overload resolution,
                and that guide's return type becomes the type of the variable.
            </span>
            CTADに依存する変数宣言は、コンパイラによってコンストラクタのオーバーロード解決の規則を使用して推論ガイドが選択され、そのガイドの戻り値の型が変数の型になります。
        </span>
    </p>

    <p class="pros">
    </p>
    <p>
        <span>
            <span class="src">
                CTAD can sometimes allow you to omit boilerplate from your code.
            </span>
            CTADでは、コードからボイラープレートを省略できる場合があります。
        </span>
    </p>

    <p class="cons">
    </p>
    <p>
        <span>
            <span class="src">
                The implicit deduction guides that are generated from constructors
                may have undesirable behavior, or be outright incorrect.
            </span>
            コンストラクタから自動生成される暗黙的な推論ガイドは、望ましくない動作をしたり、あるいは、まったくもって正しくない場合があります。
        </span>
        <span>
            <span class="src">
                This is
                particularly problematic for constructors written before CTAD was
                introduced in C++17, because the authors of those constructors had no
                way of knowing about (much less fixing) any problems that their
                constructors would cause for CTAD.
            </span>
            これは、特に、C++17でCTADが導入される前に書かれたコンストラクタで問題になりがちです。
            これらのコンストラクタの著者は、これらのコンストラクタがCTADによって引き起こす問題について、何ら知る由もなかったでしょう。
        </span>
        <span>
            <span class="src">
                Furthermore, adding explicit deduction
                guides to fix those problems might break any existing code that relies on
                the implicit deduction guides.
            </span>
            さらに、これらの問題を修正するために明示的な推論ガイドを追加しようとすると、今度は、それまでの暗黙的な推論ガイドに依存している既存のコードを壊してしまう可能性さえあります。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                CTAD also suffers from many of the same drawbacks as <code>auto</code>,
                because they are both mechanisms for deducing all or part of a variable's
                type from its initializer.
            </span>
            CTADにも<code>auto</code>と同様の欠点が数多くあります。
            これは、どちらも、その初期化子から、変数の型またはその一部を推論するための仕組みだからです。
        </span>
        <span>
            <span class="src">
                CTAD does give the reader more information
                than <code>auto</code>, but it also doesn't give the reader an obvious
                cue that information has been omitted.
            </span>
            CTADは<code>auto</code>よりは多くの情報を読者に提供しますが、情報が省略されていることを明確に伝えるわけではありません。
        </span>
    </p>

    <p class="decision">
    </p>
    <p>
        <span>
            <span class="src">
                Do not use CTAD with a given template unless the template's maintainers
                have opted into supporting use of CTAD by providing at least one explicit
                deduction guide (all templates in the <code>std</code> namespace are
                also presumed to have opted in).
            </span>
            テンプレートのメンテナーによって1つ以上の明示的な推論ガイドが提供されており、そのテンプレートで明示的にCTADに対応していることが表明されている場合に限りCTADを利用してください。それ以外の場合はCTADを避けてください。なお、<code>std</code>名前空間のすべてのテンプレートはCTADに対応していると見なしてかまいません。
        </span>
        <span>
            <span class="src">
                This should be enforced with a compiler
                warning if available.
            </span>
            また、可能であれば、コンパイラの警告を有効にしてください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Uses of CTAD must also follow the general rules on
                <a href="#Type_deduction">Type deduction</a>.
            </span>
            なお、CTADは<a href="#Type_deduction">型推論</a>に関する一般的なルールにも従う必要がありますので、注意してください。
        </span>
    </p>

    <h3 id="Designated_initializers" title="Designated Initializers">指示付き初期化子</h3>

    <p>
        <span>
            <span class="src">
                Use designated initializers only in their C++20-compliant form.
            </span>
            指示付き初期化子は、C++20に準拠する形式でのみ使用してください。
        </span>
    </p>

    <p class="definition">
    </p>
    <p>
        <span>
            <span class="src">
                <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization#Designated_initializers">
                    Designated initializers</a> are a syntax that allows for initializing an
                aggregate ("plain old struct") by naming its fields explicitly:
            </span>
            <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization#Designated_initializers">指示付き初期化子</a>は、各フィールド名を明示しながら集約型(aggregate) (あるいは、Plain Old Struct) を初期化できる構文です。
        </span>
    </p>
    <pre class="neutralcode">  struct Point {
        float x = 0.0;
        float y = 0.0;
        float z = 0.0;
      };
    
      Point p = {
        .x = 1.0,
        .y = 2.0,
        // z will be 0.0
      };</pre>
    <p>
        <span>
            <span class="src">
                The explicitly listed fields will be initialized as specified, and others
                will be initialized in the same way they would be in a traditional aggregate
                initialization expression like <code>Point{1.0, 2.0}</code>.
            </span>
            明示的に書かれたフィールドは指定されたとおりに初期化され、それ以外のフィールドは従来の集約初期化式 <code>Point{1.0, 2.0}</code> と同様の方法で初期化されます。
        </span>
    </p>

    <p class="pros">
    </p>
    <p>
        <span>
            <span class="src">
                Designated initializers can make for convenient and highly readable
                aggregate expressions, especially for structs with less straightforward
                ordering of fields than the <code>Point</code> example above.
            </span>
            指示付き初期化子は、特に上記の <code>Point</code> の例よりもフィールドの順序付けが単純でない構造体の場合に、便利で非常に読みやすい集約式(aggregate expression)を作成できます。
        </span>
    </p>

    <p class="cons">
    </p>
    <p>
        <span>
            <span class="src">
                While designated initializers have long been part of the C standard and
                supported by C++ compilers as an extension, they were not supported by
                C++ prior to C++20.
            </span>
            指示付き初期化子は、長い間、標準C言語の一部であり、C++コンパイラによって拡張機能としてサポートされていましたが、C++20よりも前のC++標準ではサポートされていませんでした。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                The rules in the C++ standard are stricter than in C and compiler extensions,
                requiring that the designated initializers appear in the same order as the
                fields appear in the struct definition.
            </span>
            C++標準における規則は、標準C言語やコンパイラの拡張機能のものよりも厳しく、指示付き初期化子が、構造体の定義におけるフィールドと同じ順序で現れることを要求しています。
        </span>
        <span>
            <span class="src">
                So in the example above, it is legal
                according to C++20 to initialize <code>x</code> and then <code>z</code>, but not
                <code>y</code> and then <code>x</code>.
            </span>
            つまり、前述の例において、C++20に従うと、<code>x</code>のあとに<code>z</code>を初期化することは正当ですが、<code>y</code>のあとに<code>x</code>を初期化することはできません。
        </span>
    </p>

    <p class="decision">
    </p>
    <p>
        <span>
            <span class="src">
                Use designated initializers only in the form that is compatible with the
                C++20 standard: with initializers in the same order as the corresponding fields
                appear in the struct definition.
            </span>
            指示付き初期化子は、C++20標準と互換性のある形式でのみ利用してください。
            つまり、対応するフィールドが構造体定義に現れるのと同じ順序で初期化子を記述するようにしてください。
        </span>
    </p>

    <h3 id="Lambda_expressions"><span title="Lambda expressions">ラムダ式</span></h3>

    <p>
        <span>
            <span class="src">
                Use lambda expressions where appropriate.
            </span>
            ラムダ式は適切に使います。
        </span>
        <span>
            <span class="src">
                Prefer explicit captures
                when the lambda will escape the current scope.
            </span>
            ラムダが現在のスコープから外に出て行くときは、変数キャプチャを明示的に行いましょう。
        </span>
    </p>

    <p class="definition"></p>

    <p>
        <span>
            <span class="src">
                Lambda expressions are a concise way of creating anonymous
                function objects.
            </span>
            ラムダ式は匿名関数オブジェクトを作るための簡潔な手段です。
        </span>
        <span>
            <span class="src">
                They're often useful when passing
                functions as arguments. For example:
            </span>
            これらは関数の引数として渡す場合にも有用です。
        </span>
    </p>

    <pre>std::sort(v.begin(), v.end(), [](int x, int y) {
  return Weight(x) &lt; Weight(y);
});
</pre>

    <p>
        <span>
            <span class="src">
                They further allow capturing variables from the enclosing scope either
                explicitly by name, or implicitly using a default capture.
            </span>
            さらに、ラムダ式では自身を囲むスコープから変数をキャプチャすることができます。
            変数のキャプチャは、明示的に名前を指定するか、暗黙的なデフォルトのキャプチャを使うかのどちらかによって行われます。
        </span>
        <span>
            <span class="src">
                Explicit captures
                require each variable to be listed, as
                either a value or reference capture:
            </span>
            明示的なキャプチャを行う場合は、次のように、各変数を値とするか参照とするかを指定しながらリストに並べます。
        </span>
    </p>
    <div>
        <div class="src">
            <pre>int weight = 3;
int sum = 0;
// Captures `weight` by value and `sum` by reference.
std::for_each(v.begin(), v.end(), [weight, &amp;sum](int x) {
  sum += weight * x;
});
</pre>
        </div>
        <pre>int weight = 3;
int sum = 0;
// weigthは値として、sumは参照としてキャプチャします。
std::for_each(v.begin(), v.end(), [weight, &amp;sum](int x) {
  sum += weight * x;
});
</pre>
    </div>
    <p>
        <span>
            <span class="src">
                Default captures implicitly capture any variable referenced in the
                lambda body, including <code>this</code> if any members are used:
            </span>
            デフォルトのキャプチャは暗黙的にラムダの本体で参照されたすべての変数をキャプチャします。何らかのメンバ変数やメンバ関数などが使われている場合は<code>this</code>もキャプチャされます。
        </span>
    </p>
    <div>
        <div class="src">
            <pre>const std::vector&lt;int&gt; lookup_table = ...;
std::vector&lt;int&gt; indices = ...;
// Captures `lookup_table` by reference, sorts `indices` by the value
// of the associated element in `lookup_table`.
std::sort(indices.begin(), indices.end(), [&amp;](int a, int b) {
  return lookup_table[a] &lt; lookup_table[b];
});
</pre>
        </div>
        <pre>const std::vector&lt;int&gt; lookup_table = ...;
std::vector&lt;int&gt; indices = ...;
// lookup_tableを参照としてキャプチャし、
// lookup_tableの要素に関連づけられたindicesの値をソートしています。
std::sort(indices.begin(), indices.end(), [&amp;](int a, int b) {
  return lookup_table[a] &lt; lookup_table[b];
});
</pre>
</div>
        <p>
            <span>
                <span class="src">
                    A variable capture can also have an explicit initializer, which can
                    be used for capturing move-only variables by value, or for other situations
                    not handled by ordinary reference or value captures:
                </span>
                変数キャプチャには、明示的な初期化子を与えることもできます。
                これによって、ムーブのみ可能な型の変数を値でキャプチャしたいときや、通常の参照キャプチャや値キャプチャでは対処できないその他の状況にも対応できます。
            </span>
        </p>
        <pre>std::unique_ptr&lt;Foo&gt; foo = ...;
        [foo = std::move(foo)] () {
          ...
        }</pre>
        <p>
            <span>
                <span class="src">
                    Such captures (often called "init captures" or "generalized lambda captures")
                    need not actually "capture" anything from the enclosing scope, or even have
                    a name from the enclosing scope; this syntax is a fully general way to define
                    members of a lambda object:
                </span>
                このようなキャプチャ (「初期化キャプチャ」または「一般化されたラムダキャプチャ」と呼ばれる)は、
                実際には、それを囲むスコープから何かをキャプチャする必要はなく、囲んでいるスコープ内に名前がある必要もありません。
                この構文は、ラムダオブジェクトのメンバ変数を定義するための一般的な手段です。
            </span>
        </p>
        <pre class="neutralcode">[foo = std::vector&lt;int&gt;({1, 2, 3})] () {
          ...
        }</pre>
        <p>
            <span>
                <span class="src">
                    The type of a capture with an initializer is deduced using the same rules
                    as <code>auto</code>.
                </span>
                初期化子を使用したキャプチャの型は、<code>auto</code>と同じ規則によって推論されます。
            </span>
        </p>

        <p class="pros"></p>
        <ul>
            <li>
                <span>
                    <span class="src">
                        Lambdas are much more concise than other ways of
                        defining function objects to be passed to STL
                        algorithms, which can be a readability
                        improvement.
                    </span>
                    ラムダ式は、STLアルゴリズムに渡す関数オブジェクトを定義する手段として非常に簡潔であり、可読性も向上させます。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Appropriate use of default captures can remove
                        redundancy and highlight important exceptions from
                        the default.
                    </span>
                    適切にデフォルトキャプチャを用いることで、冗長性を減らし、また、デフォルトとは異なる重要な部分を目立たせることができます。
                </span>
            </li>

            <li>
                <span>
                    <span class="src">
                        Lambdas, <code>std::function</code>, and
                        <code>std::bind</code> can be used in combination as a
                        general purpose callback mechanism; they make it easy
                        to write functions that take bound functions as
                        arguments.
                    </span>
                    ラムダや<code>std::function</code>、<code>std::bind</code>は、一般的なコールバックの仕組みとして組み合わせて使用することができ、これによって、関数を引数にとるような関数が書きやすくなります。
                </span>
            </li>
        </ul>

    <p class="cons"></p>
    <ul>
        <li>
            <span>
                <span class="src">
                    Variable capture in lambdas can be a source of dangling-pointer
                    bugs, particularly if a lambda escapes the current scope.
                </span>
                ラムダの変数のキャプチャは、ダングリングポインタバグの元になる危険性険があり、特にラムダがスコープ外に出ていくときは注意が必要です。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Default captures by value can be misleading because they do not prevent
                    dangling-pointer bugs.
                </span>
                誤解されやすいですが、値のデフォルトキャプチャが、ダングリングポインタのバグを防ぐことはありません。
            </span>
            <span>
                <span class="src">
                    Capturing a pointer by value doesn't cause a deep
                    copy, so it often has the same lifetime issues as capture by reference.
                </span>
                ポインタを値キャプチャしても、ポインタが差す先のオブジェクトがコピーされるわけではないため、変数を参照キャプチャした場合と同様に、オブジェクトの寿命に関して気にする必要があります。
            </span>
            <span>
                <span class="src">
                    This is especially confusing when capturing 'this' by value, since the use
                    of 'this' is often implicit.
                </span>
                特に、<code>this</code>ポインタは暗黙的に使用されることも多く、これを値でキャプチャすることは混乱の元になりがちです。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Captures actually declare new variables (whether or not the captures have
                    initializers), but they look nothing like any other variable declaration
                    syntax in C++.
                </span>
                キャプチャは(初期化子があるかどうかに関係なく)実際には新しい変数を宣言しているのですが、C++の他の変数宣言構文とはまったく異なる見た目をしています。
            </span>
            <span>
                <span class="src">
                    In particular, there's no place for the variable's type,
                    or even an <code>auto</code> placeholder (although init captures can
                    indicate it indirectly, e.g., with a cast).
                </span>
                特に、変数の型名を書く場所もなく、<code>auto</code>プレースホルダーすら書かれることはありません(ただし、初期化キャプチャは、キャストなどを使用して間接的に型を示すことができます)。
            </span>
            <span>
                <span class="src">
                    This can make it difficult to
                    even recognize them as declarations.
                </span>
                このことは、それが変数宣言であると見分けることをも難しくするかもしれません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Init captures inherently rely on <a href="#Type_deduction">type
                        deduction</a>, and suffer from many of the same drawbacks as
                    <code>auto</code>, with the additional problem that the syntax doesn't
                    even cue the reader that deduction is taking place.
                </span>
                初期化子つきのキャプチャは本質的に<a href="#Type_deduction">型推論</a>に依存しており、<code>auto</code>の持つ欠点の多くを同様に抱えています。
                また、その構文において、そこで型推論が行われていることをコード読者に伝えることもできないという点も問題です。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    It's possible for use of lambdas to get out of
                    hand; very long nested anonymous functions can make
                    code harder to understand.
                </span>
                ラムダは、手に余るような扱い方もできてしまいます。
                たとえば、ネストされた非常にに長い匿名の関数は、コードの理解の妨げとなるでしょう。
            </span>
        </li>

    </ul>

    <p class="decision"></p>
    <ul>
        <li>
            <span>
                <span class="src">
                    Use lambda expressions where appropriate, with formatting as
                    described <a href="#Formatting_Lambda_Expressions">below</a>.
                </span>
                ラムダ式は適切に使用してください。
                ラムダ式を使用する場合は、<a href="#Formatting_Lambda_Expressions">ラムダ式の書式</a>に従ってください。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Prefer explicit captures if the lambda may escape the current scope.
                </span>
                ラムダが現在のスコープの外に出て行く場合は、変数のキャプチャを明示的に行いましょう。
            </span>
            <span>
                <span class="src">
                    For example, instead of:
                </span>
                以下に例を示します。悪い例:
            </span>
            <div>
                <div class="src">
                    <pre class="badcode">{
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;] { Frobnicate(foo); })
  ...
}
// BAD! The fact that the lambda makes use of a reference to `foo` and
// possibly `this` (if `Frobnicate` is a member function) may not be
// apparent on a cursory inspection. If the lambda is invoked after
// the function returns, that would be bad, because both `foo`
// and the enclosing object could have been destroyed.
</pre>
                </div>
                <pre class="badcode">{
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;] { Frobnicate(foo); })
  ...
}
// これはダメ！
// ラムダにおいて、`foo`と`this`(`Frobnicate`がメンバ関数である場合)への参照が
// 作られているのですが、大まかに眺めただけでは、それに気づかないかもしれません。
// もし、Schedule関数が処理を呼び出し元に戻した後に、このラムダが呼び出されると、
// よくないことが起こるでしょう。ラムダが呼び出されるそのときには、`foo`も、この
// ラムダを取り囲んでいたオブジェクトも、すでに破壊済みであるかもしれないからです。
</pre>
            </div>
            <span>
                <span class="src">
                    prefer to write:
                </span>
                良い例:
            </span>
            <div>
                <div class="src">
                    <pre>{
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;foo] { Frobnicate(foo); })
  ...
}
// BETTER - The compile will fail if `Frobnicate` is a member
// function, and it's clearer that `foo` is dangerously captured by
// reference.
</pre>
                </div>
                <pre>{
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;foo] { Frobnicate(foo); })
  ...
}
// この方が良い。
// Frobnicateがメンバ関数である場合、コンパイルに失敗します。
// また、fooについても、危険な参照キャプチャをされていることが明確です。
</pre>
            </div>
        </li>
        <li>
            <span>
                <span class="src">
                    Use default capture by reference ([&amp;]) only when the
                    lifetime of the lambda is obviously shorter than any potential
                    captures.
                </span>
                参照のデフォルトキャプチャ(<code>[&amp;]</code>)は、ラムダの寿命が、すべての潜在的なキャプチャよりも明らかに短いときにのみ使用してください。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Use default capture by value ([=]) only as a means of binding a
                    few variables for a short lambda, where the set of captured
                    variables is obvious at a glance, and which does not result in
                    capturing <code>this</code> implicitly.
                </span>
                値のデフォルトキャプチャ(<code>[=]</code>)は、短いラムダにおいて1～2個の変数がキャプチャされる場合で、一目見ただけでどの変数がキャプチャされているかわかり、かつ、暗黙的な<code>this</code>のキャプチャが行われない場合にのみ使用してください。
            </span>
            <span>
                <span class="src">
                    (That means that a lambda that
                    appears in a non-static class member function and refers to non-static
                    class members in its body must capture <code>this</code> explicitly or
                    via <code>[&amp;]</code>.)
                </span>
                (つまり、ラムダが、クラスのメンバ関数内にあって、かつ、何らかの非staticなメンバを参照する場合は、必ず<code>this</code>を明示的にキャプチャするか、<code>[&amp;]</code>を使用しなければならないということです。)
            </span>
            <span>
                <span class="src">
                    Prefer not to write long or
                    complex lambdas with default capture by value.
                </span>
                長いラムダや複雑なラムダにおいては、値のデフォルトキャプチャを行うのは好ましくありません。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Use captures only to actually capture variables from the enclosing scope.
                </span>
                キャプチャは、自身を囲むスコープから実際に変数をキャプチャするためだけに使用してください。
            </span>
            <span>
                <span class="src">
                    Do not use captures with initializers to introduce new names, or
                    to substantially change the meaning of an existing name.
                </span>
                新しい名前を導入する目的や、あるいは、既存の名前の意味を変える目的で、初期化子つきキャプチャを使わないでください。
            </span>
            <span>
                <span class="src">
                    Instead,
                    declare a new variable in the conventional way and then capture it,
                    or avoid the lambda shorthand and define a function object explicitly.
                </span>
                そのかわり、従来の方法で新しいローカル変数を宣言しそれをキャプチャするか、ラムダによる短縮表現を使うのをやめて明示的に通常の関数オブジェクトを定義してください。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    See the section on <a href="#Type_deduction">type deduction</a>
                    for guidance on specifying the parameter and return types.
                </span>
                引数や戻り値の型の指定方法に関するガイドとして<a href="#Type_deduction">型推論</a>のセクションも参照してください。
            </span>
        </li>
    </ul>

    <h3 id="Template_metaprogramming"><span title="Template metaprogramming">テンプレートメタプログラミング</span></h3>

    <p>
        <span>
            <span class="src">
                Avoid complicated template programming.
            </span>
            複雑なテンプレートプログラミングは避けましょう。
        </span>
    </p>

    <p class="definition"></p>
    <p>
        <span>
            <span class="src">
                Template metaprogramming refers to a family of techniques that
                exploit the fact that the C++ template instantiation mechanism is
                Turing complete and can be used to perform arbitrary compile-time
                computation in the type domain.
            </span>
            テンプレートメタプログラミングとは、C++のテンプレートのインスタンス化の仕組みがチューリング完全であり、コンパイル時に型の世界で任意の計算を行うことができるという事実を利用した一連のテクニックのことを指します。
        </span>
    </p>
    <p class="pros"></p>
    <p>
        <span>
            <span class="src">
                Template metaprogramming allows extremely flexible interfaces that
                are type safe and high performance.
            </span>
            テンプレートメタプログラミングは、型安全かつ高性能で非常に柔軟なインターフェースを提供します。
        </span>
        <span>
            <span class="src">
                Facilities like

                <a href="https://github.com/google/googletest">GoogleTest</a>,
                <code>std::tuple</code>, <code>std::function</code>, and
                Boost.Spirit would be impossible without it.
            </span>
            <a href="https://github.com/google/googletest">GoogleTest</a>
            や<code>std::tuple</code>、<code>std::function</code>、Boost.Spiritのような機能は、テンプレートメタプログラミングがなければ実現できません。
        </span>
    </p>
    <p class="cons"></p>
    <p>
        <span>
            <span class="src">
                The techniques used in template metaprogramming are often obscure
                to anyone but language experts.
            </span>
            テンプレートメタプログラミングにおいて使われるテクニックは、言語の専門家以外にはわかりにくいものになりがちです。
        </span>
        <span>
            <span class="src">
                Code that uses templates in
                complicated ways is often unreadable, and is hard to debug or
                maintain.
            </span>
            複雑な手法のテンプレートを含むコードは、可読性が低く、デバッグやメンテナンスも難しくなります。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Template metaprogramming often leads to extremely poor compile
                time error messages: even if an interface is simple, the complicated
                implementation details become visible when the user does something
                wrong.
            </span>
            テンプレートメタプログラミングは、コンパイル時のエラーメッセージを非常に貧弱なものにしがちです。たとえ、そのインターフェースがシンプルであっても、ひとたびユーザが何かを間違えた途端に、複雑な内部実装が大量のエラーメッセージとともに現れてしまうことがあります。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Template metaprogramming interferes with large scale refactoring by
                making the job of refactoring tools harder.
            </span>
            テンプレートメタプログラミングは、リファクタリングツールの動作を難しくするため、大規模なリファクタリングの妨げとなることがあります。
        </span>
        <span>
            <span class="src">
                First, the template code
                is expanded in multiple contexts, and it's hard to verify that the
                transformation makes sense in all of them.
            </span>
            第一に、テンプレートコードは様々な文脈で展開されますが、展開後のすべての箇所において、それらが正しい意味を持つか検証することが難しいです。
        </span>
        <span>
            <span class="src">
                Second, some refactoring
                tools work with an AST that only represents the structure of the code
                after template expansion.
            </span>
            第二に、リファクタリングツールの中には、テンプレート展開後のコード構造を表すASTしか扱えないものも存在します。
        </span>
        <span>
            <span class="src">
                It can be difficult to automatically work
                back to the original source construct that needs to be
                rewritten.
            </span>
            このようなツールでは、本来のリファクタリング対象である展開前のソースコードを自動的に書き換えることはできないかもしれません。
        </span>
    </p>
    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                Template metaprogramming sometimes allows cleaner and easier-to-use
                interfaces than would be possible without it, but it's also often a
                temptation to be overly clever.
            </span>
            テンプレートメタプログラミングは、使い方次第では、インターフェースをきれいで使いやすくするために役立ちます。しかし、それと同時に、必要以上に巧妙な実装をさせようとする挑戦への誘惑のかたまりでもあります。
        </span>
        <span>
            <span class="src">
                It's best used in a small number of
                low level components where the extra maintenance burden is spread out
                over a large number of uses.
            </span>
            テンプレートメタプログラミングは、そのコードのメンテナンスコストをたくさんの使用箇所で分散できるような少数の低レベルコンポーネントで用いるのが最適でしょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Think twice before using template metaprogramming or other
                complicated template techniques; think about whether the average
                member of your team will be able to understand your code well enough
                to maintain it after you switch to another project, or whether a
                non-C++ programmer or someone casually browsing the code base will be
                able to understand the error messages or trace the flow of a function
                they want to call.
            </span>
            テンプレートメタプログラミングや、それに類する複雑なテンプレートテクニックを導入する前には、一度立ち止まって、次のことを考えてみてください。あなたのプロジェクトチームの平均的なメンバーは、あなたがチームを抜けた後でも、そのコードを十分に理解してメンテナンスできそうでしょうか？　あるいは、C++を専門としないプログラマーや他の誰かが、カジュアルにそのコードベースを眺めたときに、エラーメッセージを理解したり、呼び出したい関数のプログラムの流れを追うことができそうでしょうか？　
        </span>
        <span>
            <span class="src">
                If you're using recursive template instantiations
                or type lists or metafunctions or expression templates, or relying on
                SFINAE or on the <code>sizeof</code> trick for detecting function
                overload resolution, then there's a good chance you've gone too
                far.
            </span>
            もしあなたが、テンプレートのインスタンス化、型リスト、メタ関数、式テンプレートなどを再帰的に使おうとしていたり、あるいは、SFINAEや、関数オーバーロード解決のための<code>sizeof</code>トリックを使おうとしているのならば、それらは、おそらくやり過ぎであることを示しているでしょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                If you use template metaprogramming, you should expect to put
                considerable effort into minimizing and isolating the complexity.
            </span>
            テンプレートメタプログラミングを使うのであれば、その複雑さを最小化して分離することに対して、かなりの労力を費やすことになるでしょう。
        </span>
        <span>
            <span class="src">
                You
                should hide metaprogramming as an implementation detail whenever
                possible, so that user-facing headers are readable, and you should
                make sure that tricky code is especially well commented.
            </span>
            メタプログラミングは実装の詳細として可能な限り隠し、ユーザが目にするヘッダーファイルを読みやすく保ってください。
            また、トリッキーなコードについては、特にしっかりとコメントを残すようにしてください。
        </span>
        <span>
            <span class="src">
                You should
                carefully document how the code is used, and you should say something
                about what the "generated" code looks like.
            </span>
            コードがどのように使われるかについて注意してドキュメント化してください。
            また、展開後のコードがどのような外観を持つのかについても言及してください。
        </span>
        <span>
            <span class="src">
                Pay extra attention to the
                error messages that the compiler emits when users make mistakes.
            </span>
            また、ユーザーが何かを間違えたときにコンパイラが生成するであろうエラーメッセージにも特別気を配ってください。
        </span>
        <span>
            <span class="src">
                The
                error messages are part of your user interface, and your code should
                be tweaked as necessary so that the error messages are understandable
                and actionable from a user point of view.
            </span>
            これらのエラーメッセージはユーザーインターフェースの一部なのです。
            コードを使用するユーザーが何かを間違えてしまったとき、ユーザーの目線から見て何が間違っていて何をすればいいのかがわかるようなメッセージが生成されるようにコードを調整してください。
        </span>
    </p>

<h3 id="Concepts"><span title="Concepts and Constraints">コンセプトと制約</span></h3>

<p><span><span class="src">
Use concepts sparingly.</span>
コンセプトは控えめに。</span>
<span><span class="src">
In general, concepts and constraints should only be used in cases
where templates would have been used prior to C++20.</span>
一般に、コンセプトと制約は、以前のC++であればテンプレートを使っていた場面に限って使用します。</span>
<span><span class="src">
Avoid introducing new concepts in headers,
unless the headers are marked as internal to the library.</span>
ライブラリ内部でのみ使用するとマークしている場合を除いて、公開ヘッダーファイル内で新しいコンセプトを導入するのは避けてください。</span>
<span><span class="src">
Do not define concepts that are not enforced by the compiler.</span>
また、コンパイラによる強制が働かないコンセプトも定義してはいけません。</span>
<span><span class="src">
Prefer constraints over template metaprogramming, and
avoid the <code>template&lt;<i>Concept</i> T&gt;</code> syntax;
instead, use the <code>requires(<i>Concept&lt;T&gt;</i>)</code>
syntax.</span>
型に制約を課すときは、従来形式のテンプレートメタプログラミングよりも、新しい制約の機能を優先的に使用してください。
また、その際には、<code>template&lt;<i>Concept</i> T&gt;</code>の形の構文は避け、かわりに<code>requires(<i>Concept&lt;T&gt;</i>)</code>の形を使ってください。
</p>

<p class="definition"></p>
<p><span><span class="src">
The <code>concept</code> keyword is a new mechanism for defining
requirements (such as type traits or interface specifications)
for a template parameter.</span>
<code>concept</code>キーワードは、テンプレート引数に対して、型トレイトやインターフェース仕様等の要件を定義する新たな仕組みです。</span>
</span>
<span><span class="src">
The <code>requires</code> keyword provides mechanisms for placing
anonymous constraints on templates and verifying that constraints
are satisfied at compile time.</span>
<code>requires</code>キーワードは、テンプレートにおいて無名の制約をかけるための新たな仕組みです。また、その制約が満たされていかどうかコンパイル時の検証を行わせるためにも使われます。</span>
<span><span class="src">
Concepts and constraints are often used together, but can be
also used independently.</span>
コンセプトと制約は多くの場合に同時に用いられますが、それぞれを独立して用いることもできます。
</span></p>

<p class="pros"></p>
<ul>
  <li><span><span class="src">
  Concepts allow the compiler to generate much better error
  messages when templates are involved, which can reduce confusion
  and significantly improve the development experience.</span>
  コンセプトによって、テンプレートが関与するコードにおけるコンパイル時のエラーメッセージを大きく改善できます。これによって、混乱が軽減され、開発時のエクスペリエンスを大幅に向上させます。</span>
  </li>
  <li><span><span class="src">
  Concepts can reduce the boilerplate necessary for defining
  and using compile-time constraints, often increasing the clarity
  of the resulting code.</span>
  コンセプトによって、コンパイル時に制約を課すために必要となるボイラープレートコードを減らすことができます。これによって、コードがより明確になります。
  </li>
  <li><span><span class="src">
  Constraints provide some capabilities that are difficult to
  achieve with templates and SFINAE techniques.</span>
  制約によって、従来のテンプレートやSFINAEテクニックでは実現が難しかったことが表現できるようになります。</span>
  </li>
</ul>

<p class="cons"></p>
<ul>
  <li><span><span class="src">
  As with templates, concepts can make code significantly more
  complex and difficult to understand.</span>
  テンプレートと同様に、コンセプトを導入することによって、コードが著しく複雑化し、理解しにくいものになってしまうかもしれません。</span>
  </li>
  <li><span><span class="src">
  Concept syntax can be confusing to readers, as concepts
  appear similar to class types at their usage sites.</span>
  コンセプトの文法は、それを使う側のコードにおいてクラス型のような見た目をしているため、コードの読者を混乱させるかもしれません。</span>
  </li>
  <li><span><span class="src">
  Concepts, especially at API boundaries, increase code
  coupling, rigidity, and ossification.</span>
  特にAPI境界において、コンセプトを用いると、コードの結合性や硬化性を高めてしまいます。</span>
  </li>
  <li><span><span class="src">
  Concepts and constraints can replicate logic from a function
  body, resulting in code duplication and increased maintenance
  costs.</span>
  コンセプトと制約は、関数本文のロジックの複製となることがあります。このことは、メンテナンスコストの増大に繋がります。</span>
  </li>
  <li><span><span class="src">
  Concepts muddy the source of truth for their underlying
  contracts, as they are standalone named entities that can be
  utilized in multiple locations, all of which evolve separately
  from each other.</span>
  コンセプトは、それぞれが複数の場所で使用できる独立したエンティティであるため、それぞれの場所でばらばらに成長してしまうことによって、それらの根底にある信頼できる契約の情報源を濁してしまうことがあります。</span>
  </span>
  <span><span class="src">
  This can cause the stated and implied requirements to diverge
  over time.</span>
  これによって、記述された要件と本来の暗黙的要件とが、時とともに乖離していってしまうかもしれません。</span>
  </li>
  <li><span><span class="src">
  Concepts and constraints affect overload resolution in novel
  and non-obvious ways.</span>
  コンセプトと制約は、オーバーロード解決においても、斬新で、わかりにくい影響を与えます。</span>
  </li>
  <li><span><span class="src">
  As with SFINAE, constraints make it harder to refactor code
  at scale.</span>
  SFINAEと同様に、制約はコードの大規模なリファクタリングをより困難にします。</span></li>
</ul>

<p class="decision"></p>
<p>
<span><span class="src">
Predefined concepts in the standard library should be
preferred to type traits, when equivalent ones exist.</span>
標準ライブラリにおいて、目的の型トレイトと同様のコンセプトとの両方が定義されているときは、コンセプトの方を優先的に用いましょう。</span>
<span><span class="src">
(e.g., if <code>std::is_integral_v</code> would have been used
before C++20, then <code>std::integral</code> should be used in
C++20 code.)</span>
(たとえば、今まで<code>std::is_integral_v</code>を使っていたところでは、C++20では<code>std::integral</code>を使いましょう。)
</span>
<span><span class="src">
Similarly, prefer modern constraint syntax
(via <code>requires(<i>Condition</i>)</code>).</span>
同様に、新しい制約の構文を、(<code>requires(<i>Condition</i>)</code>の形式で)優先的に用いましょう。</span>
<span><span class="src">
Avoid legacy template metaprogramming constructs
(such as <code>std::enable_if&lt;<i>Condition</i>&gt;</code>)
as well as the <code>template&lt;<i>Concept</i> T&gt;</code>
syntax.</span>
<code>template&lt;<i>Concept</i> T&gt;</code>の構文や、
<code>std::enable_if&lt;<i>Condition</i>&gt;</code>のような従来形式のテンプレートメタプログラミングは避けましょう。</span>
</p>

<p><span><span class="src">
Do not manually re-implement any existing concepts or traits.</span>
既存のコンセプトやトレイトを再実装してはいけません。</span>
<span><span class="src">
For example, use
<code>requires(std::default_initializable&lt;T&gt;)</code>
instead of
<code>requires(requires { T v; })</code>
or the like.</span>
たとえば、<code>requires(requires { T v; })</code>のようなコードを書くのではなく、既存の<code>requires(std::default_initializable&lt;T&gt;)</code>を使うようにしてください。
</span>

</p><p>
<span><span class="src">
New <code>concept</code> declarations should be rare, and only
defined internally within a library, such that they are not
exposed at API boundaries.</span>
新しい<code>concept</code>を宣言することは極力控えましょう。新たにコンセプトを定義する場合であっても、ライブラリ内での内部利用にとどめ、API境界を越えてそれらが公開されることがないようにしてください。</span>
<span><span class="src">
More generally, do not use concepts or constraints in cases where
you wouldn't use their legacy template equivalents in C++17.</span>
平たく言えば、今までのC++において同様ことをするテンプレートを使うべきでなかった箇所においては、同じくコンセプトや制約を使うべきではありません。</span>
</p>

<p><span><span class="src">
Do not define concepts that duplicate the function body,
or impose requirements that would be insignificant or obvious
from reading the body of the code or the resulting error messages.</span>
関数本体の複製となるようなコンセプトを定義してはいけません。
また、コード本体やエラーメッセージを読めば自明にわかるような、取るに足らない要件を課してもいけません。</span>
<span><span class="src">
For example, avoid the following:</span>たとえば、次のようなコードは避けてください。</span>
</p>
<div><div class="src"><pre class="badcode">template &lt;typename T&gt;     // Bad - redundant with negligible benefit
concept Addable = std::copyable&lt;T&gt; &amp;&amp; requires(T a, T b) { a + b; };
template &lt;Addable T&gt;
T Add(T x, T y, T z) { return x + y + z; }
</pre></div><pre class="badcode">template &lt;typename T&gt;     // 悪い例。冗長だし、メリットもない
concept Addable = std::copyable&lt;T&gt; &amp;&amp; requires(T a, T b) { a + b; };
template &lt;Addable T&gt;
T Add(T x, T y, T z) { return x + y + z; }
</pre></div>
<p><span><span class="src">
Instead, prefer to leave code as an ordinary template unless
you can demonstrate that concepts result in significant
improvement for that particular case, such as in the resulting
error messages for a deeply nested or non-obvious
requirement.</span>
このようなケースでは、コンセプトは使わず、従来なからのただのテンプレート関数のままにしておく方が望ましいです。
コンセプトは、コンセプトを導入することによって、状況を大きく改善できる場合に限って用いるとよいでしょう。
たとえば、深くネストされた要件や、一目ではわかりにくいような要件などに対して、そのエラーメッセージを改善したい場合などには、コンセプトを用いるのが適切でしょう。
</span>
</p>

<p><span><span class="src">
Concepts should be statically verifiable by the compiler.</span>
すべてのコンセプトは、コンパイラによって静的に検証可能なものでなければなりません。</span>
<span><span class="src">
Do not use any concept whose primary benefits would come from a
semantic (or otherwise unenforced) constraint.</span>
意味的な(あるいは、コンパイル時に強制されないような)制約条件に主な利益があるようなコンセプトは使用してはいけません。</span>
<span><span class="src">
Requirements that are unenforced at compile time should instead
be imposed via other mechanisms such as comments, assertions,
or tests.</span>
このような、コンパイル時チェックが働かない(できない)要件については、コンセプトや制約ではなく、コードコメントやアサーション、テストなどでそれらをカバーするようにしてください。</span>
</p>

    <h3 id="Boost"><span title="Boost">Boost</span></h3>

    <p>
        <span>
            <span class="src">
                Use only approved libraries from the Boost library
                collection.
            </span>
            Boostライブラリからは、そのライブラリコレクションのうち、あらかじめ認められたもののみを使うことができます。
        </span>
    </p>

    <p class="definition"></p>
    <p>
        <span>
            <span class="src">
                The
                <a href="https://www.boost.org/">
                    Boost library collection
                </a> is a popular collection of
                peer-reviewed, free, open-source C++ libraries.
            </span>
            <a href="https://www.boost.org/">Boostライブラリコレクション</a>は、ピアレビュー済み、フリー、オープンソースの、有名なC++ライブラリのコレクションです。
        </span>
    </p>
    <p class="pros"></p>
    <p>
        <span>
            <span class="src">
                Boost code is generally very high-quality, is widely
                portable, and fills many important gaps in the C++
                standard library, such as type traits and better binders.
            </span>
            Boostのコードは、全般にとても品質が良く、広い移植性があり、型トレイトや優れたバインダなどによって、C++標準ライブラリ内に散在するたくさんの隙間を埋めてくれます。
        </span>
    </p>
    <p class="cons"></p>
    <p>
        <span>
            <span class="src">
                Some Boost libraries encourage coding practices which can
                hamper readability, such as metaprogramming and other
                advanced template techniques, and an excessively
                "functional" style of programming.
            </span>
            いくつかのBoostライブラリでは、メタプログラミングやその他の先進的なテンプレートテクニックを積極的に取り入れていたり、関数型プログラミング言語のスタイルを採用していたりします。これらの手法はコードの可読性を妨げます。
        </span>
    </p>
    <p class="decision"></p>

    <p>
        <span>
            <span class="src">
                In order to maintain a high level of readability for
                all contributors who might read and maintain code, we
                only allow an approved subset of Boost features.
            </span>
            コードを読み、それをメンテナンスするすべてのコントリビュータのために、コードは高い可読性が保たれていなければなりません。この可読性を維持するために、Boostからは一部のサブセットのみについて、使用することを認めます。
        </span>
        <span>
            <span class="src">
                Currently, the following libraries are permitted:
            </span>
            現時点では、以下のライブラリが使用を認められています。
        </span>
    </p>

    <ul>
        <li>
            <span>
                <span class="src">
                    <a href="https://www.boost.org/libs/utility/call_traits.htm">
                        Call Traits
                    </a> from <code>boost/call_traits.hpp</code>
                </span>
                <a href="https://www.boost.org/libs/utility/call_traits.htm">Call Traits</a>
                (<code>boost/call_traits.hpp</code>)
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <a href="https://www.boost.org/libs/utility/compressed_pair.htm">
                        Compressed Pair
                    </a> from <code>boost/compressed_pair.hpp</code>
                </span>
                <a href="https://www.boost.org/libs/utility/compressed_pair.htm">Compressed Pair</a>
                (<code>boost/compressed_pair.hpp</code>)
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <a href="https://www.boost.org/libs/graph/">
                        The Boost Graph Library (BGL)
                    </a> from <code>boost/graph</code>,
                    except serialization (<code>adj_list_serialize.hpp</code>) and
                    parallel/distributed algorithms and data structures
                    (<code>boost/graph/parallel/*</code> and
                    <code>boost/graph/distributed/*</code>).
                </span>
                <a href="https://www.boost.org/libs/graph/">The Boost Graph Library (BGL)</a>
                (<code>boost/graph</code>) ただし、serialization (<code>adj_list_serialize.hpp</code>)と、
                parallel/distributed algorithms and data structures
                (<code>boost/graph/parallel/*</code>, <code>boost/graph/distributed/*</code>)を除く
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <a href="https://www.boost.org/libs/property_map/">
                        Property Map
                    </a> from <code>boost/property_map</code>, except
                    parallel/distributed property maps (<code>boost/property_map/parallel/*</code>).
                </span>
                <a href="https://www.boost.org/libs/property_map/">Property
                    Map</a>(<code>boost/property_map</code>) ただし、parallel/distributed property maps
                (<code>boost/property_map/parallel/*</code>) を除く
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <a href="https://www.boost.org/libs/iterator/">
                        Iterator
                    </a> from <code>boost/iterator</code>
                </span>
                <a href="https://www.boost.org/libs/iterator/">
                    Iterator
                </a> (<code>boost/iterator</code>)
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    The part of <a href="https://www.boost.org/libs/polygon/">
                        Polygon
                    </a> that deals with Voronoi diagram
                    construction and doesn't depend on the rest of
                    Polygon:
                    <code>boost/polygon/voronoi_builder.hpp</code>,
                    <code>boost/polygon/voronoi_diagram.hpp</code>, and
                    <code>boost/polygon/voronoi_geometry_type.hpp</code>
                </span>
                <a href="https://www.boost.org/libs/polygon/">Polygon</a>のうち、Voronoi diagram
                constructionを扱い、かつ残りのPolygonに依存していない部分
                (<code>boost/polygon/voronoi_builder.hpp</code>,
                <code>boost/polygon/voronoi_diagram.hpp</code>,
                <code>boost/polygon/voronoi_geometry_type.hpp</code>)
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <a href="https://www.boost.org/libs/bimap/">
                        Bimap
                    </a> from <code>boost/bimap</code>
                </span>
                <a href="https://www.boost.org/libs/bimap/">
                    Bimap
                </a> (<code>boost/bimap</code>)
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <a href="https://www.boost.org/libs/math/doc/html/dist.html">
                        Statistical Distributions and Functions
                    </a> from
                    <code>boost/math/distributions</code>
                </span>
                <a href="https://www.boost.org/libs/math/doc/html/dist.html">
                    Statistical Distributions and Functions
                </a> (<code>boost/math/distributions</code>)
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <a href="https://www.boost.org/libs/math/doc/html/special.html">
                        Special Functions
                    </a> from <code>boost/math/special_functions</code>
                </span>
                <a href="https://www.boost.org/libs/math/doc/html/special.html">
                    Special Functions
                </a> (<code>boost/math/special_functions</code>)
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <a href="https://www.boost.org/libs/math/doc/html/root_finding.html">
                        Root Finding &amp; Minimization Functions
                    </a> from <code>boost/math/tools</code>
                </span>
                <a href="https://www.boost.org/libs/math/doc/html/root_finding.html">
                    Root Finding &amp; Minimization Functions
                </a> (<code>boost/math/tools</code>)
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <a href="https://www.boost.org/libs/multi_index/">
                        Multi-index
                    </a> from <code>boost/multi_index</code>
                </span>
                <a href="https://www.boost.org/libs/multi_index/">
                    Multi-index
                </a> (<code>boost/multi_index</code>)
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <a href="https://www.boost.org/libs/heap/">
                        Heap
                    </a> from <code>boost/heap</code>
                </span>
                <a href="https://www.boost.org/libs/heap/">
                    Heap
                </a> (<code>boost/heap</code>)
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    The flat containers from
                    <a href="https://www.boost.org/libs/container/">Container</a>:
                    <code>boost/container/flat_map</code>, and
                    <code>boost/container/flat_set</code>
                </span>
                <a href="https://www.boost.org/libs/container/">Container</a>のThe flat containers
                (<code>boost/container/flat_map</code>, <code>boost/container/flat_set</code>)
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <a href="https://www.boost.org/libs/intrusive/">Intrusive</a>
                    from <code>boost/intrusive</code>.
                </span>
                <a href="https://www.boost.org/libs/intrusive/">Intrusive</a> (<code>boost/intrusive</code>)
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <a href="https://www.boost.org/libs/sort/">
                        The
                        <code>boost/sort</code> library
                    </a>.
                </span>
                <a href="https://www.boost.org/libs/sort/">
                    The
                    <code>boost/sort</code> library
                </a>
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    <a href="https://www.boost.org/libs/preprocessor/">Preprocessor</a>
                    from <code>boost/preprocessor</code>.
                </span>
                <a href="https://www.boost.org/libs/preprocessor/">Preprocessor</a>
                (<code>boost/preprocessor</code>)
            </span>
        </li>
    </ul>

    <p>
        <span>
            <span class="src">
                We are actively considering adding other Boost
                features to the list, so this list may be expanded in
                the future.
            </span>
            なお、他のBoostの機能についても、随時リストへの追加を検討しています。将来的にこのリストは拡張されることがあります。
        </span>
    </p>


    <a id="C++11"></a>
    <h3 id="Other_Features"><span title="Other C++ Features">その他のC++機能</span></h3>

    <p>
        <span>
            <span class="src">
                As with <a href="#Boost">Boost</a>, some modern C++
                extensions encourage coding practices that hamper
                readability&#8212;for example by removing
                checked redundancy (such as type names) that may be
                helpful to readers, or by encouraging template
                metaprogramming.
            </span>
            前述の<a href="#Boost">Boost</a>も含め、現代的なC++を拡張するライブラリの中には、可読性を妨げるようなコーディングプラクティスを取り入れているものもあります。
            たとえば、型名などの読者の助けになるはずの冗長性を省いてしまったり、テンプレートメタプログラミングを積極的に採用しているものなどがあります。
        </span>
        <span>
            <span class="src">
                Other extensions duplicate functionality
                available through existing mechanisms, which may lead to confusion
                and conversion costs.
            </span>
            その他の拡張は、既存のメカニズムで実現可能なことと重複しており、これらは困惑の元になったり議論のコストに繋がったりするかもしれません。
        </span>
    </p>
    <p class="decision"></p>

    <p>
        <span>
            <span class="src">
                In addition to what's described in the rest of the style
                guide, the following C++ features may not be used:
            </span>
            本ガイドの他のパートで説明している事柄に加えて、以下に示すC++の機能は使ってはいけません。
        </span>
    </p>

    <ul>

        <li>
            <span>
                <span class="src">
                    Compile-time rational numbers
                    (<code>&lt;ratio&gt;</code>), because of concerns that
                    it's tied to a more template-heavy interface
                    style.
                </span>
                コンパイル時有理数(<code>&lt;ratio&gt;</code>ヘッダー)。
                これらのインターフェースはテンプレートを多用しているため、それを採用するコードでもそのようなスタイルに繋がりやすくなります。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    The <code>&lt;cfenv&gt;</code> and
                    <code>&lt;fenv.h&gt;</code> headers, because many
                    compilers do not support those features reliably.
                </span>
                <code>&lt;cfenv&gt;</code>と<code>&lt;fenv.h&gt;</code>ヘッダー。
                これらの機能は、多くのコンパイラにおいて信頼性がありません。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    The <code>&lt;filesystem&gt;</code> header, which

                    does not have sufficient support for testing, and suffers
                    from inherent security vulnerabilities.
                </span>
                <code>&lt;filesystem&gt;</code>ヘッダー。
                これらの機能は、テストに対するサポートが不十分であり、また、その性質上セキュリティの脆弱性につながりやすくもあります。
            </span>

        </li>
    </ul>

    <h3 id="Nonstandard_Extensions"><span title="Nonstandard Extensions">非標準の拡張</span></h3>

    <p>
        <span>
            <span class="src">
                Nonstandard extensions to C++ may not be used unless otherwise specified.
            </span>
            C++非標準の拡張は、特別に認められたものを除いて使ってはいけません。
        </span>
    </p>
    <p class="definition"></p>
    <p>
        <span>
            <span class="src">
                Compilers support various extensions that are not part of standard C++.
            </span>
            コンパイラは、様々なC++非標準の拡張を提供しています。
        </span>
        <span>
            <span class="src">
                Such
                extensions include GCC's <code>__attribute__</code>, intrinsic functions such
                as <code>__builtin_prefetch</code> or SIMD, <code>#pragma</code>, inline
                assembly, <code>__COUNTER__</code>, <code>__PRETTY_FUNCTION__</code>,
                compound statement expressions (e.g., <code>foo = ({ int x; Bar(&amp;x); x
                 })</code>, variable-length arrays and <code>alloca()</code>, and the
                "<a href="https://en.wikipedia.org/wiki/Elvis_operator">Elvis
                  Operator</a>" <code>a?:b</code>..
            </span>
            たとえばGCCでサポートされている非標準の拡張機能としては、<code>__attribute__</code>、<code>__builtin_prefetch</code>・SIMDのような組み込み関数、<code>#pragma</code>、インラインアセンブリ、<code>__COUNTER__</code>、<code>__PRETTY_FUNCTION__</code>、<code>foo = ({ int x; Bar(&amp;x); x })</code>のような複合文、可変長配列と<code>alloca()</code>、「<a href="https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%AB%E3%83%93%E3%82%B9%E6%BC%94%E7%AE%97%E5%AD%90">エルビス演算子</a>」<code>a?:b</code>などが含まれます。
        </span>
    </p>
    <p class="pros"></p>
    <ul>
        <li>
            <span>
                <span class="src">
                    Nonstandard extensions may provide useful features that do not exist
                    in standard C++.
                </span>
                非標準の拡張によって、標準のC++の範囲では実現できない便利な機能が提供されます。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Important performance guidance to the compiler can only be specified
                    using extensions.
                </span>
                重要なパフォーマンス上のガイドをコンパイラに伝えるためには、このような拡張機能を使うしかない場合があります。
            </span>
        </li>
    </ul>

    <p class="cons"></p>
    <ul>
        <li>
            <span>
                <span class="src">
                    Nonstandard extensions do not work in all compilers.
                </span>
                非標準の拡張は、すべてのコンパイラで機能するわけではありません。
            </span>
            <span>
                <span class="src">
                    Use of nonstandard
                    extensions reduces portability of code.
                </span>
                このような拡張を使用すると、コードの移植性が低下します。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Even if they are supported in all targeted compilers, the extensions
                    are often not well-specified, and there may be subtle behavior differences
                    between compilers.
                </span>
                ターゲットとするすべてのコンパイラにおいて目的の拡張機能がサポートされていたとしても、それらの拡張機能は仕様が十分に定められていなかったり、コンパイラ間で微妙に挙動が異なったりする場合があります。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Nonstandard extensions add to the language features that a reader must
                    know to understand the code.
                </span>
                非標準の拡張によって使用する言語機能が増えると、コードの読者が学ばなければいけないことも増えます。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Nonstandard extensions require additional work to port across architectures.
                </span>
                非標準の拡張が使用されていると、アーキテクチャ間をまたいだ移植の際に、追加の作業を必要とします。
            </span>
        </li>
    </ul>

    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                Do not use nonstandard extensions.
            </span>
            非標準の拡張を使ってはいけません。
        </span>
        <span>
            <span class="src">
                You may use portability wrappers that
                are implemented using nonstandard extensions, so long as those wrappers

                are provided by a designated project-wide portability
                  header.
            </span>
            なお、プロジェクトにおいて、非標準拡張機能の移植性を解決することを目的とした、プロジェクト全体から使用可能なラッパーライブラリが提供されている場合は、それらを通して非標準の機能を使用してもかまいません。
        </span>
    </p>

    <h3 id="Aliases"><span title="Aliases">エイリアス</span></h3>

    <p>
        <span>
            <span class="src">
                Public aliases are for the benefit of an API's user, and should be clearly documented.
            </span>
            APIのユーザの利益となるようなエイリアスのみを公開します。
            また、公開するエイリアスについては明確なドキュメントを用意します。
        </span>
    </p>
    <p class="definition"></p>
    <p>
        <span>
            <span class="src">
                There are several ways to create names that are aliases of other entities:
            </span>
            C++において、他のエンティティへのエイリアスとして新しい名前をつける方法はいくつかあります。
        </span>
    </p>
    <div>
    <div class="src">
    <pre>typedef Foo Bar; // But prefer `using` in C++ code.
using ::other_namespace::Foo;
using enum MyEnumType;  // Creates aliases for all enumerators in MyEnumType.
</pre></div><pre>typedef Foo Bar; // C++では `using` を使う方が好ましい
using ::other_namespace::Foo;
using enum MyEnumType;  // MyEnumTypeの全列挙子のエイリアスを作る
</pre></div>

    <p>
        <span>
            <span class="src">
                In new code, <code>using</code> is preferable to <code>typedef</code>,
                because it provides a more consistent syntax with the rest of C++ and works
                with templates.
            </span>
            新しく書くコードにおいては、<code>typedef</code>より<code>using</code>を使う方が望ましいです。
            <code>using</code>の方が、よりC++の他の文法との一貫性があり、また、テンプレートとの相性もよいためです。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Like other declarations, aliases declared in a header file are part of that
                header's public API unless they're in a function definition, in the private portion of a class,
                or in an explicitly-marked internal namespace. Aliases in such areas or in <code>.cc</code> files
                are implementation details (because client code can't refer to them), and are not restricted by
                this rule.
            </span>
            他の宣言と同様に、ヘッダーファイルにおけるエイリアスの宣言は、その宣言が公開部分にある場合、同ヘッダーが提供するAPIの一部と見なされます。
            一方で、エイリアスの宣言がクライアントコードから参照できない場所にある場合、たとえば、<code>.cc</code>ファイル内にある場合や、ヘッダーファイル内であっても、関数内部や、クラスの<code>private</code>セクション、明示的に内部用と宣言された名前空間内に存在する場合は、それらの宣言は実装の詳細と見なされ、このルールで課される制限の対象外とします。
        </span>
    </p>
    <p class="pros"></p>
    <ul>
        <li>
            <span>
                <span class="src">
                    Aliases can improve readability by simplifying a long or complicated name.
                </span>
                エイリアスを用いると、長く複雑な名前を単純化できるため、コードの可読性を向上させることができます。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Aliases can reduce duplication by naming in one place a type used repeatedly in an API,
                    which <em>might</em> make it easier to change the type later.
                </span>
                エイリアスを用いると、APIによって何度も繰り返し使われる型の名前を一カ所で命名できるため、コードの重複を減らすことができます。
                また、これによって、将来、その型を変更する機会が生じたときに、その作業を進めやすくする<em>かも</em>しれません。
            </span>
        </li>
    </ul>

    <p class="cons"></p>
    <ul>
        <li>
            <span>
                <span class="src">
                    When placed in a header where client code can refer to them, aliases increase the
                    number of entities in that header's API, increasing its complexity.
                </span>
                クライアントコードから参照可能なヘッダーファイル内でのエイリアス宣言は、そのヘッダーが提供するAPIのエンティティの数を増やすため、APIを複雑化させる要因になります。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Clients can easily rely on unintended details of public aliases, making changes difficult.
                </span>
                クライアントコードは、公開エイリアスの意図しない詳細にいとも簡単に依存してしまえるため、将来の変更を難しくする要因になります。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    It can be tempting to create a public alias that is only intended for use
                    in the implementation, without considering its impact on the API, or on maintainability.
                </span>
                エイリアスを使うことを認めると、APIやそのメンテナンス性に及ぼす影響をよく考えないまま、実装で使用したいがための余分なな公開エイリアスを作ってしまうことを誘引する要因になります。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Aliases can create risk of name collisions
                </span>
                エイリアスは名前衝突のリスクの要因になります。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Aliases can reduce readability by giving a familiar construct an unfamiliar name
                </span>
                馴染みのある構造に対して、馴染みのないエイリアス名をつけてしまうと、コードの可読性を低下させる要因になります。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Type aliases can create an unclear API contract:
                    it is unclear whether the alias is guaranteed to be identical to the type it aliases,
                    to have the same API, or only to be usable in specified narrow ways
                </span>
                型のエイリアスは、APIの規約を不明瞭にする要因になります。
                エイリアスが、そのエイリアス先の型と常に同等であり、同じAPIを持つことが保証されているのか、あるいは、その所定の狭い方法でのみ使うことを目的としているのかが明確でなくなってしまうことがあります。
            </span>
        </li>
    </ul>

    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                Don't put an alias in your public API just to save typing in the implementation;
                do so only if you intend it to be used by your clients.
            </span>
            公開APIには、クライアントコードによって使用されることを意図したエイリアスのみを宣言してください。実装時のタイピング数を減らす目的では、公開APIにエイリアスを宣言してはいけません。
        </span>
    </p>
    <p>
        <span>
            <span class="src">
                When defining a public alias, document the intent of
                the new name, including whether it is guaranteed to always be the same as the type
                it's currently aliased to, or whether a more limited compatibility is
                intended.
            </span>
            公開エイリアスを定義するときは、新しい名前を導入する意図をドキュメントに記述してください。
            その際、エイリアスが、エイリアス先の型と常に同等であることが保証されているのか、あるいは、それよりももっと限定された互換性の範囲でのみ使われることを意図して定義されているのかについて述べるようにしてください。
        </span>
        <span>
            <span class="src">
                This lets the user know whether they can treat the types as
                substitutable or whether more specific rules must be followed, and can help the
                implementation retain some degree of freedom to change the alias.
            </span>
            これによって、APIのユーザーは、それらのエイリアスを型の単純な置き換えとして扱ってよいのか、あるいは、何らかのルールに従う必要があるのか判断することができるようになります。
            同時に、その実装において、エイリアスの変更に対する一定の自由度を確保することもできるようになるでしょう。
        </span>
    </p>
    <p>
        <span>
            <span class="src">
                Don't put namespace aliases in your public API. (See also <a href="#Namespaces">Namespaces</a>).
            </span>
            名前空間へのエイリアスを公開APIに含めてはいけません(<a href="#Namespaces">名前空間</a>を参照)。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                For example, these aliases document how they are intended to be used in client code:
            </span>
            以下のコード例では、それぞれのエイリアスがクライアントコードからどのように扱われることを意図しているかについてドキュメント化しています。
        </span>
    </p>
    <div>
        <div class="src">
            <pre>namespace mynamespace {
// Used to store field measurements. DataPoint may change from Bar* to some internal type.
// Client code should treat it as an opaque pointer.
using DataPoint = ::foo::Bar*;

// A set of measurements. Just an alias for user convenience.
using TimeSeries = std::unordered_set&lt;DataPoint, std::hash&lt;DataPoint&gt;, DataPointComparator&gt;;
}  // namespace mynamespace
</pre>
        </div>
        <pre>namespace mynamespace {
// フィールドの測定値を保存するために使います。
// DataPoint は Bar* から他の内部表現用の型に変更されるかもしれません。
// クライアントコードにおいては、これを透過的なポインタとして扱ってください。
using DataPoint = ::foo::Bar*;

// 測定値のセットを表します。
// このエイリアスは、単に利便性のために定義されています。
using TimeSeries = std::unordered_set&lt;DataPoint, std::hash&lt;DataPoint&gt;, DataPointComparator&gt;;
}  // namespace mynamespace
</pre>
    </div>
    <p>
        <span>
            <span class="src">
                These aliases don't document intended use, and half of them aren't meant for client use:
            </span>
            一方で、次の例では、エイリアスの意図に関する記述がなく、また定義の半分についてはクライアントコードから使われることを意図したものですらありません。
        </span>
    </p>
    <div>
        <div class="src">
            <pre class="badcode">namespace mynamespace {
// Bad: none of these say how they should be used.
using DataPoint = ::foo::Bar*;
using ::std::unordered_set;  // Bad: just for local convenience
using ::std::hash;           // Bad: just for local convenience
typedef unordered_set&lt;DataPoint, hash&lt;DataPoint&gt;, DataPointComparator&gt; TimeSeries;
}  // namespace mynamespace
</pre>
        </div>
        <pre class="badcode">namespace mynamespace {
// ダメ: どのように扱われるべきか書かれていない。
using DataPoint = ::foo::Bar*;
using ::std::unordered_set;  // ダメ: 実装の利便性のためだけに定義されている
using ::std::hash;           // ダメ: 実装の利便性のためだけに定義されている
typedef unordered_set&lt;DataPoint, hash&lt;DataPoint&gt;, DataPointComparator&gt; TimeSeries;
}  // namespace mynamespace
</pre>
</div>
    <p>
        <span>
            <span class="src">
                However, local convenience aliases are fine in function definitions, <code>private</code> sections of
                classes, explicitly marked internal namespaces, and in <code>.cc</code> files:
            </span>
            ただし、関数定義の中など、クライアントコードからアクセスできない場所であれば、このような実装の利便性のためのエイリアスを定義してもかまいません。同様に、クラスの<code>private</code>セクション、明示的に内部利用とマークされた名前空間の中、<code>.cc</code>ファイル内などでも問題ありません。
        </span>
    </p>

    <div>
        <div class="src">
            <pre>// In a .cc file
using ::foo::Bar;
</pre>
        </div>
        <pre>// .ccファイル内
using ::foo::Bar;
</pre>
    </div>

    <h3 id="Switch_Statements"><span title="Switch Statements">switch文</span></h3>


    <p>
        <span>
            <span class="src">
                If not conditional on an enumerated value, switch statements should always
                have a <code>default</code> case (in the case of an enumerated value, the
                compiler will warn you if any values are not handled).
            </span>
            <code>switch</code>文の条件式が列挙型でない場合は、必ず<code>default</code>ブロックが必要です。
            (列挙型の値による<code>switch</code>文については、対応漏れがある場合にコンパイラが警告してくれるでしょう。)
        </span>
        <span>
            <span class="src">
                If the default case
                should never execute, treat this as an error. For example:
            </span>
            プログラムの構造上、<code>default</code>ブロックが実行される機会は絶対にないという場合には、次の例のようにエラーとして扱うようにしてください。
        </span>
    </p>

<pre>switch (var) {
  case 0: {
    ...
    break;
  }
  case 1: {
    ...
    break;
  }
  default: {
    LOG(FATAL) &lt;&lt; "Invalid value in switch statement: " &lt;&lt; var;
  }
}
</pre>


    <p>
        <span>
            <span class="src">
                Fall-through from one case label to another must be annotated using the
                <code>[[fallthrough]];</code> attribute.
            </span>
            ある<code>case</code>ラベルから別のラベルへフォールスルーさせる場合は、必ず<code>[[fallthrough]];</code>属性でマークしてください。
        </span>
        <span>
            <span class="src">
                <code>[[fallthrough]];</code> should
                be placed at a point of execution where a fall-through to the next case label
                occurs.
            </span>
            <code>[[fallthrough]];</code>は次のラベルへのフォールスルーがまさに起こる場所に記述します。
        </span>
        <span>
            <span class="src">
                A common exception is consecutive case labels without intervening code,
                in which case no annotation is needed.
            </span>
            ただし、間にコードを含まず<code>case</code>ラベルが連続している場合には、マークは不要です。
        </span>
    </p>

    <div><div class="src"><pre>switch (x) {
  case 41:  // No annotation needed here.
  case 43:
    if (dont_be_picky) {
      // Use this instead of or along with annotations in comments.
      [[fallthrough]];
    } else {
      CloseButNoCigar();
      break;
    }
  case 42:
    DoSomethingSpecial();
    [[fallthrough]];
  default:
    DoSomethingGeneric();
    break;
}</pre></div><pre>switch (x) {
  case 41:  // ここには [[fallthrough]]; は不要です。
  case 43:
    if (dont_be_picky) {
      // コメントのかわりに(あるいは、コメントとともに)、
      // このようにマークします。
      [[fallthrough]];
    } else {
      CloseButNoCigar();
      break;
    }
  case 42:
    DoSomethingSpecial();
    [[fallthrough]];
  default:
    DoSomethingGeneric();
    break;
}</pre></div>


    <h2 id="Inclusive_Language"><span title="Inclusive Language">インクルーシブ・ランゲージ</span></h2>

    <p>
        <span>
            <span class="src">
                In all code, including naming and comments, use inclusive language
                and avoid terms that other programmers might find disrespectful or offensive
                (such as "master" and "slave", "blacklist" and "whitelist", or "redline"),
                even if the terms also have an ostensibly neutral meaning.
            </span>
            命名やコメントを含むすべてのコードにおいて「インクルーシブ・ランゲージ」を使用します。
            他のプログラマーにとって、無礼または不快に感じられる可能性のある用語 (「マスター」と「スレーブ」、「ブラックリスト」と「ホワイトリスト」、または「レッドライン」など) は、その用語の表面上の意味が中立的なものであったとしても、使用するのを避けてください。
        </span>
        <span>
            <span class="src">
                Similarly, use gender-neutral language unless you're referring
                to a specific person (and using their pronouns).
            </span>
            同様に、ある特定の人(および、その人の代名詞)に言及しようとしている場合を除き、ジェンダーに中立な言葉を使用してください。
        </span>
        <span>
            <span class="src">
                For example,
                use "they"/"them"/"their" for people of unspecified gender
                (<a href="https://apastyle.apa.org/style-grammar-guidelines/grammar/singular-they">even
                    when singular</a>), and "it"/"its" for software, computers, and other
                things that aren't people.
            </span>
            たとえば、ジェンダーを特定せずに人を指す言葉として(<a href="https://apastyle.apa.org/style-grammar-guidelines/grammar/singular-they">単数の場合でも</a>)
             "they" / "them" / "their" を使用します。"it" / "its" は、ソフトウェアやコンピューターなどの<em>もの</em>に対して使用し、人に対しては用いません。
        </span>
    </p>

    <h2 id="Naming"><span title="Naming">命名規則</span></h2>

    <p>
        <span>
            <span class="src">
                The most important consistency rules are those that govern
                naming.
            </span>
            コードの一貫性を保つためのもっとも重要なルールは、名前の付け方を決めることです。
        </span>
        <span>
            <span class="src">
                The style of a name immediately informs us what sort of
                thing the named entity is: a type, a variable, a function, a
                constant, a macro, etc., without requiring us to search for the
                declaration of that entity.
            </span>
            名前のスタイルを適切に定めることで、それが<em>何であるか</em>、すなわち、型なのか、変数なのか、関数なのか、定数なのか、マクロなのか、その宣言を探すことなく、すぐにわかるようにすることができます。

        </span>
        <span>
            <span class="src">
                The pattern-matching engine in our
                brains relies a great deal on these naming rules.
            </span>
            私たちの脳がもつパターンマッチングエンジンは、こうした命名規則に大きく依存しています。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Naming rules are pretty arbitrary, but
                we feel that
                consistency is more important than individual preferences in this
                area, so regardless of whether you find them sensible or not,
                the rules are the rules.
            </span>
            命名規則はかなり恣意的なものですが、私たちは、この領域において、個人の好みよりも、一貫性が保たれることを重要視しています。
            ですので、以下で定める命名規則については、あなたがわかりやすいと感じるかどうかに関わらず、「ルールはルール」と考えるようにしてください。
        </span>
    </p>

    <h3 id="General_Naming_Rules"><span title="General Naming Rules">全般的な命名規則</span></h3>

    <p>
        <span>
            <span class="src">
                Optimize for readability using names that would be clear
                even to people on a different team.
            </span>
            プロジェクトチーム外のメンバーがコードを見たとしても意図が明確に伝わるような命名を行い、コードの可読性を最適化してください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Use names that describe the purpose or intent of the object.
            </span>
            オブジェクトには、そのオブジェクトの目的や意図を説明する名前を付けてください。
        </span>
        <span>
            <span class="src">
                Do not worry about saving horizontal space as it is far
                more important to make your code immediately
                understandable by a new reader.
            </span>
            画面の横幅を節約する必要はありません。そんなことよりも、コードを新しい読者でも直感的に理解できるようにしておくことの方がはるかに重要です。
        </span>
        <span>
            <span class="src">
                Minimize the use of
                abbreviations that would likely be unknown to someone outside
                your project (especially acronyms and initialisms).
            </span>
            プロジェクトチーム外の読者が知らないかもしれない省略語(特に、頭字語やイニシャル化すること)は最小限にとどめてください。
        </span>
        <span>
            <span class="src">
                Do not
                abbreviate by deleting letters within a word.
            </span>
            単語の中の文字を削って省略系を作ってはいけません。
        </span>
        <span>
            <span class="src">
                As a rule of thumb, an abbreviation is probably OK if it's listed in
                Wikipedia.
            </span>
            経験則としてWikipediaに載っているような省略系であれば概ねOKと言えるでしょう。
        </span>
        <span>
            <span class="src">
                Generally speaking, descriptiveness should be
                proportional to the name's scope of visibility.
            </span>
            一般論として、名前は、その名前が見えるスコープの大きさに比例してその詳細度を決めるようにします。
        </span>
        <span>
            <span class="src">
                For example,
                <code>n</code> may be a fine name within a 5-line function,
                but within the scope of a class, it's likely too vague.
            </span>
            たとえば、「<code>n</code>」という名前は、5行しかない関数の中であれば悪くない命名ですが、クラススコープ変数に対する命名としては曖昧すぎるでしょう。
        </span>

    </p>
    <div>
        <div class="src">
            <pre>class MyClass {
 public:
  int CountFooErrors(const std::vector&lt;Foo&gt;&amp; foos) {
    int n = 0;  // Clear meaning given limited scope and context
    for (const auto&amp; foo : foos) {
      ...
      ++n;
    }
    return n;
  }
  void DoSomethingImportant() {
    std::string fqdn = ...;  // Well-known abbreviation for Fully Qualified Domain Name
  }
 private:
  const int kMaxAllowedConnections = ...;  // Clear meaning within context
};
</pre>
        </div>
        <pre>class MyClass {
 public:
  int CountFooErrors(const std::vector&lt;Foo&gt;&amp; foos) {
    int n = 0;  // スコープと文脈が限られているため十分明確
    for (const auto&amp; foo : foos) {
      ...
      ++n;
    }
    return n;
  }
  void DoSomethingImportant() {
    std::string fqdn = ...;  // 一般的によく使われる、Fully Qualified Domain Name の略語
  }
 private:
  const int kMaxAllowedConnections = ...;  // この文脈において意味が明確
}; </pre>
    </div>

    <div>
        <div class="src">
            <pre class="badcode">class MyClass {
 public:
  int CountFooErrors(const std::vector&lt;Foo&gt;&amp; foos) {
    int total_number_of_foo_errors = 0;  // Overly verbose given limited scope and context
    for (int foo_index = 0; foo_index &lt; foos.size(); ++foo_index) {  // Use idiomatic `i`
      ...
      ++total_number_of_foo_errors;
    }
    return total_number_of_foo_errors;
  }
  void DoSomethingImportant() {
    int cstmr_id = ...;  // Deletes internal letters
  }
 private:
  const int kNum = ...;  // Unclear meaning within broad scope
};
</pre>
        </div>
        <pre class="badcode">class MyClass {
 public:
  int CountFooErrors(const std::vector&lt;Foo&gt;&amp; foos) {
    int total_number_of_foo_errors = 0;  // 十分に狭いスコープと文脈に対して、名前が冗長すぎ
    for (int foo_index = 0; foo_index &lt; foos.size(); ++foo_index) {  // 慣用的`i`を使うべき
      ...
      ++total_number_of_foo_errors;
    }
    return total_number_of_foo_errors;
  }
  void DoSomethingImportant() {
    int cstmr_id = ...;  // 単語の途中の文字が削られていると読みにくい
  }
 private:
  const int kNum = ...;  // スコープが広く、何を表すのか不明瞭
};
</pre>
    </div>

    <p>
        <span>
            <span class="src">
                Note that certain universally-known abbreviations are OK, such as
                <code>i</code> for an iteration variable and <code>T</code> for a
                template parameter.
            </span>
            なお、イテレーション変数の<code>i</code>、テンプレート引数の<code>T</code>など、一般に広く知られている短縮形を用いることは問題ありません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                For the purposes of the naming rules below, a "word" is anything that you
                would write in English without internal spaces.
            </span>
            これ以降の命名規則のルールにおいて、「単語」とは、英語で書くときにスペースを含まずに綴られるもののことを指すとします。
        </span>
        <span>
            <span class="src">
                This includes abbreviations,
                such as acronyms and initialisms.
            </span>
            これには、頭字語やイニシャルなどの略語も含みます。
        </span>
        <span>
            <span class="src">
                For names written in mixed case (also
                sometimes referred to as
                "<a href="https://en.wikipedia.org/wiki/Camel_case">camel case</a>" or
                "<a href="https://en.wiktionary.org/wiki/Pascal_case">Pascal case</a>"), in
                which the first letter of each word is capitalized, prefer to capitalize
                abbreviations as single words, e.g., <code>StartRpc()</code> rather than
                <code>StartRPC()</code>.
            </span>
            つまり、各単語の頭文字を大文字として大文字小文字を混在させた命名(「<a href="https://en.wikipedia.org/wiki/Camel_case">キャメルケース</a>」または「<a href="https://en.wiktionary.org/wiki/Pascal_case">パスカルケース</a>」と呼ばれるもの)において、略語も1つの単語であるかのように表記します。例えば <code>StartRPC()</code>ではなく<code>StartRpc()</code>とします。
        </span>
    </p>
    <p>
        <span>
            <span class="src">
                Template parameters should follow the naming style for their
                category: type template parameters should follow the rules for
                <a href="#Type_Names">type names</a>, and non-type template
                parameters should follow the rules for <a href="#Variable_Names">
                variable names</a>.
            </span>
            テンプレート引数の命名規則は、それぞれの引数が属するカテゴリに従います。
            つまり、テンプレート引数が型引数ならば<a href="#Type_Names">型の命名規則</a>に従い、それ以外の非型引数は<a href="#Variable_Names">変数の命名規則</a>に従います。
        </span>

    </p>
    <h3 id="File_Names"><span title="File Names">ファイル名</span></h3>

    <p>
        <span>
            <span class="src">
                Filenames should be all lowercase and can include
                underscores (<code>_</code>) or dashes (<code>-</code>).
            </span>
            ファイル名はすべて小文字とします。アンダースコア(<code>_</code>)かダッシュ(<code>-</code>)を含めてもかまいません。
        </span>
        <span>
            <span class="src">
                Follow the convention that your

                project uses.
            </span>
            プロジェクトで採用している命名規則に従ってください。
        </span>
        <span>
            <span class="src">
                If there is no consistent
                local pattern to follow, prefer "<code>_</code>".
            </span>
            従うべき一貫したルールが定められていない場合には、アンダースコアを使ってください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Examples of acceptable file names:
            </span>
            例として、次のようなファイル名は問題ありません。
        </span>
    </p>

    <ul>
        <li>
            <code>my_useful_class.cc</code>
        </li>
        <li>
            <code>my-useful-class.cc</code>
        </li>
        <li>
            <code>myusefulclass.cc</code>
        </li>
        <li>
            <span>
                <span class="src">
                    <code>myusefulclass_test.cc // _unittest and _regtest are deprecated.</code>
                </span>
                <code>myusefulclass_test.cc // _unittest や _regtest は廃止</code>
            </span>
        </li>
    </ul>

    <p>
        <span>
            <span class="src">
                C++ files should end in
                <code>.cc</code> and header files should end in
                <code>.h</code>.
            </span>
            ソースファイルの拡張子は<code>.cc</code>、ヘッダーファイルの拡張子は<code>.h</code>とします。
        </span>
        <span>
            <span class="src">
                Files that rely on being textually included at specific points
                should end in
                <code>.inc</code> (see also the section on
                <a href="#Self_contained_Headers">self-contained headers</a>).
            </span>
            特定の場所にそのままインクルードされることを意図しているファイルには、拡張子<code>.inc</code>をつけます(<a href="#Self_contained_Headers">自己完結型ヘッダー</a>のセクションも参照してください)。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Do not use filenames that already exist in
                <code>/usr/include</code>, such as
                <code>db.h</code>.
            </span>
            既に<code>/usr/include</code>に存在するファイル名(たとえば<code>db.h</code>など)をつけてはいけません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                In general, make your filenames very specific.
            </span>
            一般に、ファイル名は非常に具体的な名前となるようにしてください。
        </span>
        <span>
            <span class="src">
                For
                example, use <code>http_server_logs.h</code> rather than
                <code>logs.h</code>.
            </span>
            たとえば、単に<code>logs.h</code>とはせず、<code>http_server_logs.h</code>のような命名を行ってください。
        </span>
        <span>
            <span class="src">
                A very common case is to have a pair
                of files called, e.g.,
                <code>foo_bar.h</code> and
                <code>foo_bar.cc</code>, defining a class called
                <code>FooBar</code>.
            </span>
            非常に良くあるパターンは、ファイルのペア<code>foo_bar.h</code>と<code>foo_bar.cc</code>でクラス<code>FooBar</code>を定義するようなやり方です。
        </span>
    </p>
    <h3 id="Type_Names"><span title="Type Names">型名</span></h3>

    <p>
        <span>
            <span class="src">
                Type names start with a capital letter and have a capital
                letter for each new word, with no underscores:
                <code>MyExcitingClass</code>,
                <code>MyExcitingEnum</code>.
            </span>
            型の名前は大文字で始め、単語ごとの頭文字を大文字にします。アンダースコアは使いません。たとえば、<code>MyExcitingClass</code>、<code>MyExcitingEnum</code>のようにします。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                The names of all types — classes, structs, type aliases,
                enums, and type template parameters — have the same naming convention.
            </span>
            型に類するもの、すなわちクラス、構造体、型のエイリアス、列挙型、型テンプレート引数はすべて、この規則に従って命名します。
        </span>
        <span>
            <span class="src">
                Type names should start with a capital letter and have a capital letter
                for each new word.
            </span>
            型の名前は大文字で始めて、新しい単語ごとに頭文字を大文字にします。
        </span>
        <span>
            <span class="src">
                No underscores.
            </span>
            アンダースコアは使いません。
        </span>
        <span>
            <span class="src">
                For example:
            </span>
            以下に例を示します。
        </span>
    </p>
    <div>
        <div class="src">
            <pre>// classes and structs
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedefs
typedef hash_map&lt;UrlTableProperties *, std::string&gt; PropertiesMap;

// using aliases
using PropertiesMap = hash_map&lt;UrlTableProperties *, std::string&gt;;

// enums
enum class UrlTableError { ...
</pre>
        </div>
        <pre>// クラスと構造体
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedef
typedef hash_map&lt;UrlTableProperties *, std::string&gt; PropertiesMap;

// usingエイリアス
using PropertiesMap = hash_map&lt;UrlTableProperties *, std::string&gt;;

// 列挙型
enum class UrlTableError { ...
</pre>
    </div>

    <h3 id="Variable_Names"><span title="Variable Names">変数名</span></h3>

    <p>
        <span>
            <span class="src">
                The names of variables (including function parameters) and data members are
                <code>snake_case</code> (all lowercase, with underscores between words).
            </span>
            変数や関数引数、データメンバーの名前には、<code>snake_case</code>(すべて小文字、単語間はアンダースコア)を使います。
        </span>
        <span>
            <span class="src">
                Data members of classes
                (but not structs) additionally have trailing underscores.
            </span>
            構造体を除くクラスのデータメンバ名には、末尾に追加のアンダースコアをつけます。
        </span>
        <span>
            <span class="src">
                For instance:
                <code>a_local_variable</code>, <code>a_struct_data_member</code>,
                <code>a_class_data_member_</code>.
            </span>
            たとえば、それぞれ、<code>a_local_variable</code>、<code>a_struct_data_member</code>、<code>a_class_data_member_</code>のようにします。
        </span>
    </p>

    <h4 class="stylepoint_subsection"><span title="Common Variable names">一般的な変数名</span></h4>

    <p>
        <span>
            <span class="src">
                For example:
            </span>
            以下に例を示します。
        </span>
    </p>
    <div>
        <div class="src">
            <pre>std::string table_name;  // OK - snake_case.
</pre>
        </div>
        <pre>std::string table_name;  // OK - snake_caseになっている
</pre>
    </div>
    <div>
        <div class="src">
            <pre class="badcode">std::string tableName;   // Bad - mixed case.
</pre>
        </div>
        <pre class="badcode">std::string tableName;   // ダメ - 大文字小文字が混ざっている。
</pre>
    </div>
    <h4 class="stylepoint_subsection"><span title="Class Data Members">クラスのデータメンバ</span></h4>

    <p>
        <span>
            <span class="src">
                Data members of classes, both static and non-static, are
                named like ordinary nonmember variables, but with a
                trailing underscore.
            </span>
            クラスのデータメンバは、<code>static</code>の有無にかかわらず、通常の変数と同様の命名を行い、さらに、末尾に追加のアンダースコアをつけます。
        </span>
    </p>
    <div>
        <div class="src">
            <pre>class TableInfo {
  ...
 private:
  std::string table_name_;  // OK - underscore at end.
  static Pool&lt;TableInfo&gt;* pool_;  // OK.
};
</pre>
        </div>
        <pre>class TableInfo {
  ...
 private:
  std::string table_name_;  // OK。末尾にアンダースコア
  static Pool&lt;TableInfo&gt;* pool_;  // OK。
};
</pre>
    </div>
    <h4 class="stylepoint_subsection"><span title="Struct Data Members">構造体のデータメンバ</span></h4>

    <p>
        <span>
            <span class="src">
                Data members of structs, both static and non-static,
                are named like ordinary nonmember variables.
            </span>
            構造体のデータメンバは、<code>static</code>の有無にかかわらず、通常の変数と同じように名前を付けます。
        </span>
        <span>
            <span class="src">
                They do not have
                the trailing underscores that data members in classes have.
            </span>
            クラスのデータメンバとは異なり、末尾にアンダースコアはつけません。
        </span>
    </p>

    <pre>struct UrlTableProperties {
  std::string name;
  int num_entries;
  static Pool&lt;UrlTableProperties&gt;* pool;
};
</pre>

    <p>
        <span>
            <span class="src">
                See
                <a href="#Structs_vs._Classes">
                    Structs vs.
                    Classes
                </a> for a discussion of when to use a struct
                versus a class.
            </span>
            構造体とクラスの使い分けに関する議論については、<a href="#Structs_vs._Classes">構造体か、クラスか</a>を参照してください。
        </span>
    </p>
    <h3 id="Constant_Names"><span title="Constant Names">定数名</span></h3>

    <p>
        <span>
            <span class="src">
                Variables declared <code>constexpr</code> or <code>const</code>, and whose value is fixed for
                the duration of the program, are named with a leading "k" followed
                by mixed case.
            </span>
            <code>constexpr</code>や<code>const</code>で宣言され、かつ、プログラムの最初から最後まで常に不変の固定の値をもつ変数は、頭に「k」をつけた上で、大文字小文字混じりの名前を付けます。
        </span>
        <span>
            <span class="src">
                Underscores can be used as separators in the rare cases
                where capitalization cannot be used for separation.
            </span>
            単語の境界において大文字化することができない場合は、アンダースコアを区切りとして使ってもかまいません。
        </span>
        <span>
            <span class="src">
                For example:
            </span>
            以下に例を示します。
        </span>
    </p>
    <pre>const int kDaysInAWeek = 7;
const int kAndroid8_0_0 = 24;  // Android 8.0.0</pre>
    <p>
        <span>
            <span class="src">
                All such variables with static storage duration (i.e., statics and globals,
                see
                <a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">
                    Storage Duration
                </a> for details) should be named this way, including those in templates where
                different instantiations of the template may have different values.
            </span>
            このような、値が不変の静的記憶域時間の定数変数(すなわち、静的変数やグローバル変数ですが、詳細は<a
            href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">Storage
            Duration</a>を参照してください)は、この規則に従って命名します。これには、テンプレート内の静的変数も含みます(各テンプレートインスタンスごとに変数の値は異なる場合も含みます)。
        </span>
        <span>
            <span class="src">
               This convention is optional for
               variables of other storage classes, e.g., automatic variables; otherwise the usual variable naming
               rules apply.
            </span>
            それ以外の記憶域期間に分類される定数変数(自動変数など)については任意とします。この命名規則に従うか、あるいは、通常の変数と同様の命名規則に従ってください。
        </span>
    </p>
<div>
<div class="src">
<pre>void ComputeFoo(absl::string_view suffix) {
  // Either of these is acceptable.
  const absl::string_view kPrefix = "prefix";
  const absl::string_view prefix = "prefix";
  ...
}
</pre>
</div>
<pre>void ComputeFoo(absl::string_view suffix) {
  // 以下のどちらでもOKです
  const absl::string_view kPrefix = "prefix";
  const absl::string_view prefix = "prefix";
  ...
}
</pre>
</div>
<div>
<div class="src">
<pre class="badcode">void ComputeFoo(absl::string_view suffix) {
  // Bad - different invocations of ComputeFoo give kCombined different values.
  const std::string kCombined = absl::StrCat(kPrefix, suffix);
  ...
}
</pre>
</div>
<pre class="badcode">void ComputeFoo(absl::string_view suffix) {
  // これはダメ。kCombined が関数呼び出し毎に異なる値になりうる
  const std::string kCombined = absl::StrCat(kPrefix, suffix);
  ...
}
</pre></div>

    <h3 id="Function_Names"><span title="Function Names">関数名</span></h3>

    <p>
        <span>
            <span class="src">
                Regular functions have mixed case; accessors and mutators may be named
                like variables.
            </span>
            通常の関数は、大文字小文字を混ぜて命名します。なお、getter関数やsetter関数は、変数名の命名規則に従ってもかまいません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Ordinarily, functions should start with a capital letter and have a
                capital letter for each new word.
            </span>
            通例では、関数名は大文字で始めて、単語ごとに頭文字を大文字にします。
        </span>
    </p>

    <pre>AddTableEntry()
DeleteUrl()
OpenFileOrDie()
</pre>
    <p>
        <span>
            <span class="src">
                (The same naming rule applies to class- and namespace-scope
                constants that are exposed as part of an API and that are intended to look
                like functions, because the fact that they're objects rather than functions
                is an unimportant implementation detail.)
            </span>
            (クラススコープや名前空間スコープの定数において、それがAPIの一部として公開され、かつ、関数のように振る舞う場合には、関数名の命名規則を適用してください。それらの定数が実際には関数ではなくオブジェクトであるという事実は、APIのユーザーにとってあまり重要ではなく、実装の詳細であると言えるからです。)
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Accessors and mutators (get and set functions) may be named like
                variables.
            </span>
            getter関数やsetter関数は、変数のような名前を付けてもかまいません。
        </span>
        <span>
            <span class="src">
                These often correspond to actual member variables, but this is
                not required.
            </span>
            これらは、実際のメンバ変数と紐づけられることが多いですが、必ずしもそうでなくてもかまいません。
        </span>
        <span>
            <span class="src">
                For example, <code>int count()</code> and <code>void
                set_count(int count)</code>.
            </span>
            たとえば、<code>int count()</code>と<code>void set_count(int count)</code>のようにしてもかまいません。
        </span>
    </p>

    <h3 id="Namespace_Names"><span title="Namespace Names">名前空間の名前</span></h3>

    <p>
        <span>
            <span class="src">
                Namespace names are all lower-case, with words separated by underscores.
            </span>
            名前空間は、すべて小文字で、単語間をアンダースコアで区切って名前をつけます。
        </span>
        <span>
            <span class="src">
                Top-level namespace names are
                based on the project name.
            </span>
            最上位の名前空間には、プロジェクト名に基づいた名前をつけます。
        </span>
        <span>
            <span class="src">
                Avoid collisions
                between nested namespaces and well-known top-level namespaces.
            </span>
            ネストされた名前空間であっても、よく知られた最上位名前空間の名前と衝突させるのは避けてください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                The name of a top-level namespace should usually be the
                name of the project or team whose code is contained in that
                namespace.
            </span>
            最上位の名前空間の名前には、通常はプロジェクト名かチーム名をつけます。
        </span>
        <span>
            <span class="src">
                The code in that namespace should usually be in
                a directory whose basename matches the namespace name (or in
                subdirectories thereof).
            </span>
            名前空間に含まれるコードは、通常は、名前空間の名前と同じ名前のディレクトリ(か、そのサブディレクトリ)におきます。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Keep in mind that the <a href="#General_Naming_Rules">rule
                against abbreviated names</a> applies to namespaces just as much
                as variable names.
            </span>
            名前空間の名前には、変数名と同様に<a href="#General_Naming_Rules">省略系に関するルール</a>が適用されることに注意してください。
        </span>
        <span>
            <span class="src">
                Code inside the namespace seldom needs to
                mention the namespace name, so there's usually no particular need
                for abbreviation anyway.
            </span>
            名前空間内のコードが、それを囲む名前空間の名前を必要とすることはめったにありません。
            このため、いずれにせよ、名前空間名に省略系を必要とすることはほとんどないはずです。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Avoid nested namespaces that match well-known top-level
                namespaces.
            </span>
            ネストされた名前空間であっても、よく知られた最上位名前空間の名前と同じにはしないでください。
        </span>
        <span>
            <span class="src">
                Collisions between namespace names can lead to surprising
                build breaks because of name lookup rules.
            </span>
            このような名前空間名の衝突があると、名前検索のルールによって、想定外のビルドエラーを引き起こすことがあります。
        </span>
        <span>
            <span class="src">
                In particular, do not
                create any nested <code>std</code> namespaces.
            </span>
            特に、<code>std</code>という名前の名前空間は、いかなる階層であっても作ってはいけません。
        </span>
        <span>
            <span class="src">
                Prefer unique project
                identifiers
                (<code>websearch::index</code>, <code>websearch::index_util</code>)
                over collision-prone names like <code>websearch::util</code>.
            </span>
            プロジェクト名自体にもユニークな識別子をつけましょう。
            たとえば、<code>websearch::util</code>のような衝突しやすい名前を避け、<code>websearch::index</code>や <code>websearch::index_util</code>のようにします。
        </span>
        <span>
            <span class="src">
                Also avoid overly deep nesting
                namespaces (<a href="https://abseil.io/tips/130">TotW #130</a>).
            </span>
            また、名前空間のネストを深くしすぎないようにしてください(<a href="https://abseil.io/tips/130">TotW #130</a>)。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                For <code>internal</code> namespaces, be wary of other code being
                added to the same <code>internal</code> namespace causing a collision
                (internal helpers within a team tend to be related and may lead to
                collisions).
            </span>
            <code>internal</code>名前空間においては、同じ<code>internal</code>名前空間に追加される他のコードと衝突しないように、特に注意が必要です。(チーム内向けのヘルパー同士がこの関係に陥る傾向があり、ときに衝突につながります)。
        </span>
        <span>
            <span class="src">
                In such a situation, using the filename to make a unique
                internal name is helpful
                (<code>websearch::index::frobber_internal</code> for use
                in <code>frobber.h</code>)
            </span>
            このような場合には、ファイル名を使ってユニークな名前を作る方法が役立ちます(たとえば<code>frobber.h</code>では、<code>websearch::index::frobber_internal</code>のようにします)。
        </span>
    </p>

    <h3 id="Enumerator_Names"><span title="Enumerator Names">列挙型の名前</span></h3>

    <p>
        <span>
            <span class="src">
                Enumerators (for both scoped and unscoped enums) should be named like
                <a href="#Constant_Names">constants</a>, not like
                <a href="#Macro_Names">macros</a>.
                That is, use <code>kEnumName</code> not
                <code>ENUM_NAME</code>.
            </span>
            列挙型(スコープ付き、スコープなしの両方とも)は、<a href="#Constant_Names">定数の命名規則</a>(<code>kEnumName</code>)に従います。<a href="#Macro_Names">マクロの命名規則</a>(<code>ENUM_NAME</code>)は使いません。
        </span>
    </p>

    <pre>enum class UrlTableError {
  kOk = 0,
  kOutOfMemory,
  kMalformedInput,
};
</pre>
    <pre class="badcode">enum class AlternateUrlTableError {
  OK = 0,
  OUT_OF_MEMORY = 1,
  MALFORMED_INPUT = 2,
};
</pre>

    <p>
        <span>
            <span class="src">
                Until January 2009, the style was to name enum values
                like
                <a href="#Macro_Names">macros</a>.
            </span>
            2009年1月までは、列挙値は<a href="#Macro_Names">マクロ</a>の命名規則に従っていましたが、
        </span>
        <span>
            <span class="src">
                This caused
                problems with name collisions between enum values and
                macros.
            </span>
            列挙値とマクロとの間で名前が衝突する問題が起きたため、
        </span>
        <span>
            <span class="src">
                Hence, the change to prefer constant-style naming
                was put in place.
            </span>
            列挙型の名前は定数の命名規則に従うようルールが変更されました。
        </span>
        <span>
            <span class="src">
                New code should use constant-style
                naming.
            </span>
            新しく書くコードでは定数の命名規則に従ってください。
        </span>
    </p>

    <h3 id="Macro_Names"><span title="Macro Names">マクロの名前</span></h3>

    <p>
        <span>
            <span class="src">
                You're not really going to <a href="#Preprocessor_Macros">
                define a macro</a>, are you? If you do, they're like this:
                <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN_AND_ADULTS_ALIKE</code>.
            </span>
            本当は<a href="#Preprocessor_Macros">マクロを定義</a>しようだなんて思ってないですよね……？　
            マクロを定義する場合は、<code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN_AND_ADULTS_ALIKE</code> のように名前をつけます。
            ((訳注: MY_MACRO_THAT_SCARES_SMALL_CHILDREN_AND_ADULTS_ALIKE は「小さな子供も大人も同じように怖がらせる私のマクロ」の意))
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Please see the <a href="#Preprocessor_Macros">description
                of macros</a>; in general macros should <em>not</em> be used.
            </span>
            まず、<a href="#Preprocessor_Macros">マクロの詳細</a>を確認してください。通常、<em>マクロを使うべきではありません</em>。
        </span>
        <span>
            <span class="src">
                However, if they are absolutely needed, then they should be
                named with all capitals and underscores, and with a project-specific prefix.
            </span>
            それでも、どうしてもマクロが必要な場合は、すべてを大文字にし、アンダースコアで単語を区切り、さらにプロジェクト固有の接頭辞をつけて命名してください。
        </span>
    </p>

    <pre>#define MYPROJECT_ROUND(x) ...
</pre>

    <h3 id="Exceptions_to_Naming_Rules"><span title="Exceptions to Naming Rules">命名規則の例外</span></h3>

    <p>
        <span>
            <span class="src">
                If you are naming something that is analogous to an
                existing C or C++ entity then you can follow the existing
                naming convention scheme.
            </span>
            名前をつけようとしている対象のエンティティがC言語やC++における既存の概念と類似している場合は、それらに倣った命名規則に従ってもかまいません。
        </span>
    </p>

    <dl>
        <dt><code>bigopen()</code></dt>
        <dd>
            <span>
                <span class="src">
                    function name, follows form of <code>open()</code>
                </span>
                <code>open()</code>の形に倣っった関数名
            </span>
        </dd>

        <dt><code>uint</code></dt>
        <dd><code>typedef</code></dd>

        <dt><code>bigpos</code></dt>
        <dd>
            <span>
                <span class="src">
                    <code>struct</code> or <code>class</code>, follows
                    form of <code>pos</code>
                </span>
                <code>pos</code>の形に倣った<code>struct</code>や<code>class</code>
            </span>
        </dd>

        <dt><code>sparse_hash_map</code></dt>
        <dd>
            <span>
                <span class="src">
                    STL-like entity; follows STL naming conventions
                </span>
                STLの命名規則に倣ったSTL風のエンティティ
            </span>
        </dd>

        <dt><code>LONGLONG_MAX</code></dt>
        <dd>
            <span>
                <span class="src">
                    a constant, as in <code>INT_MAX</code>
                </span>
                <code>INT_MAX</code>に倣った定数
            </span>
        </dd>
    </dl>

    <h2 id="Comments"><span title="Comments">コメント</span></h2>

    <p>
        <span>
            <span class="src">
                Comments are absolutely vital to keeping our code readable.
            </span>
            コードの可読性を保つためには、コメントが絶対に必要不可欠です。
        </span>
        <span>
            <span class="src">
                The following rules describe what
                you should comment and where.
            </span>
            以下のルールでは、<em>どこに</em>・<em>どのような</em>コメントを残すべきか説明します。
        </span>
        <span>
            <span class="src">
                But remember: while comments are very important, the best code is
                self-documenting.
            </span>
            一点、e覚えておくべきこととして、確かにコメントは非常に重要なものですが、最もベストなのは、コード自身がコードの意味を説明できていることです。
        </span>
        <span>
            <span class="src">
                Giving sensible names to types and variables is much better than using obscure
                names that you must then explain through comments.
            </span>
            型や変数に明確で伝わりやすい名前をつけることは、曖昧な命名をしてコメントで説明するよりも、はるかに優れています。
        </span>
    </p>
    <p>
        <span>
            <span class="src">
                When writing your comments, write for your audience: the
                next
                contributor who will need to
                understand your code.
            </span>
            コメントを書くときは、その読者に宛てるつもりで書いてください。
            つまり、そのコードを次に担当するメンバーが、そのコードを理解できるように、コメントを書いてください。
        </span>
        <span>
            <span class="src">
                Be generous — the next
                one may be you!
            </span>
            ひょっとすると、次のコードの担当者はあなた自身かもしれません。コメントは惜しみなく書きましょう。
        </span>
    </p>

    <p>((訳注: この日本語翻訳版ガイドではコード例の中のコメントも日本語に訳してありますが、本ガイドのルールは英語のコメントを対象としており、本翻訳版もその内容については英語コメントを対象としたもののまま訳していますので注意してください。とはいえ、これらのコメントの書き方のルールについては、日本語でコメントを書く場合でも十分に適用できると訳者は考えます。))</p>

    <h3 id="Comment_Style"><span title="Comment Style">コメントのスタイル</span></h3>

    <p>
        <span>
            <span class="src">
                Use either the <code>//</code> or <code>/* */</code>
                syntax, as long as you are consistent.
            </span>
            コメントは、一貫性が保たれている限り、<code>//</code>か<code>/* */</code>のどちらの文法を使ってもかまいません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                You can use either the <code>//</code> or the <code>/*
                */</code> syntax; however, <code>//</code> is
                <em>much</em> more common.
            </span>
            コメントは、<code>//</code>と<code>/* */</code>のどちらの文法でも使うことができます。ただし、<code>//</code>を用いる方が<em>はるかに</em>一般的です。
        </span>
        <span>
            <span class="src">
                Be consistent with how you
                comment and what style you use where.
            </span>
            どのようにコメントを書くか、どのスタイルに従うかについて、一貫性を保ってください。
        </span>
    </p>

    <h3 id="File_Comments"><span title="File Comments">ファイルに対するコメント</span></h3>

    <p>
        <span>
            <span class="src">
                Start each file with license boilerplate.
            </span>
            各ファイルは、ライセンスに関する定型文で始めてください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                If a source file (such as a <code>.h</code> file) declares multiple user-facing abstractions
                (common functions, related classes, etc.), include a comment describing the collection of those
                abstractions.
            </span>
            あるソースファイル(<code>.h</code>ファイル等)において、複数のユーザ向けの抽象(共通関数や関連クラス等)を宣言している場合には、それらの抽象のコレクション全体について説明するコメントを含めてください。
        </span>
        <span>
            <span class="src">
                Include enough detail for future authors to know what does not fit there.
            </span>
            また、コードの将来のメンテナーに宛て、何をそこに含めるのがふさわしく、何がふさわしくないのかが伝わるような、十分な説明を含めてください。
        </span>
        <span>
            <span class="src">
                However,
                the detailed documentation about individual abstractions belongs with those abstractions, not at the
                file level.
            </span>
            なお、そのファイルに含まれる個々の抽象に関する詳細なドキュメントは、ファイルレベルのコメントではなく、それぞれの抽象に属するようにしてください。
        </span>
    </p>
    <p>
        <span>
            <span class="src">
                For instance, if you write a file comment for <code>frobber.h</code>, you do not need
to include a file comment in <code>frobber.cc</code> or
<code>frobber_test.cc</code>.
            </span>
            例として、<code>frobber.h</code>にファイルコメントを書くのであれば、<code>frobber.cc</code>や<code>frobber_test.cc</code>にはファイルコメントを書く必要はありません。
        </span>
        <span>
            <span class="src">
                On the other hand, if you write a collection of classes in
<code>registered_objects.cc</code> that has no associated header file, you must include a file
comment in <code>registered_objects.cc</code>.
            </span>
            反対に、たとえば<code>registered_objects.cc</code>にクラスのコレクションを書いていて、かつ、そのファイルと紐付くヘッダーファイルが存在しないときには、<code>registered_objects.cc</code>にファイルコメントを書くようにしてください。
        </span>
    </p>

    <h4 class="stylepoint_subsection"><span title="Legal Notice and Author Line">法的通知と著者に関する行</span></h4>

    <p>
        <span>
            <span class="src">
                Every file should contain license
                boilerplate.
            </span>
            すべてのファイルに、ライセンスに関する定型文を含めてください。
        </span>
        <span>
            <span class="src">
                Choose the appropriate boilerplate for the
                license used by the project (for example, Apache 2.0,
                BSD, LGPL, GPL).
            </span>
            その際、そのプロジェクトが採用するライセンス(たとえば、Apache 2.0, BSD, LGPL, GPL等)に応じて、適切な定型文を選んでください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                If you make significant changes to a file with an
                author line, consider deleting the author line.
            </span>
            あるファイルを大きく変更した場合は、そのファイルの著者に関する行(存在する場合)を削除することを検討してください。
        </span>
        <span>
            <span class="src">
                New files should usually not contain copyright notice or
                author line.
            </span>
            新しく作るファイルについては、通常は、著作権表記や著者の行は含めません。
        </span>
    </p>

    <h3 id="Class_Comments"><span title="Struct and Class Comments">構造体やクラスに対するコメント</span></h3>

    <p>
        <span>
            <span class="src">
                Every non-obvious class or struct declaration should have an accompanying
                comment that describes what it is for and how it should be used.
            </span>
            極めて単純なものを除いて、クラスや構造体の宣言には、その型の目的と使い方に関するコメントを書きましょう。
        </span>
    </p>

    <div>
        <div class="src">
            <pre>// Iterates over the contents of a GargantuanTable.
// Example:
//    std::unique_ptr&lt;GargantuanTableIterator&gt; iter = table-&gt;NewIterator();
//    for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) {
//      process(iter-&gt;key(), iter-&gt;value());
//    }
class GargantuanTableIterator {
  ...
};
</pre>
        </div>
        <pre>// GargantuanTable全体をイテレートします
// 使用例:
//    std::unique_ptr&lt;GargantuanTableIterator&gt; iter = table-&gt;NewIterator();
//    for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) {
//      process(iter-&gt;key(), iter-&gt;value());
//    }
class GargantuanTableIterator {
  ...
};
</pre>
((訳注: Gargantuan: 途方もないくらい大きな))
    </div>

<h4 id="Class_Comments_Details">クラスに対するコメント</h4>

    <p>
        <span>
            <span class="src">
                The class comment should provide the reader with enough information to know
                how and when to use the class, as well as any additional considerations
                necessary to correctly use the class.
            </span>
            クラスのコメントでは、そのクラスをいつ・どのように用いればよいかわかるように、十分な情報を含めてください。
            また、そのクラスを正しく扱うために必要な追加の考慮事項がある場合は、それらについても説明してください。
        </span>
        <span>
            <span class="src">
                Document the synchronization assumptions
                the class makes, if any.
            </span>
            そのほか、クラスがスレッド間における同期に関する前提条件などをもつ場合は、それらについても記述してください。
        </span>
        <span>
            <span class="src">
                If an instance of the class can be accessed by
                multiple threads, take extra care to document the rules and invariants
                surrounding multithreaded use.
            </span>
            たとえば、クラスのあるインスタンスが複数のスレッドからアクセスされうる場合には、そのクラスをマルチスレッド下で扱う場合のルールや不変条件に関して、細心の注意を払って記述してください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                The class comment is often a good place for a small example code snippet
                demonstrating a simple and focused usage of the class.
            </span>
            クラスコメントは、そのクラスの使用例などの小さなコードスニペットを記述するのにも都合の良い場所です。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                When sufficiently separated (e.g.,
                <code>.h</code> and
                <code>.cc</code>
                files), comments describing the use of the class should go together with its
                interface definition; comments about the class operation and implementation
                should accompany the implementation of the class's methods.
            </span>
            コードが<code>.h</code>と<code>.cc</code>ファイルとに十分に分離されているとき、そのクラスの使い方に関するコメントはインターフェース定義に添えて記述し、クラスで行われる操作やその実装に関するコメントはそのクラスのメソッドの実装に添えて記述してください。
        </span>
    </p>
    <h3 id="Function_Comments"><span title="Function Comments">関数に対するコメント</span></h3>

    <p>
        <span>
            <span class="src">
                Declaration comments describe use of the function (when it is
                non-obvious); comments at the definition of a function describe
                operation.
            </span>
            関数宣言のコメントでは、その関数の使い方について(自明でない場合)説明してください。関数定義のコメントでは、関数によって行われる操作について説明してください。
        </span>
    </p>

    <h4 class="stylepoint_subsection"><span title="Function Declarations">関数宣言時のコメント</span></h4>

    <p>
        <span>
            <span class="src">
                Almost every function declaration should have comments immediately
                preceding it that describe what the function does and how to use
                it.
            </span>
            ほぼすべての関数宣言において、その宣言の直前に、関数の目的(その関数が何をするのか)とその使用方法に関するコメントが必要です。
        </span>
        <span>
            <span class="src">
                These comments may be omitted only if the function is simple and
                obvious (e.g., simple accessors for obvious properties of the class).
            </span>
            関数が非常にシンプルで明らかな場合はコメントを省略してもかまいません。
            たとえば、クラスのデータメンバに対するgetter関数などではコメントを書く必要はありません。
        </span>
        <span>
            <span class="src">
                Private methods and functions declared in <code>.cc</code> files are not exempt.
            </span>
            なお、プライベートメソッドや、<code>.cc</code>内で宣言された関数だからといって、コメントが免除されるわけではありません。
        </span>
        <span>
            <span class="src">
                Function comments should be written with an implied subject of
                <i>This function</i> and should start with the verb phrase; for example,
                "Opens the file", rather than "Open the file".
            </span>
            関数コメントは、<em>This function(この関数は)</em>を暗黙的な主語として、動詞句から始めます。
            たとえば、"Opens the file(ファイルを開きます)"です。"Open the file(ファイルを開け)" ではありません。((訳注: 英文法の三単現の`s`のことを言っています。))
        </span>
        <span>
            <span class="src">
                In general, these comments do not
                describe how the function performs its task.
            </span>
            一般に、これらの関数宣言時のコメントでは、<em>どのように</em>処理が行われるかについては触れません。
        </span>
        <span>
            <span class="src">
                Instead, that should be
                left to comments in the function definition.
            </span>
            そのような内容は、関数宣言時ではなく、関数定義時のコメントに譲ってください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Types of things to mention in comments at the function
                declaration:
            </span>
            関数宣言時のコメントで言及すべきことは以下のような内容です。
        </span>
    </p>

    <ul>
        <li>
            <span>
                <span class="src">
                    What the inputs and outputs are.
                </span>
                関数の入力と出力は何か。
            </span>
            <span>
                <span class="src">
                    If function argument names
                    are provided in `backticks`, then code-indexing
                    tools may be able to present the documentation better.
                </span>
                関数の引数名は<code>`backticks`</code>のようにバッククオートで囲んで記述すると、コードインデックスツールによってドキュメント化した場合の表示がよくなるかもしれません。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    For class member functions: whether the object remembers
                    reference or pointer arguments beyond the duration of the method
                    call.
                </span>
                クラスメンバ関数の引数における参照やポインタについて、関数から戻った後もそれらの参照を内部に保持しつづけるのか否か。
            </span>
            <span>
                <span class="src">
                    This is quite common for pointer/reference arguments to
                    constructors.
                </span>
                特にコンストラクタの引数にポインタや参照を渡すパターンは非常にありふれています。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    For each pointer argument, whether it is allowed to be null and what happens
                    if it is.
                </span>
                各ポインタ引数について、その引数が<code>null</code>であってもよいか否か。また、<code>null</code>であった場合にどのような挙動をするのか。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    For each output or input/output argument, what happens to any state that argument
                    is in. (E.g. is the state appended to or overwritten?).
                </span>
                各出力用引数や入出力用引数において、関数呼び出し<em>前</em>の引数の各状態に対して、呼び出し後の状態がどうなるか(例えば、出力用引数に変数を渡したとき、そこに値が追加されるのか、あるいは、単に上書きされるのか)。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    If there are any performance implications of how a
                    function is used.
                </span>
                関数の使い方によってパフォーマンスに影響がある場合、その情報。
            </span>
        </li>
    </ul>

    <p>
        <span>
            <span class="src">
                Here is an example:
            </span>
            以下に例を示します。
        </span>
    </p>
<div>
                    <div class="src">
<pre>// Returns an iterator for this table, positioned at the first entry
// lexically greater than or equal to `start_word`. If there is no
// such entry, returns a null pointer. The client must not use the
// iterator after the underlying GargantuanTable has been destroyed.
//
// This method is equivalent to:
//    std::unique_ptr&lt;Iterator&gt; iter = table-&gt;NewIterator();
//    iter-&gt;Seek(start_word);
//    return iter;
std::unique_ptr&lt;Iterator&gt; GetIterator(absl::string_view start_word) const;
</pre>
                    </div>
<pre>// テーブル内で`start_word`に等しいか辞書的に次に大きい最初の要素を指す
// イテレータを返します。そのような要素がない場合、nullptrが返ります。
// 対象のGargantuanTableが破壊された後は、この関数から戻ったイテレータを
// 使用してはいけません。
//
// このメソッドは次の呼び出しと等価です:
//    std::unique_ptr&lt;Iterator&gt; iter = table-&gt;NewIterator();
//    iter-&gt;Seek(start_word);
//    return iter;
std::unique_ptr&lt;Iterator&gt; GetIterator(absl::string_view start_word) const;
</pre>
</div>
    
    <p>
        <span>
            <span class="src">
                However, do not be unnecessarily verbose or state the
                completely obvious.
            </span>
            ただし、コメントを無用に冗長にしたり、完全に明らかなことをわざわざ主張したりはしないでください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                When documenting function overrides, focus on the
                specifics of the override itself, rather than repeating
                the comment from the overridden function.
            </span>
            オーバーライドした関数にドキュメントを書くときは、オーバーライドする前の関数に関するコメントを繰り返すのではなく、そのオーバーライド自体の内容にフォーカスしたコメントを記述してください。
        </span>
        <span>
            <span class="src">
                In many of these
                cases, the override needs no additional documentation and
                thus no comment is required.
            </span>
            ただし、関数のオーバーライド時には追加の情報を必要としないことも多いです。そのような場合にはコメントは不要です。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                When commenting constructors and destructors, remember
                that the person reading your code knows what constructors
                and destructors are for, so comments that just say
                something like "destroys this object" are not useful.
            </span>
            コンストラクタやデストラクタにコメントを書くときは、コードの読者はコンストラクタとは何か、デストラクタとは何か、既に知っているということに注意してください。「オブジェクトを破壊します」というコメントには情報がありません。
        </span>
        <span>
            <span class="src">
                Document what constructors do with their arguments (for
                example, if they take ownership of pointers), and what
                cleanup the destructor does.
            </span>
            コンストラクタのコメントでは、コンストラクタが与えられた引数をどう扱うのか(たとえば、ポインタの所有権を引き取るか否か)について記述します。デストラクタのコメントでは、デストラクタが何をクリーンアップするかについて記述します。
        </span>
        <span>
            <span class="src">
                If this is trivial, just
                skip the comment.
            </span>
            わざわざ書くまでもないならば、コメントは省略します。
        </span>
        <span>
            <span class="src">
                It is quite common for destructors not
                to have a header comment.
            </span>
            実際、デストラクタのヘッダーコメントは省略されるのが極めて一般的です。
        </span>
    </p>

    <h4 class="stylepoint_subsection"><span title="Function Definitions">関数定義時のコメント</span></h4>

    <p>
        <span>
            <span class="src">
                If there is anything tricky about how a function does
                its job, the function definition should have an
                explanatory comment.
            </span>
            関数がその処理において何かしらトリッキーなことをしている場合には、関数定義のコメントとして、それらについて説明してください。
        </span>
        <span>
            <span class="src">
                For example, in the definition
                comment you might describe any coding tricks you use,
                give an overview of the steps you go through, or explain
                why you chose to implement the function in the way you
                did rather than using a viable alternative.
            </span>
            このコメントでは、たとえば、使用されているコーディングトリックを説明したり、その関数の処理手順の概要を示したり、あるいは、様々な実装方法の中からその方法を選んだ理由を説明したりすることができます。
        </span>
        <span>
            <span class="src">
                For instance,
                you might mention why it must acquire a lock for the
                first half of the function but why it is not needed for
                the second half.
            </span>
            たとえば、関数前半ではロックの取得を必要とするが、関数後半では不要となる理由のようなことについても言及することもできるでしょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Note you should
                <em>not</em> just repeat the comments
                given with the function declaration, in the
                <code>.h</code> file or wherever.
            </span>
            なお、<code>.h</code>等で行った関数宣言時のコメントを繰り返すだけのものは避けてください。
        </span>
        <span>
            <span class="src">
                It's okay to
                recapitulate briefly what the function does, but the
                focus of the comments should be on how it does it.
            </span>
            関数が何をするのかを軽く繰り返す程度はかまいませんが、関数定義時のコメントでは、どちらかといえば、<em>どのように</em>それを実現するのかについてフォーカスしたコメントを記述してください。
        </span>
    </p>

    <h3 id="Variable_Comments"><span title="Variable Comments">変数に対するコメント</span></h3>

    <p>
        <span>
            <span class="src">
                In general the actual name of the variable should be
                descriptive enough to give a good idea of what the variable
                is used for.
            </span>
            一般に、変数の名前には、その変数が何のために使われているか、その目的がわかるような、十分に説明的な名前をつけているはずです。
        </span>
        <span>
            <span class="src">
                In certain cases, more comments are required.
            </span>
            それでも、さらなるコメントを必要とするケースがあります。
        </span>
    </p>

    <h4 class="stylepoint_subsection"><span title="Class Data Members">クラスデータメンバに対するコメント</span></h4>

    <p>
        <span>
            <span class="src">
                The purpose of each class data member (also called an instance
                variable or member variable) must be clear.
            </span>
            クラスの各メンバ変数の目的は明確でなければなりません。
        </span>
        <span>
            <span class="src">
                If there are any
                invariants (special values, relationships between members, lifetime
                requirements) not clearly expressed by the type and name, they must be
                commented.
            </span>
            変数の型や変数名だけでは明確に表現できない不変条件(たとえば、特殊な意味を持つ値の存在や、メンバ間の関連性、寿命に関する要件など)がある場合は、それらをコメントとして記述しなければなりません。
        </span>
        <span>
            <span class="src">
                However, if the type and name suffice (<code>int
                num_events_;</code>), no comment is needed.
            </span>
            反対に、型と名前だけで十分説明できている場合(たとえば、<code>int num_events_;</code>)は、コメントは不要です。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                In particular, add comments to describe the existence and meaning
                of sentinel values, such as nullptr or -1, when they are not
                obvious.
            </span>
            特に、<code>nullptr</code>や<code>-1</code>のような値に、番兵のような特殊な意味を持たせている場合で、そのことが明らかでないときは、そのような値の存在やその意味について説明するコメントを付け足してください。
        </span>
        <span>
            <span class="src">
                For example:
            </span>
            以下に例を示します。
        </span>
    </p>

    <div>
        <div class="src">
            <pre>private:
 // Used to bounds-check table accesses. -1 means
 // that we don't yet know how many entries the table has.
 int num_total_entries_;
</pre>
        </div>
        <pre>private:
 // テーブルアクセス時の境界チェックに使います。-1 は、
 // まだテーブルにいくつの要素があるかわからないことを意味します。
 int num_total_entries_;
</pre>
    </div>

    <h4 class="stylepoint_subsection"><span title="Global Variables">グローバル変数に対するコメント</span></h4>

    <p>
        <span>
            <span class="src">
                All global variables should have a comment describing what they
                are, what they are used for, and (if unclear) why they need to be
                global.
            </span>
            すべてのグローバル変数は、その変数が何を表していて、何のために使われ、そしてなぜグローバルである必要があるのか(明確でない場合)を説明するコメントが必要です。
        </span>
        <span>
            <span class="src">
                For example:
            </span>
            以下に例を示します。
        </span>
    </p>
    <div>
        <div class="src">

            <pre>// The total number of test cases that we run through in this regression test.
const int kNumTestCases = 6;
</pre>
        </div>
        <pre>// この回帰テストにおけるテストケースの総数
const int kNumTestCases = 6;
</pre>
    </div>

    <h3 id="Implementation_Comments"><span title="Implementation Comments">実装に対するコメント</span></h3>

    <p>
        <span>
            <span class="src">
                In your implementation you should have comments in tricky,
                non-obvious, interesting, or important parts of your code.
            </span>
            実装のコードの中では、トリッキーな部分や、わかりにくい部分、興味深い部分、重要な部分について、コメントを記述するようにしてください。
        </span>
    </p>

    <h4 class="stylepoint_subsection"><span title="Explanatory Comments">解説のコメント</span></h4>

    <p>
        <span>
            <span class="src">
                Tricky or complicated code blocks should have comments
                before them.
            </span>
            トリッキーあるいは複雑なコードブロックの前に、それらに関するコメントを記述してください。
        </span>
    </p>

    <h4 class="stylepoint_subsection" id="Function_Argument_Comments"><span
            title="Function Argument Comments">関数実引数のコメント</span></h4>

    <p>
        <span>
            <span class="src">
                When the meaning of a function argument is nonobvious, consider
                one of the following remedies:
            </span>
            関数呼び出し時の実引数の意味を捉えにくい場合、次に述べる対策のいずれかを検討してください。
        </span>
    </p>

    <ul>
        <li>
            <span>
                <span class="src">
                    If the argument is a literal constant, and the same constant is
                    used in multiple function calls in a way that tacitly assumes they're
                    the same, you should use a named constant to make that constraint
                    explicit, and to guarantee that it holds.
                </span>
                引数が定数リテラルで、かつ、同じ定数を複数の関数呼び出しで使用しており、しかも、それらが意味的に同じ値のことを指しているときは、名前付きの定数を導入して制約を明示的にし、常に同じ値であることを保証するようにしてください。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Consider changing the function signature to replace a
                    <code>bool</code>
                    argument with an
                    <code>enum</code> argument.
                </span>
                関数シグネチャにおける<code>bool</code>は<code>enum</code>で置き換えることを検討してください。
            </span>
            <span>
                <span class="src">
                    This will make the argument
                    values self-describing.
                </span>
                <code>enum</code>を使うと、関数呼び出し時に実引数として現れる値自身が説明的になります。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    For functions that have several configuration options, consider
                    defining a single class or struct to hold all the options
                    ,
                    and pass an instance of that.
                </span>
                関数がいくつかの設定オプションを持つような場合、すべてのオプションをまとめて保持する構造体かクラスを定義して、そのインスタンスを関数に渡すことを検討してください。
            </span>
            <span>
                <span class="src">

                    This approach has several advantages.
                </span>
                この方法にはいくつか利点があります。
            </span>
            <span>
                <span class="src">
                    Options are referenced by name
                    at the call site, which clarifies their meaning.
                </span>
                まず、呼び出し元のコードにおいて、各オプションが名前によって参照されるため、コードの意味が明確になります。
            </span>
            <span>
                <span class="src">
                    It also reduces
                    function argument count, which makes function calls easier to read and
                    write.
                </span>
                また、関数の引数の数が減るため、関数呼び出しそのものも読みやすく書きやすくなります。
            </span>
            <span>
                <span class="src">
                    As an added benefit, you don't have to change call sites when
                    you add another option.
                </span>
                追加の利点として、将来オプションを追加することになっても、呼び出し側のコードを書き換える必要がなくなります。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Replace large or complex nested expressions with named variables.
                </span>
                長い、あるいは、複雑なネストを含む式は、名前付きの一時変数で置き換えてください。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    As a last resort, use comments to clarify argument meanings at the
                    call site.
                </span>
                最後の手段として、関数呼び出し元で、引数の意味を明確にするためのコメントを記載してください。
            </span>
        </li>
    </ul>
    <span>
        <span class="src">
            Consider the following example:
        </span>
        次の例を考えてみましょう。
    </span>
    <div>
        <div class="src">
            <pre class="badcode">// What are these arguments?
const DecimalNumber product = CalculateProduct(values, 7, false, nullptr);
</pre>
        </div>
        <pre class="badcode">// これらの引数の意味は何？
const DecimalNumber product = CalculateProduct(values, 7, false, nullptr);
</pre>
    </div>

    <p>
        <span>
            <span class="src">
                versus:
            </span>
            これに対して、次の例はどうでしょうか。
        </span>
    </p>
    <div>
        <div class="src">
            <pre>ProductOptions options;
options.set_precision_decimals(7);
options.set_use_cache(ProductOptions::kDontUseCache);
const DecimalNumber product =
    CalculateProduct(values, options, /*completion_callback=*/nullptr);
</pre>
        </div>
        <pre>ProductOptions options;
options.set_precision_decimals(7);
options.set_use_cache(ProductOptions::kDontUseCache);
const DecimalNumber product =
    CalculateProduct(values, options, /*completion_callback=*/nullptr);
</pre>
    </div>

    <h4 id="Implementation_Comment_Donts"><span title="Don'ts">してはならないこと</span></h4>

    <p>
        <span>
            <span class="src">
                Do not state the obvious.
            </span>
            明らかなことをわざわざ主張してはいけません。
        </span>
        <span>
            <span class="src">
                In particular, don't literally describe what
                code does, unless the behavior is nonobvious to a reader who understands
                C++ well.
            </span>
            特に、C++を十分理解している読者にとってわかりにくいような場合は除き、コードがしていることを逐一文字通りに説明するようなコメントを書いてはいけません。
        </span>
        <span>
            <span class="src">
                Instead, provide higher level comments that describe
                <i>why</i>
                the code does what it does, or make the code self describing.
            </span>
            そのようなコメントのかわりに、より高い次元の、たとえばそのコードが<em>なぜ</em>それをしているのかをコメントに記述したり、あるいはコード自身にそれを説明させるようにしてください。
        </span>
    </p>

    <span>
        <span class="src">
            Compare this:
        </span>
        以下のコード例を比べてみましょう。
    </span>
    <div>
        <div class="src">
            <pre class="badcode">// Find the element in the vector. &lt;-- Bad: obvious!
if (std::find(v.begin(), v.end(), element) != v.end()) {
    Process(element);
}
</pre>
        </div>
        <pre class="badcode">// vectorの中から要素を検索する。  &lt;-- ダメ。明らか！
    if (std::find(v.begin(), v.end(), element) != v.end()) {
        Process(element);
}
</pre>
    </div>

    <span>
        <span class="src">
            To this:
        </span>
        と、
    </span>
    <div>
        <div class="src">
            <pre>// Process "element" unless it was already processed.
if (std::find(v.begin(), v.end(), element) != v.end()) {
  Process(element);
}
</pre>
        </div>
        <pre>// まだ処理していない要素があれば処理する。
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
</pre>
    </div>

    <span>
        <span class="src">
            Self-describing code doesn't need a comment.
        </span>
        さらに、コード自身が自己説明的になっていると、コメントを必要としなくなります。
    </span>
    <span>
        <span class="src">
            The comment from
            the example above would be obvious:
        </span>
        上の例におけるコメントのかわりに、以下の例のようにすると、より明確です。
    </span>
    <pre>if (!IsAlreadyProcessed(element)) {
  Process(element);
}
</pre>

    <h3 id="Punctuation,_Spelling_and_Grammar"><span title="Punctuation, Spelling and Grammar">句読点と綴りと文法</span></h3>

    <p>
        <span>
            <span class="src">
                Pay attention to punctuation, spelling, and grammar; it is
                easier to read well-written comments than badly written
                ones.
            </span>
            句読点や綴りや文法に注意してください。きちんとしたコメントは、それだけで読みやすいものです。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Comments should be as readable as narrative text, with
                proper capitalization and punctuation.
            </span>
            コメントは、大文字や句読点を適切に用いてふつうの文章として読めるように記述します。
        </span>
        <span>
            <span class="src">
                In many cases,
                complete sentences are more readable than sentence
                fragments.
            </span>
            多くの場合、文の断片だけの場合よりも、完全な文にするほうが読みやすくなります。
        </span>
        <span>
            <span class="src">
                Shorter comments, such as comments at the end
                of a line of code, can sometimes be less formal, but you
                should be consistent with your style.
            </span>
            行末コメントなどの短いコメントでは多少形式を崩すこともありますが、極力、一貫したスタイルを保つようにはしてください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Although it can be frustrating to have a code reviewer
                point out that you are using a comma when you should be
                using a semicolon, it is very important that source code
                maintain a high level of clarity and readability.
            </span>
            コードレビュアーからの指摘のうち「セミコロンを使うべきところでカンマを使っている」といったものにはうんざりするかもしれません。しかし、ソースコードの明瞭性や可読性を高く保つことは、本当に重要なことなのです。
        </span>
        <span>
            <span class="src">
                Proper
                punctuation, spelling, and grammar help with that
                goal.
            </span>
            適切な句読点、正しい綴り、正しい文法は、このゴールに向かうための手助けをしてくれるでしょう。
        </span>
    </p>
    <h3 id="TODO_Comments"><span title="TODO Comments">TODOコメント</span></h3>

    <p>
        <span>
            <span class="src">
                Use
                <code>TODO</code> comments for code that is temporary,
                a short-term solution, or good-enough but not perfect.
            </span>
            一時的なコード、暫定対応コード、完璧ではないが現状十分であるコード等に対しては、<code>TODO</code>コメントを記述してください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                <code>TODO</code>s should include the string
                <code>TODO</code> in all caps, followed by the

                bug ID, name, e-mail address, or other
                identifier
                of the person or issue with the best context
                about the problem referenced by the
                <code>TODO</code>.
            </span>
            <code>TODO</code>コメントは、まず、すべて大文字で<code>TODO</code>と書き、続けて、バグ管理番号、その<code>TODO</code>に関して、詳しい人の名前やメールアドレスやその他のID等、あるいは、関連するissueへのリンク等を含めます。
        </span>
    </p>

    <div>
        <div class="src">
            <pre>// TODO: bug 12345678 - Remove this after the 2047q4 compatibility window expires.
// TODO: example.com/my-design-doc - Manually fix up this code the next time it's touched.
// TODO(bug 12345678): Update this list after the Foo service is turned down.
// TODO(John): Use a "\*" here for concatenation operator.
</pre>
            </div>
            <pre>// TODO: bug 12345678 - 2047q4の互換性維持期間がおわったら消す
// TODO: example.com/my-design-doc - 次回ここを触るときには直す
// TODO(bug 12345678): Fooサービスを止めたらこのリストを更新する
// TODO(John): ここでは連結演算子として"\*"を使う
</pre>
</div>

    <p>
        <span>
            <span class="src">
                If your <code>TODO</code> is of the form "At a future
                date do something" make sure that you either include a
                very specific date ("Fix by November 2005") or a very
                specific event ("Remove this code when all clients can
                handle XML responses.").
            </span>
            もし、その<code>TODO</code>が「<em>未来のいつ、何をする</em>」という形式になる場合は、必ず、具体的な日付(例:「2005年11月までに直す」)や、具体的なイベント(例:「すべてのクライアントがXMLレスポンスを扱えるようになったらこのコードは消す」)を含めるようにしてください。
        </span>
    </p>

    <h2 id="Formatting">
        <span title="Formatting">コードのフォーマット</span>
    </h2>

    <p>
        <span>
            <span class="src">
                Coding style and formatting are pretty arbitrary, but a
                project is much easier to follow
                if everyone uses the same style.
            </span>
            コーディングスタイルやコードフォーマットは好みによるところが大きいものですが、全員が同じスタイルに従っていれば、プロジェクト全体で同じルールを適用しやすくなります。
        </span>
        <span>
            <span class="src">
                Individuals may not agree with every
                aspect of the formatting rules, and some of the rules may take
                some getting used to, but it is important that all
                project contributors follow the
                style rules so that
                they can all read and understand
                everyone's code easily.
            </span>
            ここで定めるフォーマットのルールの中には、各個人にとって賛同しかねるものもあれば、非常に馴染み深いものもあるでしょう。それでも、ここでは、すべてのプロジェクトメンバーがある一つのルールに沿うということを重要視します。プロジェクト全体でルールを統一することによって、誰もが誰のコードでも読みやすく理解しやすい状態を保つことができます。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                To help you format code correctly, we've created a
                <a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">
                settings file for emacs</a>.
            </span>
            コードを正しくフォーマットするために、<a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">emacsの設定ファイル</a>を用意しています。
        </span>
    </p>

    <h3 id="Line_Length"><span title="Line Length">行の長さ</span></h3>

    <p>
        <span>
            <span class="src">
                Each line of text in your code should be at most 80
                characters long.
            </span>
            コードの各行の長さは、最大80文字までとします。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                We recognize that this rule is
                controversial, but so much existing code already adheres
                to it, and we feel that consistency is important.
            </span>
            このルールに議論の余地があることは認識していますが、既に多くのコードがこのルールに沿って書かれており、そして、私たちは一貫性を保つことが重要であると考えています。
        </span>
    </p>

    <p class="pros"></p>
    <p>
        <span>
            <span class="src">
                Those who favor this rule
                argue that it is rude to force them to resize
                their windows and there is no need for anything longer.
            </span>
            このルールを推す側の主張は、長いコードによってウィンドウサイズの変更を強制するのは失礼であるし、そもそもコードを横に長くする必要はない、というものです。
        </span>
        <span>
            <span class="src">
                Some folks are used to having several code windows
                side-by-side, and thus don't have room to widen their
                windows in any case.
            </span>
            人によっては複数のコードウィンドウを横に並べて使っていて、それ以上ウィンドウ幅を広げる余地がないかもしれません。
        </span>
        <span>
            <span class="src">
                People set up their work environment
                assuming a particular maximum window width, and 80
                columns has been the traditional standard.
            </span>
            多くの人が、特定の最大ウィンドウサイズを仮定して仕事環境を構築しており、その際、横幅80文字が伝統的な標準とされてきました。
        </span>
        <span>
            <span class="src">
                Why change
                it?
            </span>
            変える理由があるでしょうか？
        </span>
    </p>
    <p class="cons"></p>
    <p>
        <span>
            <span class="src">
                Proponents of change argue that a wider line can make
                code more readable.
            </span>
            このルールを変えたがっている側の主張は、行を長くすることでコードがもっと読みやすくなるはずである、というものです。
        </span>
        <span>
            <span class="src">
                The 80-column limit is an hidebound
                throwback to 1960s mainframes; modern equipment has wide screens that
                can easily show longer lines.
            </span>
            横幅80文字の制限は、1960年のメインフレームを思い起こさせる干からびたものです。現代的な環境は、もっと長い行を簡単に表示できる広いスクリーンを備えているではありませんか？
        </span>
    </p>
    <p class="decision"></p>
    <p>
        <span>
            <span class="src">
                80 characters is the maximum.
            </span>
            最大80文字とします。
        </span>
    </p>

    <p class="exception"></p>
    <p>
        <span>
            <span class="src">
                A line may exceed 80 characters if it is
            </span>
            次の場合、80文字を超えてもかまいません。
        </span>
    </p>
    <ul>
        <li>
            <span>
                <span class="src">
                    a comment line which is not feasible to split without harming
                    readability, ease of cut and paste or auto-linking -- e.g., if a line
                    contains an example command or a literal URL longer than 80 characters.
                </span>
                行を分割すると可読性や利便性の妨げとなるようなコメント行。
                たとえば、80文字を超えるような長いコマンド例や長いURLがこれに該当します。このような行を分割してしまうと、可読性を損ねたり、コピー・ペーストしにくくなったり、JRL自動リンクが正しく機能しなくなったりしてしまいます。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    a string literal that cannot easily be wrapped at 80 columns.
                </span>
                80文字での折り返しが難しい長い文字列リテラル。
            </span>
            <span>
                <span class="src">
                    This may be because it contains URIs or other semantically-critical pieces,
                    or because the literal contains an embedded language, or a multiline
                    literal whose newlines are significant like help messages.
                </span>
                これには、URIやその他の意味的に重要なもの、別の組み込み言語を含む文字列リテラル、ヘルプメッセージのような改行が重要な意味を持つ複数行文字列リテラルなどが該当します。
            </span>
            <span>
                <span class="src">
                    In these cases, breaking up the literal would
                    reduce readability, searchability, ability to click links, etc.
                </span>
                このような場合においてリテラルを分割してしまうと、可読性や検索性を損なったり、リンクがクリックできなくなったりします。
            </span>
            <span>
                <span class="src">
                    Except for
                    test code, such literals should appear at namespace scope near the top of a
                    file.
                </span>
                なお、テスト用コードを除いて、このようなリテラルは、ファイル先頭付近の名前空間スコープ内におくとよいでしょう。
            </span>
            <span>
                <span class="src">
                    If a tool like Clang-Format doesn't recognize the unsplittable content,
                    <a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html#disabling-formatting-on-a-piece-of-code">
                        disable the tool</a> around the content as necessary.
                </span>
                また、もしClang-Formatのようなツールによって、そのようなコンテンツが分割されてしまう場合は、必要に応じて、そのコンテンツの周りで<a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html#disabling-formatting-on-a-piece-of-code">ツールを無効化</a>してください。
            </span>
            <span>
                <span class="src">
                    (We must balance between usability/searchability of such literals and the
                    readability of the code around them.)
                </span>
                (なお、このようなリテラルに対する利便性や検索性と、その周辺のコードの読みやすさとのバランスも保つようにしてください)
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    an include statement.
                </span>
                <code>#include</code>文。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    a <a href="#The__define_Guard">header guard</a>
                </span>
                <a href="#The__define_Guard">インクルードガード</a>。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    a using-declaration
                </span>
                using宣言。
            </span>
        </li>
    </ul>

    <h3 id="Non-ASCII_Characters"><span title="Non-ASCII Characters">非アスキー文字</span></h3>
<!---->
    <p>
        <span>
            <span class="src">
                Non-ASCII characters should be rare, and must use UTF-8
                formatting.
            </span>
            基本的に非アスキー文字は使いません。もし、非アスキー文字を使う場合はUTF-8フォーマットを使います。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                You shouldn't hard-code user-facing text in source,
                even English, so use of non-ASCII characters should be
                rare.
            </span>
            まず前提として、そもそもユーザの目に触れるようなテキストをソースコード中にハードコーディングしてはいけません。たとえ、英語であってもです。ですから、非アスキー文字をソースコード中で使う機会はほとんどないはずです。
        </span>
        <span>
            <span class="src">
                However, in certain cases it is appropriate to
                include such words in your code.
            </span>
            しかし、場合によっては、このような単語をソースコードに含めることが適切であるようなケースもあります。
        </span>
        <span>
            <span class="src">
                For example, if your
                code parses data files from foreign sources, it may be
                appropriate to hard-code the non-ASCII string(s) used in
                those data files as delimiters.
            </span>
            たとえば、そのコードが海外から来るデータファイルを解析するのであれば、そのデータの区切り文字として使われている非アスキー文字列をソースコードに埋め込むのは適切なことでしょう。
        </span>
        <span>
            <span class="src">
                More commonly, unittest
                code (which does not need to be localized) might
                contain non-ASCII strings.
            </span>
            また、(ローカライズの必要がない)ユニットテストにおいて、非アスキー文字列を含むこともあります。
        </span>
        <span>
            <span class="src">
                In such cases, you should use
                UTF-8, since that is an encoding
                understood by most tools able to handle more than just
                ASCII.
            </span>
            このような場合には、UTF-8を使います。UTF-8エンコーディングであれば、ASCII以外も解するほとんどのツールでサポートされています。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Hex encoding is also OK, and encouraged where it
                enhances readability — for example,
                <code>"\xEF\xBB\xBF"</code>, or, even more simply,
                <code>"\uFEFF"</code>, is the Unicode zero-width
                no-break space character, which would be invisible
                if included in the source as straight UTF-8.
            </span>
            16進数によるエンコーディングを使ってもかまいません。特に、そうすることで可読性が高まる場合は積極的に使用してください。たとえば、<code>"\xEF\xBB\xBF"</code>や、より単純に<code>"\uFEFF"</code>は、Unicodeのゼロ幅改行なしスペース文字ですが、これが普通のUTF-8文字としてソースコード中に埋め込まれていたら、ソースコードの中では見えなくなってしまうでしょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                When possible, avoid the <code>u8</code> prefix.
            </span>
            可能な限り、<code>u8</code>接頭辞を避けてください。
        </span>
        <span>
            <span class="src">
                It has significantly different semantics starting in C++20
                than in C++17, producing arrays of <code>char8_t</code>
                rather than <code>char</code>, and will change again in C++23.
            </span>
            C++17以前と比べて、C++20から、そのセマンティクスが大きく変更されました。
            C++20において、<code>u8</code>接頭辞は、<code>char</code>の配列ではなく<code>char8_t</code>の配列を生成するようになりました。そして、さらなる変更がC++23で予定されています。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                You shouldn't use <code>char16_t</code> and
                <code>char32_t</code> character types, since they're for
                non-UTF-8 text.
            </span>
            <code>char16_t</code>と<code>char32_t</code>は、UTF-8以外のテキストのためのものであるため、使いません。
        </span>
        <span>
            <span class="src">
                For similar reasons you also shouldn't
                use
                <code>wchar_t</code> (unless you're writing code that
                interacts with the Windows API, which uses
                <code>wchar_t</code> extensively).
            </span>
            同様の理由で、(Windows APIを使うコードは例外として)<code>wchar_t</code>も使いません。
        </span>
    </p>
    <h3 id="Spaces_vs._Tabs"><span title="Spaces vs. Tabs">スペースか、タブか</span></h3>

    <p>
        <span>
            <span class="src">
                Use only spaces, and indent 2 spaces at a time.
            </span>
            スペースだけを使います。インデント1つにつき、スペース2つとします。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                We use spaces for indentation.
            </span>
            インデントにはスペースを使います。
        </span>
        <span>
            <span class="src">
                Do not use tabs in your
                code.
            </span>
            タブは使いません。
        </span>
        <span>
            <span class="src">
                You should set your editor to emit spaces when you
                hit the tab key.
            </span>
            タブキーを押したときに、スペースが入力されるようにエディタを設定してください。
        </span>
    </p>
    <h3 id="Function_Declarations_and_Definitions"><span title="Function Declarations and Definitions">関数宣言と関数定義</span>
    </h3>

    <p>
        <span>
            <span class="src">
                Return type on the same line as function name, parameters
                on the same line if they fit.
            </span>
            関数の戻り値の型は、関数名と同じ行に記述します。
            引数は、同じ行に収まる限り、同じ行に記述します。
        </span>
        <span>
            <span class="src">
                Wrap parameter lists which do
                not fit on a single line as you would wrap arguments in a
                <a href="#Function_Calls">function call</a>.
            </span>
            引数リストが1行に収まらないときは、<a href="#Function_Calls">関数呼び出し</a>と同じ方法で、行を分割してください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Functions look like this:
            </span>
            関数は次のようにします。
        </span>
    </p>

    <pre>ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
  DoSomething();
  ...
}
</pre>

    <p>
        <span>
            <span class="src">
                If you have too much text to fit on one line:
            </span>
            1行に収まらないときは、次のようにします。
        </span>
    </p>

    <pre>ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3) {
  DoSomething();
  ...
}
</pre>

    <p>
        <span>
            <span class="src">
                or if you cannot fit even the first parameter:
            </span>
            もし、最初の引数からして同じ行に収まらないときは、次のようにします。
        </span>
    </p>
    <div>
        <div class="src">
            <pre>ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 4 space indent
    Type par_name2,
    Type par_name3) {
  DoSomething();  // 2 space indent
  ...
}
</pre>
        </div>
        <pre>ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // スペース4個でインデント
    Type par_name2,
    Type par_name3) {
  DoSomething();  // スペース2個でインデント
  ...
}
</pre>
    </div>

    <p>
        <span>
            <span class="src">
                Some points to note:
            </span>
            次の点に注意してください。
        </span>
    </p>

    <ul>
        <li>
            <span>
                <span class="src">
                    Choose good parameter names.
                </span>
                引数には良い名前を付けてください。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    A parameter name may be omitted only if the parameter is not used in the
                    function's definition.
                </span>
                関数定義において、使わない引数については、その名前を省略してもかまいません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    If you cannot fit the return type and the function
                    name on a single line, break between them.
                </span>
                戻り値の型と関数名とが同じ行に収まらないときは、それらの間で行を分割してください。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    If you break after the return type of a function
                    declaration or definition, do not indent.
                </span>
                戻り値の型の後で改行する場合、後続の関数名の行をインデントしないでください。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    The open parenthesis is always on the same line as
                    the function name.
                </span>
                関数の開き丸括弧<code>(</code>は常に関数名と同じ行に書きます。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    There is never a space between the function name
                    and the open parenthesis.
                </span>
                関数名と開き丸括弧<code>(</code>の間にはスペースを入れてはいけません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    There is never a space between the parentheses and
                    the parameters.
                </span>
                開き丸括弧<code>(</code>と引数の間にはスペースを入れてはいけません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    The open curly brace is always on the end of the last line of the function
                    declaration, not the start of the next line.
                </span>
                開き波括弧<code>{</code>は常に関数宣言の最後の行に書きます。次の行の頭ではありません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    The close curly brace is either on the last line by
                    itself or on the same line as the open curly brace.
                </span>
                閉じ波括弧<code>}</code>は、それ自身で最後の行とするか、開き波括弧<code>{</code>と同じ行に書くかのいずれかとします。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    There should be a space between the close
                    parenthesis and the open curly brace.
                </span>
                閉じ丸括弧<code>)</code>と開き波括弧<code>{</code>の間にはスペースを1つ入れます。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    All parameters should be aligned if possible.
                </span>
                可能な限り、すべての引数を整列させます。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Default indentation is 2 spaces.
                </span>
                デフォルトのインデントはスペース2つです。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Wrapped parameters have a 4 space indent.
                </span>
                引数リストにおいて行を分割した場合は、スペース4つでインデントします。
            </span>
        </li>
    </ul>

    <p>
        <span>
            <span class="src">
                Unused parameters that are obvious from context may be omitted:
            </span>
            次の例のように、引数が使われず、かつ、その意味が文脈から明らかな場合は、引数を省略できます。
        </span>
    </p>

    <pre>class Foo {
 public:
  Foo(const Foo&amp;) = delete;
  Foo&amp; operator=(const Foo&amp;) = delete;
};
</pre>

    <p>
        <span>
            <span class="src">
                Unused parameters that might not be obvious should comment out the variable
                name in the function definition:
            </span>
            ただし、使わない引数であっても、その意味が文脈から明らかにならないときには、省略せずにコメントとして残します。
        </span>
    </p>

    <pre>class Shape {
 public:
  virtual void Rotate(double radians) = 0;
};

class Circle : public Shape {
 public:
  void Rotate(double radians) override;
};

void Circle::Rotate(double /*radians*/) {}
</pre>

    <div>
        <div class="src">
            <pre class="badcode">// Bad - if someone wants to implement later, it's not clear what the
// variable means.
void Circle::Rotate(double) {}
</pre>
        </div>
        <pre class="badcode">// これはダメ。将来、実装を追加するとき、引数の意図がわからなくなってしまう。
void Circle::Rotate(double) {}
</pre>
    </div>

    <p>
        <span>
            <span class="src">
                Attributes, and macros that expand to attributes, appear at the very
                beginning of the function declaration or definition, before the
                return type:
            </span>
            属性や、属性に展開されるマクロは、関数宣言や関数定義の最も先頭、戻り値の型の前に書きます。
        </span>
    </p>
    <pre>  ABSL_ATTRIBUTE_NOINLINE void ExpensiveFunction();
  [[nodiscard]] bool IsOk();
</pre>

    <h3 id="Formatting_Lambda_Expressions"><span title="Lambda Expressions">ラムダ式</span></h3>

    <p>
        <span>
            <span class="src">
                Format parameters and bodies as for any other function, and capture
                lists like other comma-separated lists.
            </span>
            ラムダ式の引数リストと関数本体は、通常の関数と同様にフォーマットします。
            キャプチャリストは、他のカンマ区切りのリストと同様にフォーマットします。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                For by-reference captures, do not leave a space between the
                ampersand (<code>&amp;</code>) and the variable name.
            </span>
            参照キャプチャについて、アンパサンド(<code>&amp;</code>)と変数名の間には、スペースを入れません。
        </span>
    </p>
    <pre>int x = 0;
auto x_plus_n = [&amp;x](int n) -&gt; int { return x + n; }
</pre>
    <p>
        <span>
            <span class="src">
                Short lambdas may be written inline as function arguments.
            </span>
            短いラムダは、関数の実引数として直接その場に書いてもかまいません。
        </span>
    </p>
    <pre>absl::flat_hash_set&lt;int&gt; to_remove = {7, 8, 9};
std::vector&lt;int&gt; digits = {3, 9, 1, 8, 4, 7, 1};
digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;to_remove](int i) {
               return to_remove.contains(i);
             }),
             digits.end());
</pre>

    <h3 id="Floating_Literals"><span title="Floating-point Literals">浮動小数点リテラル</span></h3>

    <p>
        <span>
            <span class="src">
                Floating-point literals should always have a radix point, with digits on both
                sides, even if they use exponential notation.
            </span>
            浮動小数点リテラルには、指数表記を使用する場合であっても、常に小数点を書き、常に小数点の両側に数字を書きます。
        </span>
        <span>
            <span class="src">
                Readability is improved if all
                floating-point literals take this familiar form, as this helps ensure that they
                are not mistaken for integer literals, and that the
                <code>E</code>/<code>e</code> of the exponential notation is not mistaken for a
                hexadecimal digit.
            </span>
            すべての浮動小数点リテラルの見た目を、この見慣れた形に統一しておくことで、コードの可読性を向上させることができます。
            この形の浮動小数点リテラルであれば、それを整数リテラルと取り違えたり、指数表記の<code>E</code>や<code>e</code>を16進数のそれと見間違えたりすることもなくなるでしょう。
        </span>
        <span>
            <span class="src">
                It is fine to initialize a floating-point variable with an
                integer literal (assuming the variable type can exactly represent that integer),
                but note that a number in exponential notation is never an integer literal.
            </span>
            浮動小数点変数を整数リテラルで初期化してもかまいません(ただし、その整数値を正確に表せる場合に限ります)。一方で、指数表記された数値は決して整数リテラルにはなりませんので注意してください。
        </span>
    </p>

    <pre class="badcode">float f = 1.f;
long double ld = -.5L;
double d = 1248e6;
</pre>

    <div><div class="src"><pre class="goodcode">float f = 1.0f;
float f2 = 1;   // Also OK
long double ld = -0.5L;
double d = 1248.0e6;
</pre></div><pre class="goodcode">float f = 1.0f;
float f2 = 1;   // これもOK
long double ld = -0.5L;
double d = 1248.0e6;
    </pre></div>

    <h3 id="Function_Calls"><span title="Function Calls">関数呼び出し</span></h3>

    <p>
        <span>
            <span class="src">
                Either write the call all on a single line, wrap the
                arguments at the parenthesis, or start the arguments on a new
                line indented by four spaces and continue at that 4 space
                indent.
            </span>
            関数呼び出しは、全体を1行で書くか、引数リストを途中改行して丸括弧<code>(</code>のところで整列させるか、4つのスペースでインデントした新しい行から引数を書きはじめるかのいずれかとします。
        </span>
        <span>
            <span class="src">
                In the absence of other considerations, use the
                minimum number of lines, including placing multiple arguments
                on each line where appropriate.
            </span>
            他に特別な理由がない限り、各行に複数の引数をまとめて、可能な限り少ない行数で記述します。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Function calls have the following format:
            </span>
            関数呼び出しは、次のォーマットに従います。
        </span>
    </p>
    <pre>bool result = DoSomething(argument1, argument2, argument3);
</pre>

    <p>
        <span>
            <span class="src">
                If the arguments do not all fit on one line, they
                should be broken up onto multiple lines, with each
                subsequent line aligned with the first argument.
            </span>
            もし、すべての引数が1行に収まらない場合、それらを複数の行に分割します。その際、後続の行は、最初の引数に揃えるようにします。
        </span>
        <span>
            <span class="src">
                Do not
                add spaces after the open paren or before the close
                paren:
            </span>
            開き丸括弧<code>(</code>の後や、閉じ丸括弧<code>)</code>の前にスペースを入れてはいけません。
        </span>
    </p>
    <pre>bool result = DoSomething(averyveryveryverylongargument1,
                          argument2, argument3);
</pre>

    <p>
        <span>
            <span class="src">
                Arguments may optionally all be placed on subsequent
                lines with a four space indent:
            </span>
            引数は、それらをすべて、スペース4つでインデントされた後続の行に記述してもかまいません。
        </span>
    </p>
    <div>
        <div class="src">
            <pre>if (...) {
  ...
  ...
  if (...) {
    bool result = DoSomething(
        argument1, argument2,  // 4 space indent
        argument3, argument4);
    ...
  }
</pre>
        </div>
        <pre>if (...) {
  ...
  ...
  if (...) {
    bool result = DoSomething(
        argument1, argument2,  // スペース4つでインデント
        argument3, argument4);
    ...
  }
</pre>
    </div>

    <p>
        <span>
            <span class="src">
                Put multiple arguments on a single line to reduce the
                number of lines necessary for calling a function unless
                there is a specific readability problem.
            </span>
            可読性の妨げとならない限り、複数の引数を1つの行にまとめ、関数呼び出しに要する行数を減らしてください。
        </span>

        <span>
            <span class="src">
                Some find that
                formatting with strictly one argument on each line is
                more readable and simplifies editing of the arguments.
            </span>
            人によっては、厳密に1行に1つずつ引数をかく形式の方が読みやすく、編集もしやすいと考えるかもしれません。
        </span>

        <span>
            <span class="src">
                However, we prioritize for the reader over the ease of
                editing arguments, and most readability problems are
                better addressed with the following techniques.
            </span>
            しかし、私たちは、編集のしやすよりも、読者にとっての読みやすさを優先します。また、可読性に関する問題のほとんどは、以下で述べるテクニックによって解決することができます。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                If having multiple arguments in a single line decreases
                readability due to the complexity or confusing nature of the
                expressions that make up some arguments, try creating
                variables that capture those arguments in a descriptive name:
            </span>
            引数が複雑な式から構成されていて、1行にそれらの引数をまとめると読みにくくなってしまう場合には、次のように、それらの引数のための一時変数を作って、適切な名前を与えてください。
        </span>
    </p>
    <pre>int my_heuristic = scores[x] * y + bases[x];
bool result = DoSomething(my_heuristic, x, y, z);
</pre>

    <p>
        <span>
            <span class="src">
                Or put the confusing argument on its own line with
                an explanatory comment:
            </span>
            あるいは、次のように、意味のわかりにくい引数を個別の行にわけて、説明的なコメントを記述してください。
        </span>
    </p>
    <div>
        <div class="src">
            <pre>bool result = DoSomething(scores[x] * y + bases[x],  // Score heuristic.
                          x, y, z);
</pre>
        </div>
        <pre>bool result = DoSomething(scores[x] * y + bases[x],  // ヒューリスティックなスコア
                          x, y, z);
</pre>
    </div>

    <p>
        <span>
            <span class="src">
                If there is still a case where one argument is
                significantly more readable on its own line, then put it on
                its own line.
            </span>
            それでも、引数を1行に1つだけにした方がはるかに読みやすくなるという場合は、そのようにしましょう。
        </span>
        <span>
            <span class="src">
                The decision should be specific to the argument
                which is made more readable rather than a general policy.
            </span>
            全体的なポリシーを守るよりも、それらの引数が読みやすくなる方を選んでください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Sometimes arguments form a structure that is important
                for readability.
            </span>
            次の例のように、関数引数は、しばしば、可読性の面で重要な、何らかの構造をとることがあります。
        </span>
        <span>
            <span class="src">
                In those cases, feel free to format the
                arguments according to that structure:
            </span>
            このような場合には、その構造に沿って自由に引数を配置してかまいません。
        </span>
    </p>
    <div>
        <div class="src">
            <pre>// Transform the widget by a 3x3 matrix.
my_widget.Transform(x1, x2, x3,
                    y1, y2, y3,
                    z1, z2, z3);
</pre>
        </div>
        <pre>// ウィジェットを3x3行列で変形する
my_widget.Transform(x1, x2, x3,
                    y1, y2, y3,
                    z1, z2, z3);
</pre>
    </div>


    <h3 id="Braced_Initializer_List_Format"><span title="Braced Initializer List Format">波括弧による初期化子リスト</span></h3>

    <p>
        <span>
            <span class="src">
                Format a braced initializer list exactly like you would format a function
                call in its place.
            </span>
            波括弧による初期化子リストは、関数呼び出しと同じようにフォーマットします。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                If the braced list follows a name (e.g., a type or
                variable name), format as if the
                <code>{}</code> were the
                parentheses of a function call with that name.
            </span>
            波括弧のリストが型名や変数名の直後に続く場合は、波括弧<code>{}</code>を関数呼び出しの丸括弧<code>()</code>に見立てて、その引数と同じようにフォーマットします。
        </span>
        <span>
            <span class="src">
                If there
                is no name, assume a zero-length name.
            </span>
            名前がない場合は、0文字の名前があると見なしてフォーマットします。
        </span>
    </p>
    <div>
        <div class="src">
            <pre>// Examples of braced init list on a single line.
return {foo, bar};
functioncall({foo, bar});
std::pair&lt;int, int&gt; p{foo, bar};

// When you have to wrap.
SomeFunction(
    {"assume a zero-length name before {"},
    some_other_function_parameter);
SomeType variable{
    some, other, values,
    {"assume a zero-length name before {"},
    SomeOtherType{
        "Very long string requiring the surrounding breaks.",
        some, other, values},
    SomeOtherType{"Slightly shorter string",
                  some, other, values}};
SomeType variable{
    "This is too long to fit all in one line"};
MyType m = {  // Here, you could also break before {.
    superlongvariablename1,
    superlongvariablename2,
    {short, interior, list},
    {interiorwrappinglist,
     interiorwrappinglist2}};
</pre>
        </div>
        <pre>// 1行の初期化子リストの例
return {foo, bar};
functioncall({foo, bar});
std::pair&lt;int, int&gt; p{foo, bar};

// 複数行にする場合
SomeFunction(
    {"{の前に、0文字の名前があるかのように扱います"},
    some_other_function_parameter);
SomeType variable{
    some, other, values,
    {"{の前に、0文字の名前があるかのように扱います"},
    SomeOtherType{
        "それの前後に改行を要するようなとてもとても長い文字列。",
        some, other, values},
    SomeOtherType{"それよりは少し短めの文字列",
                  some, other, values}};
SomeType variable{
    "全体を1行に納めるには少しばかり長すぎる文字列"};
MyType m = {  // {の前で改行してもかまいません
    superlongvariablename1,  // 超長い変数名
    superlongvariablename2,
    {short, interior, list}, // 短いリスト
    {interiorwrappinglist,   // 改行を要するリスト
     interiorwrappinglist2}};
</pre>
    </div>

    <a id="Conditionals"></a>
    <h3 id="Formatting_Looping_Branching"><span title="Looping and branching statements">ループと条件分岐</span></h3>


<p><span><span class="src">
At a high level, looping or branching statements consist of the following
<strong>components</strong>:
</span>
おおまかに、ループや分岐のための文は、次のような<strong>部品</strong>から成り立っていると言えます。</span>
</p><ul>
  <li><span><span class="src">One or more <strong>statement keywords</strong> (e.g. <code>if</code>,
  <code>else</code>, <code>switch</code>, <code>while</code>, <code>do</code>,
  or <code>for</code>).</span>
  1つ以上の<strong>キーワード(statement keywords)</strong>(<code>if</code>,
  <code>else</code>, <code>switch</code>, <code>while</code>, <code>do</code>,
  <code>for</code>) 
  </span></li>
  <li><span><span class="src">One <strong>condition or iteration specifier</strong>, inside
  parentheses.</span>括弧で囲まれた、1つの<strong>条件指定子(condition specifier)</strong>もしくは<strong>イテレーション指定子(iteration specifier)</strong></span></li>
  <li><span><span class="src">One or more <strong>controlled statements</strong>, or blocks of
  controlled statements.</span>1つ以上の<strong>制御対象文(controlled statements)</strong>もしくはそのブロック</span></li>
</ul>
<p><span><span class="src">For these statements:</span>これらの文について:</span></p>

<ul>
  <li><span><span class="src">
  The components of the statement should be separated by single spaces (not
  line breaks).</span>
  文を構成する<strong>部品</strong>同士の間は、改行せず1つのスペースで区切ります。</span></li>
  <li><span><span class="src">
  Inside the condition or iteration specifier, put one space (or a line
  break) between each semicolon and the next token, except if the token is a
  closing parenthesis or another semicolon.</span>
  <strong>条件指定子</strong>や<strong>イテレーション指定子</strong>の内側において、各セミコロン<code>;</code>と続くトークンの間は1つのスペース(か改行)で区切ります。ただし、セミコロン<code>;</code>の次のトークンが閉じ丸括弧<code>)</code>あるいはセミコロン<code>;</code>であるときはスペース(か改行)を省きます。</span></li>
  <li><span><span class="src">
  Inside the condition or iteration specifier, do not put a space after the
  opening parenthesis or before the closing parenthesis.</span>
  <strong>条件指定子</strong>や<strong>イテレーション指定子</strong>の内側において、開き丸括弧<code>(</code>の後や閉じ丸括弧<code>)</code>の前にはスペースを入れません。
  </span></li>
  <li><span><span class="src">
  Put any controlled statements inside blocks (i.e. use curly braces).</span>
  すべての<strong>制御対象文</strong>はブロックに入れます(つまり、常に波括弧<code>{...}</code>で囲みます)。
  </span></li>
  <li><span><span class="src">
  Inside the controlled blocks, put one line break immediately after the
  opening brace, and one line break immediately before the closing brace.</span>
  <strong>制御対象文</strong>のブロックの内側では、開き波括弧<code>{</code>の後で1回改行し、閉じ波括弧<code>}</code>の前で1回改行します。
  </span></li>
</ul>

<div><div class="src">
<pre>if (condition) {                   // Good - no spaces inside parentheses, space before brace.
  DoOneThing();                    // Good - two-space indent.
  DoAnotherThing();
} else if (int a = f(); a != 3) {  // Good - closing brace on new line, else on same line.
  DoAThirdThing(a);
} else {
  DoNothing();
}

// Good - the same rules apply to loops.
while (condition) {
  RepeatAThing();
}

// Good - the same rules apply to loops.
do {
  RepeatAThing();
} while (condition);

// Good - the same rules apply to loops.
for (int i = 0; i &lt; 10; ++i) {
  RepeatAThing();
}
</pre></div>
<pre>if (condition) {                   // 良い例。丸括弧内はスペースなし、開き波括弧の前にスペースあり
  DoOneThing();                    // 良い例。スペース2つでインデント
  DoAnotherThing();
} else if (int a = f(); a != 3) {  // 良い例。閉じ波括弧の前で改行、elseは同一行内
  DoAThirdThing(a);
} else {
  DoNothing();
}

// 良い例。ループ文にも同じルールを適用します
while (condition) {
  RepeatAThing();
}

// 良い例。ループ文にも同じルールを適用します
do {
  RepeatAThing();
} while (condition);

// 良い例。ループ文にも同じルールを適用します
for (int i = 0; i &lt; 10; ++i) {
  RepeatAThing();
}
</pre>
</div>

<div><div class="src">
<pre class="badcode">if(condition) {}                   // Bad - space missing after `if`.
else if ( condition ) {}           // Bad - space between the parentheses and the condition.
else if (condition){}              // Bad - space missing before `{`.
else if(condition){}               // Bad - multiple spaces missing.

for (int a = f();a == 10) {}       // Bad - space missing after the semicolon.

// Bad - `if ... else` statement does not have braces everywhere.
if (condition)
  foo;
else {
  bar;
}

// Bad - `if` statement too long to omit braces.
if (condition)
  // Comment
  DoSomething();

// Bad - `if` statement too long to omit braces.
if (condition1 &amp;&amp;
    condition2)
  DoSomething();
</pre></div>
<pre class="badcode">if(condition) {}                   // ダメ。ifの後にスペースがない。
else if ( condition ) {}           // ダメ。括弧と条件の間にスペースがある。
else if (condition){}              // ダメ。{の前にスペースがない。
else if(condition){}               // ダメ。諸々スペースがない

for (int a = f();a == 10) {}       // ダメ。セミコロンの後にスペースがない。

// ダメ。`if ... else`文のすべての場所に{}がない
if (condition)
  foo;
else {
  bar;
}

// ダメ。{}を省略するにはif文が長すぎる
if (condition)
  // 何かしらコメント何かしらコメント何かしらコメント
  DoSomething();

// ダメ。{}を省略するにはif文が長すぎる
if (condition1 &amp;&amp;
    condition2)
  DoSomething();
</pre></div>

    <p>
        <span>
            <span class="src">
                For historical reasons, we allow one exception to the above rules: the curly
                braces for the controlled statement or the line breaks inside the curly braces
                may be omitted if as a result the entire statement appears on either a single
                line (in which case there is a space between the closing parenthesis and the
                controlled statement) or on two lines (in which case there is a line break
                after the closing parenthesis and there are no braces).
            </span>
            歴史的経緯により、このルールについては例外を設けています。
            全体が1行か2行におさまる場合、制御対象文を囲む波括弧自体や、あるいは、波括弧の内側の改行を省略しても許容するものとします。
            全体を1行とする場合は、条件の閉じ括弧<code>)</code>と制御対象文との間に1つスペースをあけます。
            全体を2行とする場合は、条件の閉じ括弧<code>)</code>の直後で改行し、波括弧を削ります。
        </span>
    </p>
<div><div class="src">
<pre class="neutralcode">// OK - fits on one line.
if (x == kFoo) { return new Foo(); }

// OK - braces are optional in this case.
if (x == kFoo) return new Foo();

// OK - condition fits on one line, body fits on another.
if (x == kBar)
  Bar(arg1, arg2, arg3);
</pre></div>
<pre class="neutralcode">// 許容される例。1行におさまっている。
if (x == kFoo) { return new Foo(); }

// 許容される例。このケースでは{}を省略できます。
if (x == kFoo) return new Foo();

// 許容される例。条件が1行に、制御対象文が次の1行におさまっている。
if (x == kBar)
  Bar(arg1, arg2, arg3);
</pre>
</div>

    <p>
        <span>
            <span class="src">
                This exception does not apply to multi-keyword statements like
                <code>if ... else</code> or <code>do ... while</code>.
            </span>
            ただし、この例外ルールは、<code>if...else</code>や、<code>do...while</code>等の、複数のキーワードからなる構文には適用されません。
        </span>
    </p>

<div><div class="src">
<pre class="badcode">// Bad - `if ... else` statement is missing braces.
if (x) DoThis();
else DoThat();

// Bad - `do ... while` statement is missing braces.
do DoThis();
while (x);
</pre></div>
<pre class="badcode">// ダメ。`if ... else`の形においては{}は省略不可
if (x) DoThis();
else DoThat();

// ダメ。`do ... while`の形においては{}は省略不可
do DoThis();
while (x);
</pre>
</div>

    <p>
        <span>
            <span class="src">
                Use this style only when the statement is brief, and consider that loops and
                branching statements with complex conditions or controlled statements may be
                more readable with curly braces.
            </span>
            このスタイルは、文が短く簡潔である場合にのみ適用してください。
            ループや条件分岐が、複雑な条件や制御対象文を持つ場合は、波括弧を用いて読みやすくすることができないか検討してください。
        </span>
        <span>
            <span class="src">
                Some
                projects require curly braces always.
            </span>
            また、プロジェクトによっては、常に波括弧を必須とするよう定めていることもありますので注意してください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                <code>case</code> blocks in <code>switch</code> statements can have curly
                braces or not, depending on your preference.
            </span>
            <code>switch</code>文の<code>case</code>ブロックでは、波括弧を書いても書かなくてもかまいません。
        </span>
        <span>
            <span class="src">
                If you do include curly braces,
                they should be placed as shown below.
            </span>
            もし、波括弧を書く場合は、次のようにしてください。
        </span>
    </p>
    <div>
        <div class="src">
<pre>switch (var) {
  case 0: {  // 2 space indent
    Foo();   // 4 space indent
    break;
  }
  default: {
    Bar();
  }
}
</pre>
        </div>
        <pre>switch (var) {
  case 0: {  // スペース2つでインデント
    Foo();   // スペース4つでインデント
    break;
  }
  default: {
    Bar();
  }
}
</pre>
    </div>
    <p>
        <span>
            <span class="src">
                Empty loop bodies should use either an empty pair of braces or
                <code>continue</code> with no braces, rather than a single semicolon.
            </span>
            ループの本体が空になる場合は、波括弧による空のブロックとするか、波括弧なしで<code>continue</code>を使います。セミコロンだけを書いてはいけません。
        </span>
    </p>
    <div>
        <div class="src">
            <pre>while (condition) {}  // Good - `{}` indicates no logic.
while (condition) {
  // Comments are okay, too
}
while (condition) continue;  // Good - `continue` indicates no logic.
</pre>
            </div>
            <pre>while (condition) {}  // 良い例。`{}`によって、ロジックがないことを明示している。
while (condition) {
  // コメントだけを書いてもよい
}
while (condition) continue;  // 良い例。 `continue` によって、ロジックがないことを明示している。
</pre>
        </div>
        <div>
            <div class="src">
                <pre class="badcode">while (condition);  // Bad - looks like part of `do-while` loop.
</pre>
            </div>
            <pre class="badcode">while (condition);  // ダメ。do-whileループの一部にも見える。
</pre>
        </div>


    <h3 id="Pointer_and_Reference_Expressions"><span title="Pointer and Reference Expressions">ポインタと参照の表現</span></h3>

    <p>
        <span>
            <span class="src">
                No spaces around period or arrow.
            </span>
            ドット演算子やアロー演算子の周りにスペースは使いません。
        </span>
        <span>
            <span class="src">
                Pointer operators do not
                have trailing spaces.
            </span>
            ポインタ演算子の後にはスペースを使いません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                The following are examples of correctly-formatted
                pointer and reference expressions:
            </span>
            ポインタおよび参照に関する正しいフォーマットの例を以下に示します。
        </span>
    </p>

    <pre>x = *p;
p = &amp;x;
x = r.y;
x = r-&gt;y;
</pre>
    <p>
        <span>
            <span class="src">
                Note that:
            </span>
            以下のことに注意してください。
        </span>
    </p>

    <ul>
        <li>
            <span>
                <span class="src">
                    There are no spaces around the period or arrow when
                    accessing a member.
                </span>
                メンバにアクセスするためのドット演算子(<code>.</code>)やアロー演算子(<code>-&gt;</code>)の周りにはスペースを置きません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Pointer operators have no space after the
                    <code>*</code> or
                    <code>&amp;</code>.
                </span>
                ポインタ演算子(<code>*</code>や<code>&amp;</code>)の後にはスペースを置きません。
            </span>
        </li>
    </ul>

    <p>
        <span>
            <span class="src">
                When referring to a pointer or reference (variable declarations or definitions, arguments,
                return types, template parameters, etc), you may place the space before or after the
                asterisk/ampersand.
            </span>
            ポインタや参照を宣言する(変数宣言や定義、引数、戻り値型、テンプレート引数など)ときは、アスタリスク(<code>*</code>)やアンパサンド(<code>&amp;</code>)を型名と変数名のどちらにつけてもかまいません。
        </span>
        <span>
            <span class="src">
                In the trailing-space style, the space is elided in some cases (template
                parameters, etc).
            </span>
            後ろにスペースを置くスタイルの場合、テンプレート引数などの型名のみを表記する箇所ではスペースは省略されることがあります。
        </span>
    </p>

    <div>
        <div class="src">
            <pre>// These are fine, space preceding.
char *c;
const std::string &amp;str;
int *GetPointer();
std::vector&lt;char *&gt;

// These are fine, space following (or elided).
char* c;
const std::string&amp; str;
int* GetPointer();
std::vector&lt;char*&gt;  // Note no space between '*' and '&gt;'
</pre>
        </div>
        <pre>// これらはどちらもOK。スペースが先。
char *c;
const std::string &amp;str;
int *GetPointer();
std::vector&lt;char *&gt;

// これらもどちらもOK。スペースが後。
char* c;
const std::string&amp; str;
int* GetPointer();
std::vector&lt;char*&gt;  // '*' と '&gt;'の間にスペースがない点に注意
</pre>
    </div>

    <p>
        <span>
            <span class="src">
                You should do this consistently within a single
                file.
            </span>
            1つのファイル内では一貫性を保つようにしてください。
        </span>
        <span>
            <span class="src">
                When modifying an existing file, use the style in
                that file.
            </span>
            既存のファイルを変更するときは、そのファイル内で使われているスタイルにあわせてください。
        </span>
    </p>

    <span>
        <span class="src">
            It is allowed (if unusual) to declare multiple variables in the same
            declaration, but it is disallowed if any of those have pointer or
            reference decorations.
        </span>
        変数宣言において、通常、1つの宣言で複数の変数をまとめて宣言することは問題ありません。しかし、その宣言の中に1つでもポインタや参照の宣言を含む場合は同時に宣言してはいけません。
    </span>
    <span>
        <span class="src">
            Such declarations are easily misread.
        </span>
        そのような宣言は簡単に読み違えてしまうためです。
    </span>
    <div>
        <div class="src">
            <pre>// Fine if helpful for readability.
int x, y;
</pre>
        </div>
        <pre>// 可読性が高まる場合は複数の変数を同時に宣言してOK。
int x, y;
</pre>
    </div>

    <div>
        <div class="src">
            <pre class="badcode">int x, *y;  // Disallowed - no &amp; or * in multiple declaration
char * c;  // Bad - spaces on both sides of *
const std::string &amp; str;  // Bad - spaces on both sides of &amp;
</pre>
        </div>
        <pre class="badcode">int x, *y;  // 不可。&amp;や*が複数宣言の中に含められている。
char * c;  // ダメ。*の前後両方にスペースがある。
const std::string &amp; str;  // ダメ。&amp;の前後両方にスペースがある。
</pre>
    </div>

    <h3 id="Boolean_Expressions"><span title="Boolean Expressions">ブーリアン式</span></h3>

    <p>
        <span>
            <span class="src">
                When you have a boolean expression that is longer than the
                <a href="#Line_Length">standard line length</a>, be
                consistent in how you break up the lines.
            </span>
            ブーリアン式が<a href="#Line_Length">標準の行の長さ</a>を超えるような場合、行の区切り方について一貫性を保ってください。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                In this example, the logical AND operator is always at
                the end of the lines:
            </span>
            たとえば、次のコード例では、論理積演算子(<code>&amp;&amp;</code>)を常に行末に配置しています。
        </span>
    </p>

    <div>
        <div class="src">
            <pre>if (this_one_thing &gt; this_other_thing &amp;&amp;
    a_third_thing == a_fourth_thing &amp;&amp;
    yet_another &amp;&amp; last_one) {
  ...
}
</pre>
        </div>
        <pre>if (this_one_thing &gt; this_other_thing &amp;&amp;
    a_third_thing == a_fourth_thing &amp;&amp;
    yet_another &amp;&amp; last_one) {
  ...
}
</pre>
    </div>

    <p>
        <span>
            <span class="src">
                Note that when the code wraps in this example, both of
                the
                <code>&amp;&amp;</code> logical AND operators are at
                the end of the line.
            </span>
            この例において、両方の論理積演算子(<code>&amp;&amp;</code>)が、いずれも行末にあることに注目してください。
        </span>
        <span>
            <span class="src">
                This is more common in Google code,
                though wrapping all operators at the beginning of the
                line is also allowed.
            </span>
            Googleのコードにおいては、どちらかといえば演算子を行末に置く形がよく使われますが、演算子を次の行の頭に置くスタイルでもかまいません。
        </span>
        <span>
            <span class="src">
                Feel free to insert extra
                parentheses judiciously because they can be very helpful
                in increasing readability when used
                appropriately, but be careful about overuse.
            </span>
            また、これらの式において、余分な丸括弧を適切に挿入することで、大幅に可読性を高められることがあります。そのような丸括弧は自由に挿入してかまいません。ただし、使いすぎには気をつけてください。
        </span>
        <span>
            <span class="src">
                Also note that you should always use
                the punctuation operators, such as
                <code>&amp;&amp;</code> and <code>~</code>, rather than
                the word operators, such as <code>and</code> and
                <code>compl</code>.
            </span>
            なお、これらの論理演算を行う際は、<code>and</code>や<code>compl</code>のような単語による演算子ではなく、常に<code>&amp;&amp;</code>や<code>~</code>のような記号による演算子を使用してください。
        </span>
    </p>
    <h3 id="Return_Values"><span title="Return Values">戻り値</span></h3>

    <p>
        <span>
            <span class="src">
                Do not needlessly surround the <code>return</code>
                expression with parentheses.
            </span>
            <code>return</code>文の式を不要な丸括弧で囲んではいけません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Use parentheses in
                <code>return expr;</code> only
                where you would use them in
                <code>x = expr;</code>.
            </span>
            <code>return expr;</code>に丸括弧を使うのは、式が<code>x = expr;</code>の形をしている場合のみです。
        </span>
    </p>

    <div>
        <div class="src">
            <pre>return result;                  // No parentheses in the simple case.
// Parentheses OK to make a complex expression more readable.
return (some_long_condition &amp;&amp;
        another_condition);
</pre>
        </div>
        <pre>return result;                  // 単純なものには丸括弧を使いません。

// これはOK。複雑な式を読みやすくするために、丸括弧を使っています。
return (some_long_condition &amp;&amp;
        another_condition);
</pre>
    </div>
    <div>
        <div class="src">
            <pre class="badcode">return (value);                // You wouldn't write var = (value);
return(result);                // return is not a function!
</pre>
        </div>
        <pre class="badcode">return (value);                // var = (value);とは書かないでしょう。
return(result);                // returnは関数ではありません！
</pre>
    </div>

    <h3 id="Variable_and_Array_Initialization"><span title="Variable and Array Initialization">変数と配列の初期化</span></h3>

    <p>
        <span>
            <span class="src">
                You may choose between
                <code>=</code>,
                <code>()</code>, and
                <code>{}</code>; the following are
                all correct:
            </span>
            <code>=</code>と<code>()</code>と<code>{}</code>のうち、いずれを使用してもかまいません。次の例はすべてOKです。
        </span>
    </p>

    <div>
        <div class="src">
            <pre>int x = 3;
int x(3);
int x{3};
std::string name = "Some Name";
std::string name("Some Name");
std::string name{"Some Name"};
</pre>
        </div>
        <pre>int x = 3;
int x(3);
int x{3};
std::string name = "Some Name";
std::string name("Some Name");
std::string name{"Some Name"};
</pre>
    </div>

    <p>
        <span>
            <span class="src">
                Be careful when using a braced initialization list
                <code>{...}</code>
                on a type with an
                <code>std::initializer_list</code> constructor.
            </span>
            ただし、波括弧による初期化子リスト<code>{...}</code>は、型が<code>std::initializer_list</code>を引数にとるコンストラクタを持つ場合に注意が必要です。
        </span>
        <span>
            <span class="src">
                A nonempty
                <i>braced-init-list</i> prefers the
                <code>std::initializer_list</code> constructor whenever
                possible.
            </span>
            空でない波括弧初期化リストは、可能な限り<code>std::initializer_list</code>のコンストラクタを呼び出そうとします。
        </span>
        <span>
            <span class="src">
                Note that empty braces <code>{}</code> are special, and
                will call a default constructor if available.
            </span>
            しかし、リストが空<code>{}</code>のときは特殊で、デフォルトコンストラクタが優先的に呼び出されます。
        </span>
        <span>
            <span class="src">
                To force the
                non-<code>std::initializer_list</code> constructor, use parentheses
                instead of braces.
            </span>
            <code>std::initializer_list</code>では<strong>ない</strong>コンストラクタを呼び出すことを強制するためには、波括弧<code>{}</code>ではなく丸括弧<code>()</code>を使ってください。
        </span>
    </p>

    <div>
        <div class="src">
            <pre>std::vector&lt;int&gt; v(100, 1);  // A vector containing 100 items: All 1s.
std::vector&lt;int&gt; v{100, 1};  // A vector containing 2 items: 100 and 1.
</pre>
        </div>
        <pre>std::vector&lt;int&gt; v(100, 1);  // 中身は「1」が100個。
std::vector&lt;int&gt; v{100, 1};  // 中身は「100」と「1」の2個。
</pre>
    </div>

    <p>
        <span>
            <span class="src">
                Also, the brace form prevents narrowing of integral
                types.
            </span>
            また、整数型に波括弧による初期化子の形を用いると、小さい型への変換を防ぐことができます。
        </span>
        <span>
            <span class="src">
                This can prevent some types of programming
                errors.
            </span>
            これによって、プログラミング上のミスを防げます。
        </span>
    </p>

    <div>
        <div class="src">
            <pre>int pi(3.14);  // OK -- pi == 3.
int pi{3.14};  // Compile error: narrowing conversion.
</pre>
        </div>
        <pre>int pi(3.14);  // コンパイルが通る。 pi == 3 になる。
int pi{3.14};  // コンパイルエラー: より小さい型への変換
</pre>
    </div>

    <h3 id="Preprocessor_Directives"><span title="Preprocessor Directives">プリプロセッサディレクティブ</span></h3>

    <p>
        <span>
            <span class="src">
                The hash mark that starts a preprocessor directive should
                always be at the beginning of the line.
            </span>
            プリプロセッサディレクティブのための<code>#</code>は、常に行頭に置きます。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Even when preprocessor directives are within the body
                of indented code, the directives should start at the
                beginning of the line.
            </span>
            たとえプリプロセッサディレクティブをインデントされているコードの中に書く場合であっても、ディレクティブは行の頭から記述します。
        </span>
    </p>

    <div>
        <div class="src">
            <pre>// Good - directives at beginning of line
  if (lopsided_score) {
#if DISASTER_PENDING      // Correct -- Starts at beginning of line
    DropEverything();
# if NOTIFY               // OK but not required -- Spaces after #
    NotifyClient();
# endif
#endif
    BackToNormal();
  }
</pre>
        </div>
        <pre>// OK。プリプロセッサが行の頭にある。
  if (lopsided_score) {
#if DISASTER_PENDING      // 正しい。行頭から始める。
    DropEverything();
# if NOTIFY               // #の後にスペースもOK(必須ではない)。
    NotifyClient();
# endif
#endif
    BackToNormal();
  }
</pre>
    </div>
    <div>
        <div class="src">
            <pre class="badcode">// Bad - indented directives
  if (lopsided_score) {
    #if DISASTER_PENDING  // Wrong!  The "#if" should be at beginning of line
    DropEverything();
    #endif                // Wrong!  Do not indent "#endif"
    BackToNormal();
  }
</pre>
        </div>
        <pre class="badcode">// ダメ。ディレクティブがインデントされている。
  if (lopsided_score) {
    #if DISASTER_PENDING  // 間違い！ "#if"は行頭になくてはならない。
    DropEverything();
    #endif                // 間違い！ #endifをインデントしてはダメ。
    BackToNormal();
  }
</pre>
    </div>

    <h3 id="Class_Format"><span title="Class Format">クラスのフォーマット</span></h3>

    <p>
        <span>
            <span class="src">
                Sections in <code>public</code>, <code>protected</code> and
                <code>private</code> order, each indented one space.
            </span>
            クラス内のセクションは<code>public</code>、<code>protected</code>、<code>private</code>の順で並べ、これらのラベルはスペース1文字でインデントします。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                The basic format for a class definition (lacking the
                comments, see<a href="#Class_Comments">Class
                Comments</a> for a discussion of what comments are
                needed) is:
            </span>
            クラス定義の基本的なフォーマットを以下に示します(ただし、コメントは省いています。コメントについては、<a href="#Class_Comments">クラスのコメント</a>で議論しています)
        </span>
    </p>

    <div>
        <div class="src">
            <pre>class MyClass : public OtherClass {
 public:      // Note the 1 space indent!
  MyClass();  // Regular 2 space indent.
  explicit MyClass(int var);
  ~MyClass() {}

  void SomeFunction();
  void SomeFunctionThatDoesNothing() {
  }

  void set_some_var(int var) { some_var_ = var; }
  int some_var() const { return some_var_; }

 private:
  bool SomeInternalFunction();

  int some_var_;
  int some_other_var_;
};
</pre>
        </div>
        <pre>class MyClass : public OtherClass {
 public:      // 注意: スペース1つでインデント！
  MyClass();  // いつもの。スペース2つでインデント
  explicit MyClass(int var);
  ~MyClass() {}

  void SomeFunction();
  void SomeFunctionThatDoesNothing() {
  }

  void set_some_var(int var) { some_var_ = var; }
  int some_var() const { return some_var_; }

 private:
  bool SomeInternalFunction();

  int some_var_;
  int some_other_var_;
};
</pre>
    </div>

    <p>
        <span>
            <span class="src">
                Things to note:
            </span>
            次の点に注意してください。
        </span>
    </p>

    <ul>
        <li>
            <span>
                <span class="src">
                    Any base class name should be on the same line as
                    the subclass name, subject to the 80-column limit.
                </span>
                基底クラス名は派生クラス名と同じ行に配置します。ただし、行の長さの制限(80文字)には従います。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    The <code>public:</code>,<code>protected:</code>,
                    and <code>private:</code> keywords should be indented
                    one space.
                </span>
                <code>public:</code>と<code>protected:</code>と<code>private:</code>の各キーワードは、スペース1つでインデントします。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Except for the first instance, these keywords
                    should be preceded by a blank line.
                </span>
                これらのキーワードのうち最初に現れるものを除いて、キーワードの前には1行の空行を挟みます。
            </span>
            <span>
                <span class="src">
                    This rule is
                    optional in small classes.
                </span>
                小さなクラスにおいては、必ずしもこのルールに従わなくてもかまいません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Do not leave a blank line after these
                    keywords.
                </span>
                これらのキーワードの後には空行を入れてはいけません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    The <code>public</code> section should be first,
                    followed by the <code>protected</code> and finally the
                    <code>private</code> section.
                </span>
                <code>public</code>セクションを最初に置き、次に<code>protected</code>、最後に<code>private</code>の順にします。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    See<a href="#Declaration_Order">Declaration
                    Order</a> for rules on ordering declarations within
                    each of these sections.
                </span>
                また、各セクション内での宣言は、<a href="#Declaration_Order">宣言の順序</a>に従って並べてください。
            </span>
        </li>
    </ul>

    <h3 id="Constructor_Initializer_Lists"><span title="Constructor Initializer Lists">コンストラクタの初期化子リスト</span></h3>

    <p>
        <span>
            <span class="src">
                Constructor initializer lists can be all on one line or
                with subsequent lines indented four spaces.
            </span>
            コンストラクタの初期化子リストは、すべて同じ行に収めるか、行を分ける場合は、続く行をスペース4つでインデントします。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                The acceptable formats for initializer lists are:
            </span>
            初期化子リストの正しい例を以下に示します。
        </span>
    </p>

    <div>
        <div class="src">
            <pre>// When everything fits on one line:
MyClass::MyClass(int var) : some_var_(var) {
  DoSomething();
}

// If the signature and initializer list are not all on one line,
// you must wrap before the colon and indent 4 spaces:
MyClass::MyClass(int var)
    : some_var_(var), some_other_var_(var + 1) {
  DoSomething();
}

// When the list spans multiple lines, put each member on its own line
// and align them:
MyClass::MyClass(int var)
    : some_var_(var),             // 4 space indent
      some_other_var_(var + 1) {  // lined up
  DoSomething();
}

// As with any other code block, the close curly can be on the same
// line as the open curly, if it fits.
MyClass::MyClass(int var)
    : some_var_(var) {}
</pre>
        </div>
        <pre>// 1行にすべて収まるとき
MyClass::MyClass(int var) : some_var_(var) {
  DoSomething();
}

// 関数シグネチャと初期化子リストの全体が1行に収まらない場合は、
// コロンの前で行を区切り、スペース4つでインデントします。
MyClass::MyClass(int var)
    : some_var_(var), some_other_var_(var + 1) {
  DoSomething();
}

// 初期化子リストが複数行にまたがる場合は、
// 1行に1つずつメンバ変数を書くようにし、それらを整列させます。
MyClass::MyClass(int var)
    : some_var_(var),             // スペース4つでインデント。
      some_other_var_(var + 1) {  // 整列させます
  DoSomething();
}

// 他のコードブロックと同様ですが、1行に収まるのであれば、
// 開き波括弧`{`と、閉じ波括弧`}`を、同じ行においてもかまいません。
MyClass::MyClass(int var)
    : some_var_(var) {}
</pre>
    </div>

    <h3 id="Namespace_Formatting"><span title="Namespace Formatting">名前空間のフォーマット</span></h3>

    <p>
        <span>
            <span class="src">
                The contents of namespaces are not indented.
            </span>
            名前空間の内容はインデントしません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                <a href="#Namespaces">Namespaces</a> do not add an
                extra level of indentation.
            </span>
            <a href="#Namespaces">名前空間</a>ではインデントを足しません。
        </span>

        <span>
            <span class="src">
                For example, use:
            </span>
            たとえば、次のようにします。
        </span>
    </p>

    <div>
        <div class="src">
            <pre>namespace {

void foo() {  // Correct.  No extra indentation within namespace.
  ...
}

}  // namespace
</pre>
        </div>
        <pre>namespace {

void foo() {  // 正しい。名前空間はインデントを追加しない。
  ...
}

}  // namespace
</pre>
    </div>

    <p>
        <span>
            <span class="src">
                Do not indent within a namespace:
            </span>
            名前空間の中ではインデントしてはいけません。
        </span>
    </p>

    <div>
        <div class="src">
            <pre class="badcode">namespace {

  // Wrong!  Indented when it should not be.
  void foo() {
    ...
  }

}  // namespace
</pre>
        </div>
        <pre class="badcode">namespace {

  // 間違い！　インデントしてはだめ。
  void foo() {
    ...
  }

}  // namespace
</pre>
    </div>

    <p>
        <span>
            <span class="src">
                When declaring nested namespaces, put each namespace
                on its own line.
            </span>
            名前空間の宣言をネストするときは、1行に1つずつにします。
        </span>
    </p>

    <div>
        <div class="src">
            <pre>namespace foo {
namespace bar {
</pre>
        </div>
        <pre>namespace foo {
namespace bar {
</pre>
    </div>

    <h3 id="Horizontal_Whitespace"><span title="Horizontal Whitespace">水平方向の空白</span></h3>

    <p>
        <span>
            <span class="src">
                Use of horizontal whitespace depends on location.
            </span>
            水平方向の空白は場所に応じて使いわけます。
        </span>
        <span>
            <span class="src">
                Never put
                trailing whitespace at the end of a line.
            </span>
            行末に空白をおいてはいけません。
        </span>
    </p>

    <h4 class="stylepoint_subsection"><span title="General">全般</span></h4>

    <div>
        <div class="src">
            <pre>int i = 0;  // Two spaces before end-of-line comments.

void f(bool b) {  // Open braces should always have a space before them.
  ...
int i = 0;  // Semicolons usually have no space before them.
// Spaces inside braces for braced-init-list are optional.  If you use them,
// put them on both sides!
int x[] = { 0 };
int x[] = {0};

// Spaces around the colon in inheritance and initializer lists.
class Foo : public Bar {
 public:
  // For inline function implementations, put spaces between the braces
  // and the implementation itself.
  Foo(int b) : Bar(), baz_(b) {}  // No spaces inside empty braces.
  void Reset() { baz_ = 0; }  // Spaces separating braces from implementation.
  ...
</pre>
        </div>
        <pre>int i = 0;  // 行末コメントの前にはスペース2つ。

void f(bool b) {  // 開き波括弧{の前には常にスペースを置く。
  ...

int i = 0;  // 通常は、セミコロンの前にスペースを置かない。

// 波括弧初期化子リスト{}の内側のスペースは任意。
// ただし、スペースを置く場合は、必ず左右の両方に置くこと。
int x[] = { 0 };
int x[] = {0};

// 継承や初期化子リストのコロンの前後にはスペースを置く。
class Foo : public Bar {
 public:
  // インライン関数の実装において、波括弧と実装の間にはスペースを置く。
  Foo(int b) : Bar(), baz_(b) {}  // 空の実装にはスペースを置かない。
  void Reset() { baz_ = 0; }  // 波括弧と実装との間にはスペースを置く。
  ...
</pre>
    </div>

    <p>
        <span>
            <span class="src">
                Adding trailing whitespace can cause extra work for
                others editing the same file, when they merge, as can
                removing existing trailing whitespace.
            </span>
            行末にスペースを追加してしまうと、同じファイルで作業している他の人がファイルをマージする際に、これらのスペースを取り除くなどの余計な仕事を発生させてしまいます。
        </span>
        <span>
            <span class="src">
                So: Don't
                introduce trailing whitespace.
            </span>
            ですから、行末にスペースを入れてはいけません。
        </span>
        <span>
            <span class="src">
                Remove it if you're
                already changing that line, or do it in a separate
                clean-up
                operation (preferably when no-one
                else is working on the file).
            </span>
            既存の行末のスペースは、そのような行を編集したタイミングで取り除くか、あるいは、別途、コードを整理するタイミングを設けて、まとめて取り除くようにしてください(この場合は、そのファイルを誰も編集していないときに行うのがよいでしょう)。
        </span>
    </p>

    <h4 class="stylepoint_subsection"><span title="Loops and Conditionals">ループと条件式</span></h4>

    <div>
        <div class="src">
            <pre>if (b) {          // Space after the keyword in conditions and loops.
} else {          // Spaces around else.
}
while (test) {}   // There is usually no space inside parentheses.
switch (i) {
for (int i = 0; i &lt; 5; ++i) {
// Loops and conditions may have spaces inside parentheses, but this
// is rare.  Be consistent.
switch ( i ) {
if ( test ) {
for ( int i = 0; i &lt; 5; ++i ) {
// For loops always have a space after the semicolon.  They may have a space
// before the semicolon, but this is rare.
for ( ; i &lt; 5 ; ++i) {
  ...

// Range-based for loops always have a space before and after the colon.
for (auto x : counts) {
  ...
}
switch (i) {
  case 1:         // No space before colon in a switch case.
    ...
  case 2: break;  // Use a space after a colon if there's code after it.
</pre>
        </div>
        <pre>if (b) {          // 条件文キーワードやループキーワードは直後にスペースを置きます。
} else {          // elseは前後にスペースを置きます。
}
while (test) {}   // 通常、丸括弧の内側にはスペースを置きません。
switch (i) {
for (int i = 0; i &lt; 5; ++i) {

// ループと条件式の丸括弧の内側には、スペースを置いてもかまいませんが、
// そのようなケースはレアケースです。周りとの一貫性を保ってください。
switch ( i ) {
if ( test ) {
for ( int i = 0; i &lt; 5; ++i ) {

// ループでは、常にセミコロンの後にスペースを置きます。
// セミコロンの前にもスペースを置いてもかまいませんが、レアケースです。
for ( ; i &lt; 5 ; ++i) {
  ...

// 範囲for文(range-based for)では、常にコロンの前後にスペースを置きます。
for (auto x : counts) {
  ...
}
switch (i) {
  case 1:         // caseのコロンの前にはスペースを置きません。
    ...
  case 2: break;  // コロンの後にコードが続く場合は、その前にスペースを置きます。
</pre>
    </div>

    <h4 class="stylepoint_subsection"><span title="Operators">演算子</span></h4>

    <div>
        <div class="src">
            <pre>// Assignment operators always have spaces around them.
x = 0;

// Other binary operators usually have spaces around them, but it's
// OK to remove spaces around factors.  Parentheses should have no
// internal padding.
v = w * x + y / z;
v = w*x + y/z;
v = w * (x + z);

// No spaces separating unary operators and their arguments.
x = -5;
++x;
if (x &amp;&amp; !y)
  ...
</pre>
        </div>
        <pre>// 代入演算子の前後には常にスペースを置きます。
x = 0;

// その他の二項演算子の前後には、通常はスペースを置きます。
// ただし項の前後のスペースは、適宜削除してもかまいません。
// 丸括弧を使う場合は、その内側にはスペースを置きません。
v = w * x + y / z;
v = w*x + y/z;
v = w * (x + z);

// 単項演算子においては、その引数との間にスペースは置きません。
x = -5;
++x;
if (x &amp;&amp; !y)
  ...
</pre>
    </div>

    <h4 class="stylepoint_subsection"><span title="Templates and Casts">テンプレートとキャスト</span></h4>

    <div>
        <div class="src">
            <pre>// No spaces inside the angle brackets (&lt; and &gt;), before
// &lt;, or between &gt;( in a cast
std::vector&lt;std::string&gt; x;
y = static_cast&lt;char*&gt;(x);

// Spaces between type and pointer are OK, but be consistent.
std::vector&lt;char *&gt; x;
</pre>
        </div>
        <pre>// 山括弧(<code>&lt;</code>と<code>&gt;</code>)の内側にはスペースを置きません。
// キャストにおける<code>&lt;</code>の前や、
// <code>&gt;</code>と<code>(</code>との間にもスペースを置きません。
std::vector&lt;std::string&gt; x;
y = static_cast&lt;char*&gt;(x);

// ポインタと型名の間のスペースはOKですが、周囲との一貫性を保ってください。
std::vector&lt;char *&gt; x;
</pre>
    </div>

    <h3 id="Vertical_Whitespace"><span title="Vertical Whitespace">垂直方向の空白</span></h3>

    <p>
        <span>
            <span class="src">
                Minimize use of vertical whitespace.
            </span>
            垂直方向の空白は最小限にします。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                This is more a principle than a rule: don't use blank lines when
                you don't have to.
            </span>
            これはルールというよりも原則ですが、不要な空行をおいてはいけません。
        </span>
        <span>
            <span class="src">
                In particular, don't put more than one or two blank
                lines between functions, resist starting functions with a blank line,
                don't end functions with a blank line, and be sparing with your use of
                blank lines.
            </span>
            特に、関数と関数との間の空行は1行か2行までとし、関数を空行で始めたり終わらせたりせず、関数の中でも空行を使いすぎないようにしましょう。
        </span>
        <span>
            <span class="src">
                A blank line within a block of code serves like a
                paragraph break in prose: visually separating two thoughts.
            </span>
            コードブロック中の空行には、通常の散文において段落を区切るような、2つの考えや概念を視覚的に分離させるような効果があります。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                The basic principle is: The more code that fits on one screen, the
                easier it is to follow and understand the control flow of the
                program.
            </span>
            基本的な原則は「1画面に収まるコードが多ければ多いほど、プログラムの流れが追いやすく、理解しやすくなる」というものです。
        </span>
        <span>
            <span class="src">
                Use whitespace purposefully to provide separation in that
                flow.
            </span>
            空白は、フローを分離する目的をもって、意図的に使いましょう。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                Some rules of thumb to help when blank lines may be
                useful:
            </span>
            空行が有効に働くのはどのような場合か、経験則として、次のルールを参考にしてみてください。
        </span>
    </p>

    <ul>
        <li>
            <span>
                <span class="src">
                    Blank lines at the beginning or end of a function
                    do not help readability.
                </span>
                関数の最初や最後の空行を入れても、コードが読みやすくなることはありません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Blank lines inside a chain of if-else blocks may
                    well help readability.
                </span>
                if-elseブロックが連なっているとき、その中に空行を入れると、読みやすくなることがあります。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    A blank line before a comment line usually helps
                    readability — the introduction of a new comment suggests
                    the start of a new thought, and the blank line makes it clear
                    that the comment goes with the following thing instead of the
                    preceding.
                </span>
                通常、コメント行の前に空行をおくと、可読性が向上します。
                新しいコメントが入るということは、そこから新しい事柄が始まるということでもあります。
                コメントの前に空行を入れることによって、それまでのコードと新しいコメントとが分離され、そのコメントがその後に続く事柄に関するものであることを視覚的に表現できます。
            </span>
        </li>
        <li>
            <span>
                <span class="src">
                    Blank lines immediately inside a declaration of a namespace or block of
                    namespaces may help readability by visually separating the load-bearing
                    content from the (largely non-semantic) organizational wrapper.
                </span>
                名前空間の宣言(あるいは名前空間の宣言ブロック)のすぐ内側の空行には、その内容である主となるコンテンツと、具体的な意味を持たない組織のラッパーとを視覚的に分離する効果があり、この空行によって可読性が向上することがあります。
            </span>
            <span>
                <span class="src">
                    Especially
                    when the first declaration inside the namespace(s) is preceded by a comment,
                    this becomes a special case of the previous rule, helping the comment to
                    "attach" to the subsequent declaration.
                </span>
                特に、名前空間内にある最初の宣言がコメントで始まっている場合、これは先ほどのルールの特殊なケースにあたり、そのコメントが後に続く宣言の方に係っていることを示すのに役立ちます。
            </span>
        </li>
    </ul>

    <h2 id="Exceptions_to_the_Rules"><span title="Exceptions to the Rules">ルールの例外</span></h2>

    <p>
        <span>
            <span class="src">
                The coding conventions described above are mandatory.
            </span>
            ここまでに説明したコーディング規約はどれも必須とされるものです。
        </span>
        <span>
            <span class="src">
                However, like all good rules, these sometimes have exceptions,
                which we discuss here.
            </span>
            しかし、すべての良いルールがそうであるように、これらのルールにも例外があります。ここでは、それらの例外的な事項について議論します。
        </span>
    </p>

    <h3 id="Existing_Non-conformant_Code"><span title="Existing Non-conformant Code">ルールに沿っていない既存のコード</span></h3>
<!-- -->
    <p>
        <span>
            <span class="src">
                You may diverge from the rules when dealing with code that
                does not conform to this style guide.
            </span>
            既存のコードを取り扱うとき、そのコードがこのスタイルガイドのルールに沿って書かれたものでない場合は、このガイドのルールから外れてかまいません。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                If you find yourself modifying code that was written
                to specifications other than those presented by this
                guide, you may have to diverge from these rules in order
                to stay consistent with the local conventions in that
                code.
            </span>
            編集しているコードが、このガイドで提供しているルールとは異なるコーディング規約に従って書かれている場合、そのコードが従っているコーディング規約との一貫性を保つためには、このガイドのルールから外れる必要があるかもしれません。
        </span>
        <span>
            <span class="src">
                If you are in doubt about how to do this, ask the
                original author or the person currently responsible for
                the code.
            </span>
            どうしていいか迷った場合は、コードのオリジナルの著者や、現在の責任者に相談してください。
        </span>
        <span>
            <span class="src">
                Remember that <em>consistency</em> includes
                local consistency, too.
            </span>
            「<em>一貫性</em>」には、このような局所的なものも含まれています。そのことを忘れないでください。
        </span>
    </p>


    <h3 id="Windows_Code"><span title="Windows Code">Windowsのコード</span></h3>

    <p>
        <span>
            <span class="src">
                Windows
                programmers have developed their own set of coding
                conventions, mainly derived from the conventions in Windows
                headers and other Microsoft code.
            </span>
            Windowsプログラマーの間では、独自のコーディング規約が開発されてきました。これらは主にWindowsのヘッダーファイルや、その他のMicrosoftのコードが従っているコーディング規約から派生してきたものです。
        </span>
        <span>
            <span class="src">
                We want to make it easy
                for anyone to understand your code, so we have a single set
                of guidelines for everyone writing C++ on any platform.
            </span>
            私たちは、コードがすべての人にとって理解しやすくなることを望んでいるので、すべてのC++を書く人に向けた、プラットフォームに依存しない、たった1つのガイドラインのセットのみを用意しています。
        </span>
    </p>

    <p>
        <span>
            <span class="src">
                It is worth reiterating a few of the guidelines that
                you might forget if you are used to the prevalent Windows
                style:
            </span>
            一般的なWindowsスタイルに慣れているプログラマーにとって、忘れられやすいルールについてここでおさらいしておきましょう。
        </span>
    </p>

    <ul>
        <li>
            <span>
                <span class="src">
                    Do not use Hungarian notation (for example, naming
                    an integer
                    <code>iNum</code>).
                </span>
                ハンガリアン記法(たとえば、整数型に<code>iNum</code>と名付ける命名規則)は使いません。
            </span>
            <span>
                <span class="src">
                    Use the Google naming
                    conventions, including the <code>.cc</code> extension
                    for source files.
                </span>
                ソースコードの拡張子が<code>.cc</code>であることも含めて、Googleの命名規則に従ってください。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Windows defines many of its own synonyms for
                    primitive types, such as <code>DWORD</code>,
                    <code>HANDLE</code>, etc.
                </span>
                Windowsでは、<code>DWORD</code>や<code>HANDLE</code>などの、組み込み型に対する独自のシノニム(同義語)が大量に定義されています。
            </span>
            <span>
                <span class="src">
                    It is perfectly acceptable,
                    and encouraged, that you use these types when calling
                    Windows API functions.
                </span>
                Windows APIを呼び出すときにこれらの型を使用することはまったく問題なく、むしろ推奨されることです。
            </span>
            <span>
                <span class="src">
                    Even so, keep as close as you
                    can to the underlying C++ types.
                </span>
                ただし、その場合であっても、できる限り基礎となるC++の型から離れないようにしてください。
            </span>
            <span>
                <span class="src">
                    For example, use
                    <code>const TCHAR *</code> instead of
                    <code>LPCTSTR</code>.
                </span>
                たとえば、<code>LPCTSTR</code>ではなく、<code>const TCHAR *</code>を使用してください。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    When compiling with Microsoft Visual C++, set the
                    compiler to warning level 3 or higher, and treat all
                    warnings as errors.
                </span>
                コンパイラにMicrosoft Visual C++を使う場合は、コンパイラの警告レベルを3以上にし、また、すべての警告をエラーとして扱うように設定してください。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Do not use <code>#pragma once</code>; instead use
                    the standard Google include guards.
                </span>
                <code>#pragma once</code>は使わないでください。かわりに、Google標準のインクルードガードを使用してください。
            </span>
            <span>
                <span class="src">
                    The path in the
                    include guards should be relative to the top of your
                    project tree.
                </span>
                インクルードガードは、プロジェクトツリーのルートからの相対パスを使用して命名します。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    In fact, do not use any nonstandard extensions,
                    like <code>#pragma</code> and <code>__declspec</code>,
                    unless you absolutely must.
                </span>
                <code>#pragma</code>や<code>__declspec</code>などの非標準の拡張については、どうしてもそれを必要とする場合を除いて、使用しないでください。
            </span>
            <span>
                <span class="src">
                    Using
                    <code>__declspec(dllimport)</code> and
                    <code>__declspec(dllexport)</code> is allowed; however,
                    you must use them through macros such as
                    <code>DLLIMPORT</code> and <code>DLLEXPORT</code>, so
                    that someone can easily disable the extensions if they
                    share the code.
                </span>
                <code>__declspec(dllimport)</code>と<code>__declspec(dllexport)</code>は使用してかまいません。しかし、その場合であっても、必ず<code>DLLIMPORT</code>や<code>DLLEXPORT</code>のようなマクロを通して使うようにしてください。そのようにしておくことで、コードが共有されたときに、他の人が簡単にそのような拡張を無効化することができるようになります。
            </span>
        </li>
    </ul>

    <p>
        <span>
            <span class="src">
                However, there are just a few rules that we
                occasionally need to break on Windows:
            </span>
            また、Windowsにおいては、いくつかのルールについて、破らざるをえないことがあります。
        </span>
    </p>

    <ul>
        <li>
            <span>
                <span class="src">
                    Normally we <a href="#Multiple_Inheritance">strongly discourage
                    the use of multiple implementation inheritance</a>;
                    however, it is required when using COM and some ATL/WTL
                    classes.
                </span>
                通常、<a href="#Multiple_Inheritance">実装の多重継承は強く非推奨</a>としていますが、COMやATL/WTLのクラスを使う場合には、それらはむしろ必須になってきます。
            </span>
            <span>
                <span class="src">
                    You may use multiple implementation
                    inheritance to implement COM or ATL/WTL classes and
                    interfaces.
                </span>
                COMやATL/WTLのクラスやインターフェースを実装するためであれば、実装の多重継承を行ってもかまいません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Although you should not use exceptions in your own
                    code, they are used extensively in the ATL and some
                    STLs, including the one that comes with Visual C++.
                </span>
                例外は、ユーザコードで使うべきではありませんが、ATLやSTLやその他のVisual C++由来のコードにおいて、広く使われています。
            </span>
            <span>
                <span class="src">
                    When using the ATL, you should define
                    <code>_ATL_NO_EXCEPTIONS</code> to disable exceptions.
                </span>
                ATLを使う場合には、<code>_ATL_NO_EXCEPTIONS</code>を定義して、例外を無効にしてください。
            </span>
            <span>
                <span class="src">
                    You should investigate whether you can also disable
                    exceptions in your STL, but if not, it is OK to turn on
                    exceptions in the compiler.
                </span>
                また、STLを使う場合は、そのSTLで例外を無効にできないか確認してください。例外を無効にできない場合は、コンパイラの設定で例外を有効にしてもかまいません。
            </span>
            <span>
                <span class="src">
                    (Note that this is only to
                    get the STL to compile.
                </span>
                ただし、これはあくまで、STLをコンパイルできるようにするためのものであり、
            </span>
            <span>
                <span class="src">
                    You should still not write
                    exception handling code yourself.)
                </span>
                この場合でも、ユーザーコードにおいて、例外を処理するコードを書いてはいけません。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    The usual way of working with precompiled headers
                    is to include a header file at the top of each source
                    file, typically with a name like
                    <code>StdAfx.h</code> or <code>precompile.h</code>.
                </span>
                一般的なプリコンパイル済みヘッダーの使い方は、各ソースファイルの先頭でそれを<code>#include</code>する手法です。
                典型的には、プリコンパイルヘッダーには<code>StdAfx.h</code>や<code>precompile.h</code>といったファイル名がつけられます。
            </span>
            <span>
                <span class="src">
                    To make your code easier
                    to share with other projects, avoid including this file
                    explicitly (except in
                    <code>precompile.cc</code>), and
                    use the
                    <code>/FI</code> compiler option to include the
                    file automatically.
                </span>
                他のプロジェクトとコードを共有しやすくするために、(<code>precompile.cc</code>を除いて)明示的にこのファイルを<code>#include</code>するのは避け、かわりに、コンパイラオプションの<code>/FI</code>を使って、そのファイルが自動的にインクルードされるように設定してください。
            </span>
        </li>

        <li>
            <span>
                <span class="src">
                    Resource headers, which are usually named
                    <code>resource.h</code> and contain only macros, do not
                    need to conform to these style guidelines.
                </span>
                リソースヘッダー(通常は<code>resource.h</code>という名前を持ち、マクロのみを含んでいるファイル)については、このスタイルガイドのルールに従う必要はありません。
            </span>
        </li>
    </ul>
</div>

</body>

</html>